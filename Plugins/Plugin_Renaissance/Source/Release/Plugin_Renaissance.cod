; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\Dominik\Google Drive\TLD\Script\Plugin_Renaissance\Source\Plugin_Renaissance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?OldZoom@@3HA					; OldZoom
PUBLIC	?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
PUBLIC	?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
PUBLIC	?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
PUBLIC	?MyData@@3UStrMyData@@A				; MyData
PUBLIC	?StepRight@@3_NA				; StepRight
PUBLIC	?NoFlyby@@3HA					; NoFlyby
PUBLIC	?TexMyPluginName@@3PADA				; TexMyPluginName
PUBLIC	?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
PUBLIC	?AnimateItem@@3P6AXPAUStrItemTr4@@@ZA		; AnimateItem
PUBLIC	?MoveLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA ; MoveLaraPosition
PUBLIC	?TestBoundCollide@@3P6A_NPAUStrItemTr4@@0H@ZA	; TestBoundCollide
PUBLIC	?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA ; GetBestFrame
PUBLIC	?ItemPushLara@@3P6AXPAUStrItemTr4@@0PAUStrCollisionLara@@_NH@ZA ; ItemPushLara
PUBLIC	?AddActiveItem@@3P6AXF@ZA			; AddActiveItem
PUBLIC	?AlterFOV@@3P6AXG@ZA				; AlterFOV
PUBLIC	?SoundEffect@@3P6AXHPAXH@ZA			; SoundEffect
PUBLIC	?TestCollision@@3P6AKPAUStrItemTr4@@0@ZA	; TestCollision
PUBLIC	?MyDllInstance@@3PAUHINSTANCE__@@A		; MyDllInstance
PUBLIC	?MyTomb4PatcherAddress@@3KA			; MyTomb4PatcherAddress
PUBLIC	?SubPatchArray@@3PAPAXA				; SubPatchArray
PUBLIC	??_C@_0BE@KDOKDHCG@Init?5Alchemy?5Puzzle?$AA@	; `string'
PUBLIC	??_C@_0BA@JKNOKBCP@FE_ALCHEMY_MOVE?$AA@		; `string'
PUBLIC	??_C@_0BL@CMEKIMAC@Ring?5?$CFd?0?5Lock?5?$CFb?0?5State?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BD@FKMCNLHN@FE_ALCHEMY_LOCK?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@ ; `string'
PUBLIC	??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@ ; `string'
PUBLIC	??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@ ; `string'
PUBLIC	??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@ ; `string'
PUBLIC	??_C@_0BP@FHDDNNFO@AP1?5?$CFd?0?5AP2?5?$CFd?0?5AP3?5?$CFd?0?5AP4?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_07HFBPLNKF@Anim?5?$CFd?$AA@		; `string'
EXTRN	@__security_check_cookie@4:PROC
?OldZoom@@3HA DD 01H DUP (?)				; OldZoom
?SearchObject4TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject4TestPosition
?SearchObject2TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject2TestPosition
?SearchObject1TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject1TestPosition
?MyData@@3UStrMyData@@A DB 0fd1H DUP (?)		; MyData
	ALIGN	4

?StepRight@@3_NA DB 01H DUP (?)				; StepRight
	ALIGN	4

?NoFlyby@@3HA DD 01H DUP (?)				; NoFlyby
?TexMyPluginName@@3PADA DB 050H DUP (?)			; TexMyPluginName
?SearchObject3TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject3TestPosition
?MyDllInstance@@3PAUHINSTANCE__@@A DD 01H DUP (?)	; MyDllInstance
?MyTomb4PatcherAddress@@3KA DD 01H DUP (?)		; MyTomb4PatcherAddress
?SubPatchArray@@3PAPAXA DD 01H DUP (?)			; SubPatchArray
;	COMDAT ??_C@_07HFBPLNKF@Anim?5?$CFd?$AA@
CONST	SEGMENT
??_C@_07HFBPLNKF@Anim?5?$CFd?$AA@ DB 'Anim %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FHDDNNFO@AP1?5?$CFd?0?5AP2?5?$CFd?0?5AP3?5?$CFd?0?5AP4?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BP@FHDDNNFO@AP1?5?$CFd?0?5AP2?5?$CFd?0?5AP3?5?$CFd?0?5AP4?5?$CFd?$AA@ DB 'A'
	DB	'P1 %d, AP2 %d, AP3 %d, AP4 %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@
CONST	SEGMENT
??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@ DB 'ERROR: t'
	DB	'oo many AssignSlot= commands for current plugin', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@
CONST	SEGMENT
??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@ DB 'WARNING: con'
	DB	'dition trigger number %d has not been handled in cbConditionM'
	DB	'ine() function', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@
CONST	SEGMENT
??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@ DB 'WARNING:'
	DB	' action trigger number %d has not been handled in cbActionMin'
	DB	'e() function', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@
CONST	SEGMENT
??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@ DB 'WARNING: Fli'
	DB	'peffect trigger number %d has not been handled in cbFlipEffec'
	DB	'tMine() function', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FKMCNLHN@FE_ALCHEMY_LOCK?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@FKMCNLHN@FE_ALCHEMY_LOCK?5?$CFd?$AA@ DB 'FE_ALCHEMY_LOCK %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CMEKIMAC@Ring?5?$CFd?0?5Lock?5?$CFb?0?5State?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@CMEKIMAC@Ring?5?$CFd?0?5Lock?5?$CFb?0?5State?5?$CFd?$AA@ DB 'Ri'
	DB	'ng %d, Lock %b, State %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JKNOKBCP@FE_ALCHEMY_MOVE?$AA@
CONST	SEGMENT
??_C@_0BA@JKNOKBCP@FE_ALCHEMY_MOVE?$AA@ DB 'FE_ALCHEMY_MOVE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KDOKDHCG@Init?5Alchemy?5Puzzle?$AA@
CONST	SEGMENT
??_C@_0BE@KDOKDHCG@Init?5Alchemy?5Puzzle?$AA@ DB 'Init Alchemy Puzzle', 00H ; `string'
?AnimateItem@@3P6AXPAUStrItemTr4@@@ZA DD 0449280H	; AnimateItem
?MoveLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA DD 0447b50H ; MoveLaraPosition
?TestBoundCollide@@3P6A_NPAUStrItemTr4@@0H@ZA DD 0447270H ; TestBoundCollide
?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA DD 0450560H ; GetBestFrame
?ItemPushLara@@3P6AXPAUStrItemTr4@@0PAUStrCollisionLara@@_NH@ZA DD 0446ec0H ; ItemPushLara
?AddActiveItem@@3P6AXF@ZA DD 0453c10H			; AddActiveItem
?AlterFOV@@3P6AXG@ZA DD 048d660H			; AlterFOV
?SoundEffect@@3P6AXHPAXH@ZA DD 045e440H			; SoundEffect
?TestCollision@@3P6AKPAUStrItemTr4@@0@ZA DD 045ed00H	; TestCollision
PUBLIC	?AnimatingCollision@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; AnimatingCollision
; Function compile flags: /Ogtp
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\plugin_renaissance.cpp
;	COMDAT ?AnimatingCollision@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z
_TEXT	SEGMENT
_ItemIndex$ = 8						; size = 2
_laraitem$ = 12						; size = 4
_coll$ = 16						; size = 4
?AnimatingCollision@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z PROC ; AnimatingCollision, COMDAT

; 758  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 759  : 	StrItemTr4 *item;
; 760  : 
; 761  : 	item = &items[ItemIndex];

  00003	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00008	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0000e	53		 push	 ebx

; 762  : 	if (!TestBoundCollide(item, laraitem, coll->LaraSizeX))

  0000f	8b 5d 10	 mov	 ebx, DWORD PTR _coll$[ebp]
  00012	8b 53 48	 mov	 edx, DWORD PTR [ebx+72]
  00015	56		 push	 esi
  00016	0f bf 75 08	 movsx	 esi, WORD PTR _ItemIndex$[ebp]
  0001a	69 f6 f6 15 00
	00		 imul	 esi, 5622		; 000015f6H
  00020	03 71 08	 add	 esi, DWORD PTR [ecx+8]
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _laraitem$[ebp]
  00027	52		 push	 edx
  00028	57		 push	 edi
  00029	56		 push	 esi
  0002a	b8 70 72 44 00	 mov	 eax, 4485744		; 00447270H
  0002f	ff d0		 call	 eax
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	84 c0		 test	 al, al
  00036	74 21		 je	 SHORT $LN3@AnimatingC

; 763  : 		return;
; 764  : 	if (!TestCollision(item, laraitem))

  00038	57		 push	 edi
  00039	56		 push	 esi
  0003a	b9 00 ed 45 00	 mov	 ecx, 4582656		; 0045ed00H
  0003f	ff d1		 call	 ecx
  00041	83 c4 08	 add	 esp, 8
  00044	85 c0		 test	 eax, eax
  00046	74 11		 je	 SHORT $LN3@AnimatingC

; 765  : 		return;
; 766  : 
; 767  : 	ItemPushLara(item, laraitem, coll, 0, 1);

  00048	6a 01		 push	 1
  0004a	6a 00		 push	 0
  0004c	53		 push	 ebx
  0004d	57		 push	 edi
  0004e	56		 push	 esi
  0004f	ba c0 6e 44 00	 mov	 edx, 4484800		; 00446ec0H
  00054	ff d2		 call	 edx
  00056	83 c4 14	 add	 esp, 20			; 00000014H
$LN3@AnimatingC:
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 768  : }

  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?AnimatingCollision@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ENDP ; AnimatingCollision
_TEXT	ENDS
PUBLIC	?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z ; PerformMyProgrAction
; Function compile flags: /Ogtp
;	COMDAT ?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z
_TEXT	SEGMENT
?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z PROC ; PerformMyProgrAction, COMDAT

; 711  : 
; 712  : 
; 713  : 	switch (pAction->ActionType) {
; 714  : // replace the "case -1:" with your first "case AXN_...:" progressive action to manage)		
; 715  : 	case -1:
; 716  : 		break;
; 717  : 
; 718  : 	}
; 719  : 
; 720  : }

  00000	c3		 ret	 0
?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z ENDP ; PerformMyProgrAction
_TEXT	ENDS
PUBLIC	?BinocularsZoom@@YAXXZ				; BinocularsZoom
; Function compile flags: /Ogtp
;	COMDAT ?BinocularsZoom@@YAXXZ
_TEXT	SEGMENT
?BinocularsZoom@@YAXXZ PROC				; BinocularsZoom, COMDAT

; 640  : 	if (*Trng.pGlobTomb4->pAdr->pTestLaserSight || (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & FL2_IS_USING_LASER_SIGHT_OR_BINOCULARS))

  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00005	8b 80 4a 34 19
	00		 mov	 eax, DWORD PTR [eax+1651786]
  0000b	8b 88 b4 01 00
	00		 mov	 ecx, DWORD PTR [eax+436]
  00011	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00014	75 1e		 jne	 SHORT $LN4@Binoculars
  00016	8b 90 90 00 00
	00		 mov	 edx, DWORD PTR [eax+144]
  0001c	f6 02 10	 test	 BYTE PTR [edx], 16	; 00000010H
  0001f	75 13		 jne	 SHORT $LN4@Binoculars

; 646  : 		}
; 647  : 	}
; 648  : 	else if (OldZoom != 128) // Set default value when not used

  00021	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00026	39 05 00 00 00
	00		 cmp	 DWORD PTR ?OldZoom@@3HA, eax ; OldZoom
  0002c	74 41		 je	 SHORT $LN3@Binoculars

; 645  : 			OldZoom = *Trng.pGlobTomb4->pAdr->pZoomFactor;

  0002e	a3 00 00 00 00	 mov	 DWORD PTR ?OldZoom@@3HA, eax ; OldZoom

; 649  : 	{
; 650  : 		OldZoom = 128;
; 651  : 	}
; 652  : }

  00033	c3		 ret	 0
$LN4@Binoculars:

; 641  : 	{
; 642  : 		if (*Trng.pGlobTomb4->pAdr->pZoomFactor != OldZoom)

  00034	8b 80 b8 01 00
	00		 mov	 eax, DWORD PTR [eax+440]
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?OldZoom@@3HA ; OldZoom
  00042	74 2b		 je	 SHORT $LN3@Binoculars

; 643  : 		{
; 644  : 			SoundEffect(313, NULL, 0);

  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	68 39 01 00 00	 push	 313			; 00000139H
  0004d	ba 40 e4 45 00	 mov	 edx, 4580416		; 0045e440H
  00052	ff d2		 call	 edx

; 645  : 			OldZoom = *Trng.pGlobTomb4->pAdr->pZoomFactor;

  00054	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00059	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0005f	8b 91 b8 01 00
	00		 mov	 edx, DWORD PTR [ecx+440]
  00065	8b 02		 mov	 eax, DWORD PTR [edx]
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006a	a3 00 00 00 00	 mov	 DWORD PTR ?OldZoom@@3HA, eax ; OldZoom
$LN3@Binoculars:

; 649  : 	{
; 650  : 		OldZoom = 128;
; 651  : 	}
; 652  : }

  0006f	c3		 ret	 0
?BinocularsZoom@@YAXXZ ENDP				; BinocularsZoom
_TEXT	ENDS
PUBLIC	?FreeMemoryParameters@@YAXXZ			; FreeMemoryParameters
; Function compile flags: /Ogtp
;	COMDAT ?FreeMemoryParameters@@YAXXZ
_TEXT	SEGMENT
?FreeMemoryParameters@@YAXXZ PROC			; FreeMemoryParameters, COMDAT

; 340  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 341  : 	int i;
; 342  : 
; 343  : 	for (i=0;i<MyData.BaseParametersMine.TotParameters;i++) {

  00002	33 db		 xor	 ebx, ebx
  00004	33 f6		 xor	 esi, esi
  00006	39 1d a5 0c 00
	00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+3237, ebx
  0000c	7e 40		 jle	 SHORT $LN14@FreeMemory
  0000e	57		 push	 edi
  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
$LL4@FreeMemory:

; 344  : 		FreeMemory(MyData.BaseParametersMine.pVetParameters[i].pVetArg);

  00015	a1 a9 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3241
  0001a	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  0001e	51		 push	 ecx
  0001f	ff d7		 call	 edi
  00021	a1 a5 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3237
  00026	46		 inc	 esi
  00027	83 c4 04	 add	 esp, 4
  0002a	3b f0		 cmp	 esi, eax
  0002c	7c e7		 jl	 SHORT $LL4@FreeMemory

; 345  : 	}
; 346  : 
; 347  : 	if (MyData.BaseParametersMine.TotParameters > 0) {

  0002e	3b c3		 cmp	 eax, ebx
  00030	7e 12		 jle	 SHORT $LN13@FreeMemory

; 348  : 		FreeMemory(MyData.BaseParametersMine.pVetParameters);

  00032	8b 15 a9 0c 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+3241
  00038	52		 push	 edx
  00039	ff d7		 call	 edi
  0003b	83 c4 04	 add	 esp, 4

; 349  : 		MyData.BaseParametersMine.TotParameters=0;

  0003e	89 1d a5 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3237, ebx
$LN13@FreeMemory:

; 350  : 	}
; 351  : 
; 352  : 	MyData.BaseParametersMine.pVetParameters=NULL;

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 1d a9 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3241, ebx
  0004c	5b		 pop	 ebx

; 353  : }

  0004d	c3		 ret	 0
$LN14@FreeMemory:
  0004e	5e		 pop	 esi

; 350  : 	}
; 351  : 
; 352  : 	MyData.BaseParametersMine.pVetParameters=NULL;

  0004f	89 1d a9 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3241, ebx
  00055	5b		 pop	 ebx

; 353  : }

  00056	c3		 ret	 0
?FreeMemoryParameters@@YAXXZ ENDP			; FreeMemoryParameters
_TEXT	ENDS
PUBLIC	?FreeMemoryCustomize@@YAXXZ			; FreeMemoryCustomize
; Function compile flags: /Ogtp
;	COMDAT ?FreeMemoryCustomize@@YAXXZ
_TEXT	SEGMENT
?FreeMemoryCustomize@@YAXXZ PROC			; FreeMemoryCustomize, COMDAT

; 322  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 323  : 	int i;
; 324  : 
; 325  : 	for (i=0;i<MyData.BaseCustomizeMine.TotCustomize;i++) {

  00002	33 db		 xor	 ebx, ebx
  00004	33 f6		 xor	 esi, esi
  00006	39 1d 9d 0c 00
	00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+3229, ebx
  0000c	7e 40		 jle	 SHORT $LN14@FreeMemory@2
  0000e	57		 push	 edi
  0000f	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
$LL4@FreeMemory@2:

; 326  : 		FreeMemory(MyData.BaseCustomizeMine.pVetCustomize[i].pVetArg);

  00015	a1 a1 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3233
  0001a	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  0001e	51		 push	 ecx
  0001f	ff d7		 call	 edi
  00021	a1 9d 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3229
  00026	46		 inc	 esi
  00027	83 c4 04	 add	 esp, 4
  0002a	3b f0		 cmp	 esi, eax
  0002c	7c e7		 jl	 SHORT $LL4@FreeMemory@2

; 327  : 	}
; 328  : 
; 329  : 	if (MyData.BaseCustomizeMine.TotCustomize > 0) {

  0002e	3b c3		 cmp	 eax, ebx
  00030	7e 12		 jle	 SHORT $LN13@FreeMemory@2

; 330  : 		FreeMemory(MyData.BaseCustomizeMine.pVetCustomize);

  00032	8b 15 a1 0c 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+3233
  00038	52		 push	 edx
  00039	ff d7		 call	 edi
  0003b	83 c4 04	 add	 esp, 4

; 331  : 		MyData.BaseCustomizeMine.TotCustomize=0;

  0003e	89 1d 9d 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3229, ebx
$LN13@FreeMemory@2:

; 332  : 	}
; 333  : 
; 334  : 
; 335  : 	MyData.BaseCustomizeMine.pVetCustomize=NULL;

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	89 1d a1 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3233, ebx
  0004c	5b		 pop	 ebx

; 336  : }

  0004d	c3		 ret	 0
$LN14@FreeMemory@2:
  0004e	5e		 pop	 esi

; 332  : 	}
; 333  : 
; 334  : 
; 335  : 	MyData.BaseCustomizeMine.pVetCustomize=NULL;

  0004f	89 1d a1 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3233, ebx
  00055	5b		 pop	 ebx

; 336  : }

  00056	c3		 ret	 0
?FreeMemoryCustomize@@YAXXZ ENDP			; FreeMemoryCustomize
_TEXT	ENDS
PUBLIC	?cbLoadMyData@@YAXPAEK@Z			; cbLoadMyData
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?cbLoadMyData@@YAXPAEK@Z
_TEXT	SEGMENT
_Indice$ = -4						; size = 4
_pAdrZone$ = 8						; size = 4
_SizeData$ = 12						; size = 4
?cbLoadMyData@@YAXPAEK@Z PROC				; cbLoadMyData, COMDAT

; 279  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 280  : 
; 281  : 	WORD *pVetExtras;
; 282  : 	StrParseNGField  ParseField;
; 283  : 	int Indice;
; 284  : 	int i;
; 285  : 	WORD TotActions;
; 286  : 
; 287  : 	
; 288  : 	pVetExtras = (WORD*) pAdrZone;
; 289  : 
; 290  : 	Indice=0;

  00006	8b 75 08	 mov	 esi, DWORD PTR _pAdrZone$[ebp]
  00009	33 d2		 xor	 edx, edx
  0000b	57		 push	 edi
  0000c	89 55 fc	 mov	 DWORD PTR _Indice$[ebp], edx
  0000f	90		 npad	 1
$LL7@cbLoadMyDa:

; 291  : 
; 292  : 	while (ParseNgField(pVetExtras ,Indice, &ParseField)==true) {

  00010	0f b7 04 56	 movzx	 eax, WORD PTR [esi+edx*2]
  00014	a9 00 80 00 00	 test	 eax, 32768		; 00008000H
  00019	74 17		 je	 SHORT $LN12@cbLoadMyDa
  0001b	0f b7 7c 56 02	 movzx	 edi, WORD PTR [esi+edx*2+2]
  00020	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00025	8b c8		 mov	 ecx, eax
  00027	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0002a	c1 e1 10	 shl	 ecx, 16			; 00000010H
  0002d	03 f9		 add	 edi, ecx
  0002f	40		 inc	 eax
  00030	eb 05		 jmp	 SHORT $LN11@cbLoadMyDa
$LN12@cbLoadMyDa:
  00032	8b f8		 mov	 edi, eax
  00034	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
$LN11@cbLoadMyDa:
  00037	85 ff		 test	 edi, edi
  00039	0f 84 8f 00 00
	00		 je	 $LN17@cbLoadMyDa

; 293  : 		
; 294  : 		// recover different ng token
; 295  : 		switch (ParseField.Type) {

  0003f	0f b7 0c 46	 movzx	 ecx, WORD PTR [esi+eax*2]
  00043	49		 dec	 ecx
  00044	74 56		 je	 SHORT $LN1@cbLoadMyDa
  00046	49		 dec	 ecx
  00047	74 3d		 je	 SHORT $LN3@cbLoadMyDa
  00049	49		 dec	 ecx
  0004a	75 76		 jne	 SHORT $LN4@cbLoadMyDa

; 299  : 			break;
; 300  : 
; 301  : 		case NGTAG_GLOBAL_DATA:
; 302  : 			// global data
; 303  : 			memcpy(&MyData.Save.Global, ParseField.pData, sizeof(StrSavegameGlobalData));

  0004c	8b 4c 46 02	 mov	 ecx, DWORD PTR [esi+eax*2+2]
  00050	89 0d 00 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A, ecx
  00056	8b 4c 46 06	 mov	 ecx, DWORD PTR [esi+eax*2+6]
  0005a	89 0d 04 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+4, ecx
  00060	8b 4c 46 0a	 mov	 ecx, DWORD PTR [esi+eax*2+10]
  00064	89 0d 08 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+8, ecx
  0006a	8b 4c 46 0e	 mov	 ecx, DWORD PTR [esi+eax*2+14]
  0006e	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+12, ecx
  00074	8b 44 46 12	 mov	 eax, DWORD PTR [esi+eax*2+18]
  00078	03 fa		 add	 edi, edx
  0007a	a3 10 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+16, eax
  0007f	89 7d fc	 mov	 DWORD PTR _Indice$[ebp], edi

; 314  : 			break;
; 315  : 		}
; 316  : 		Indice= ParseField.NextIndex; 
; 317  : 	}

  00082	8b d7		 mov	 edx, edi
  00084	eb 8a		 jmp	 SHORT $LL7@cbLoadMyDa
$LN3@cbLoadMyDa:

; 296  : 		case NGTAG_LOCAL_DATA:
; 297  : 			// local data
; 298  : 			memcpy(&MyData.Save.Local, ParseField.pData, sizeof(StrSavegameLocalData));

  00086	8a 4c 46 02	 mov	 cl, BYTE PTR [esi+eax*2+2]
  0008a	03 fa		 add	 edi, edx
  0008c	88 0d 14 00 00
	00		 mov	 BYTE PTR ?MyData@@3UStrMyData@@A+20, cl
  00092	89 7d fc	 mov	 DWORD PTR _Indice$[ebp], edi

; 314  : 			break;
; 315  : 		}
; 316  : 		Indice= ParseField.NextIndex; 
; 317  : 	}

  00095	8b d7		 mov	 edx, edi
  00097	e9 74 ff ff ff	 jmp	 $LL7@cbLoadMyDa
$LN1@cbLoadMyDa:

; 304  : 			break;
; 305  : 			
; 306  : 		case NGTAG_PROGRESSIVE_ACTIONS:
; 307  : 			// progressive actions
; 308  : 			i= ParseField.StartDataIndex;
; 309  : 			// read tot actions value
; 310  : 			TotActions = pVetExtras[i++];

  0009c	0f b7 5c 46 02	 movzx	 ebx, WORD PTR [esi+eax*2+2]

; 311  : 			// copy all tot records
; 312  : 			memcpy(&MyData.VetProgrActions[0], &pVetExtras[i], sizeof(StrProgressiveAction) * TotActions);

  000a1	8b d3		 mov	 edx, ebx
  000a3	c1 e2 05	 shl	 edx, 5
  000a6	52		 push	 edx
  000a7	8d 44 46 04	 lea	 eax, DWORD PTR [esi+eax*2+4]
  000ab	50		 push	 eax
  000ac	68 1d 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+29
  000b1	e8 00 00 00 00	 call	 _memcpy

; 313  : 			MyData.TotProgrActions = TotActions;

  000b6	8b 55 fc	 mov	 edx, DWORD PTR _Indice$[ebp]
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	89 1d 15 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+21, ebx
$LN4@cbLoadMyDa:

; 291  : 
; 292  : 	while (ParseNgField(pVetExtras ,Indice, &ParseField)==true) {

  000c2	03 fa		 add	 edi, edx
  000c4	89 7d fc	 mov	 DWORD PTR _Indice$[ebp], edi

; 314  : 			break;
; 315  : 		}
; 316  : 		Indice= ParseField.NextIndex; 
; 317  : 	}

  000c7	8b d7		 mov	 edx, edi
  000c9	e9 42 ff ff ff	 jmp	 $LL7@cbLoadMyDa
$LN17@cbLoadMyDa:
  000ce	5f		 pop	 edi
  000cf	5e		 pop	 esi
  000d0	5b		 pop	 ebx

; 318  : 
; 319  : }

  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c3		 ret	 0
?cbLoadMyData@@YAXPAEK@Z ENDP				; cbLoadMyData
_TEXT	ENDS
PUBLIC	?cbInitLevel@@YAXHHK@Z				; cbInitLevel
; Function compile flags: /Ogtp
;	COMDAT ?cbInitLevel@@YAXHHK@Z
_TEXT	SEGMENT
_LevelNow$ = 8						; size = 4
_LevelOld$ = 12						; size = 4
_FIL_Flags$ = 16					; size = 4
?cbInitLevel@@YAXHHK@Z PROC				; cbInitLevel, COMDAT

; 187  : 	// here you can initialize specific items of currnet level.
; 188  : 	// it will be called only once for level, when all items has been already initialized
; 189  : 	// and just a moment before entering in main game cycle.
; 190  : 	NoFlyby = *Trng.pGlobTomb4->pAdr->pTestFlybyInProgress; // For FOV Fix

  00000	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00005	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0000b	8b 91 14 01 00
	00		 mov	 edx, DWORD PTR [ecx+276]
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	a3 00 00 00 00	 mov	 DWORD PTR ?NoFlyby@@3HA, eax ; NoFlyby

; 191  : }

  00018	c3		 ret	 0
?cbInitLevel@@YAXHHK@Z ENDP				; cbInitLevel
_TEXT	ENDS
PUBLIC	?cbInitGame@@YAXXZ				; cbInitGame
; Function compile flags: /Ogtp
;	COMDAT ?cbInitGame@@YAXXZ
_TEXT	SEGMENT
?cbInitGame@@YAXXZ PROC					; cbInitGame, COMDAT

; 181  : 	// here you can initialize your global data for whole adventure
; 182  : 	// this procedure will be called only once, before loading title level
; 183  : }

  00000	c3		 ret	 0
?cbInitGame@@YAXXZ ENDP					; cbInitGame
_TEXT	ENDS
PUBLIC	?cbInitProgram@@YAXHQAPAD@Z			; cbInitProgram
; Function compile flags: /Ogtp
;	COMDAT ?cbInitProgram@@YAXHQAPAD@Z
_TEXT	SEGMENT
_NumberLoadedPlugins$ = 8				; size = 4
_VetPluginNames$ = 12					; size = 4
?cbInitProgram@@YAXHQAPAD@Z PROC			; cbInitProgram, COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 159  : 
; 160  : 	// save number of plugins (enclosed yours and the tomb_nextgeneration.dll ) and their names
; 161  : 	// these data will be used to locate IDs of any loaded plugins using FindPluginID() function
; 162  : 	Trng.TotPlugins = NumberLoadedPlugins;

  00003	8b 45 08	 mov	 eax, DWORD PTR _NumberLoadedPlugins$[ebp]

; 163  : 	Trng.pVetPluginNames = VetPluginNames;

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _VetPluginNames$[ebp]

; 164  : 
; 165  : 	// clear all my global variables
; 166  : 	ClearMemory(&MyData, sizeof(StrMyData));

  00009	68 d1 0f 00 00	 push	 4049			; 00000fd1H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A ; MyData
  00015	a3 28 00 00 00	 mov	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+40, eax
  0001a	89 0d 2c 00 00
	00		 mov	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+44, ecx
  00020	e8 00 00 00 00	 call	 _memset
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 167  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?cbInitProgram@@YAXHQAPAD@Z ENDP			; cbInitProgram
_TEXT	ENDS
PUBLIC	?MainPatcher@@YAHXZ				; MainPatcher
; Function compile flags: /Odtp
;	COMDAT ?MainPatcher@@YAHXZ
_TEXT	SEGMENT
?MainPatcher@@YAHXZ PROC				; MainPatcher, COMDAT

; 146  : 	and eax, 0ffffh

  00000	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 147  : 	mov eax, dword ptr [SubPatchArray+eax*4];

  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?SubPatchArray@@3PAPAXA[eax*4]

; 148  : 	jmp eax

  0000c	ff e0		 jmp	 eax
?MainPatcher@@YAHXZ ENDP				; MainPatcher
_TEXT	ENDS
PUBLIC	?CreateMyCodePatches@@YA_NXZ			; CreateMyCodePatches
; Function compile flags: /Ogtp
;	COMDAT ?CreateMyCodePatches@@YA_NXZ
_TEXT	SEGMENT
?CreateMyCodePatches@@YA_NXZ PROC			; CreateMyCodePatches, COMDAT

; 115  : 	// the call of the code patch to TYPE_HERE:
; 116  : 	// example: 
; 117  : 	// SET_PATCH(Path_RedirCollision)
; 118  : 	// to call the function Patch_RedirCollision() created with TrngPatcher program (command Assmembly->Create Dynamic Patch Generator)
; 119  : 
; 120  : 	return true;

  00000	b0 01		 mov	 al, 1

; 121  : }

  00002	c3		 ret	 0
?CreateMyCodePatches@@YA_NXZ ENDP			; CreateMyCodePatches
PUBLIC	?AlchemyPuzzleControl@@YAXF@Z			; AlchemyPuzzleControl
; Function compile flags: /Ogtp
;	COMDAT ?AlchemyPuzzleControl@@YAXF@Z
_TEXT	SEGMENT
_ItemIndex$ = 8						; size = 2
?AlchemyPuzzleControl@@YAXF@Z PROC			; AlchemyPuzzleControl, COMDAT

; 1014 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1015 : 	int state;
; 1016 : 	StrItemTr4* item;
; 1017 : 	item = &items[ItemIndex];

  00005	0f bf 75 08	 movsx	 esi, WORD PTR _ItemIndex$[ebp]
  00009	69 f6 f6 15 00
	00		 imul	 esi, 5622		; 000015f6H
  0000f	57		 push	 edi
  00010	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00016	8b 8f 4a 34 19
	00		 mov	 ecx, DWORD PTR [edi+1651786]
  0001c	03 71 08	 add	 esi, DWORD PTR [ecx+8]

; 1018 : 
; 1019 : 	state = MyData.Save.Global.Puzzle[AlchemyPuzzleSlot()].State;
; 1020 : 	
; 1021 : 	if (state != GetRelativeAnim())

  0001f	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00022	0f b7 46 0c	 movzx	 eax, WORD PTR [esi+12]
  00026	8b 94 80 32 f6
	ff ff		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A[eax+eax*4-2510]
  0002d	0f b7 5e 14	 movzx	 ebx, WORD PTR [esi+20]
  00031	c1 e0 06	 shl	 eax, 6
  00034	0f b7 4c 01 26	 movzx	 ecx, WORD PTR [ecx+eax+38]
  00039	2b d9		 sub	 ebx, ecx
  0003b	3b d3		 cmp	 edx, ebx
  0003d	74 15		 je	 SHORT $LN1@AlchemyPuz

; 1022 : 		item->AnimationNow = SetRelativeAnim();

  0003f	8b 8f 4a 34 19
	00		 mov	 ecx, DWORD PTR [edi+1651786]
  00045	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00048	66 8b 44 01 26	 mov	 ax, WORD PTR [ecx+eax+38]
  0004d	66 03 c2	 add	 ax, dx
  00050	66 89 46 14	 mov	 WORD PTR [esi+20], ax
$LN1@AlchemyPuz:

; 1023 : 
; 1024 : 	SendToLog("AP1 %d, AP2 %d, AP3 %d, AP4 %d", MyData.Save.Global.Puzzle[0].State, MyData.Save.Global.Puzzle[1].State, MyData.Save.Global.Puzzle[2].State, MyData.Save.Global.Puzzle[3].State);

  00054	8b 0d 0f 00 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+15
  0005a	8b 15 0a 00 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+10
  00060	a1 05 00 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+5
  00065	51		 push	 ecx
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A
  0006c	52		 push	 edx
  0006d	50		 push	 eax
  0006e	51		 push	 ecx
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@FHDDNNFO@AP1?5?$CFd?0?5AP2?5?$CFd?0?5AP3?5?$CFd?0?5AP4?5?$CFd?$AA@
  00074	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog

; 1025 : 	SendToLog("Anim %d", GetRelativeAnim());

  00079	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0007f	0f b7 4e 0c	 movzx	 ecx, WORD PTR [esi+12]
  00083	8b 82 4a 34 19
	00		 mov	 eax, DWORD PTR [edx+1651786]
  00089	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0008c	c1 e1 06	 shl	 ecx, 6
  0008f	0f b7 44 0a 26	 movzx	 eax, WORD PTR [edx+ecx+38]
  00094	0f b7 4e 14	 movzx	 ecx, WORD PTR [esi+20]
  00098	2b c8		 sub	 ecx, eax
  0009a	51		 push	 ecx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_07HFBPLNKF@Anim?5?$CFd?$AA@
  000a0	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog

; 1026 : 
; 1027 : 	AnimateItem(item);

  000a5	56		 push	 esi
  000a6	ba 80 92 44 00	 mov	 edx, 4493952		; 00449280H
  000ab	ff d2		 call	 edx
  000ad	83 c4 20	 add	 esp, 32			; 00000020H
  000b0	5f		 pop	 edi
  000b1	5e		 pop	 esi
  000b2	5b		 pop	 ebx

; 1028 : }

  000b3	5d		 pop	 ebp
  000b4	c3		 ret	 0
?AlchemyPuzzleControl@@YAXF@Z ENDP			; AlchemyPuzzleControl
_TEXT	ENDS
PUBLIC	?cbProgrActionMine@@YAXXZ			; cbProgrActionMine
; Function compile flags: /Ogtp
;	COMDAT ?cbProgrActionMine@@YAXXZ
_TEXT	SEGMENT
?cbProgrActionMine@@YAXXZ PROC				; cbProgrActionMine, COMDAT

; 724  : 	int i;
; 725  : 	StrProgressiveAction *pAction;
; 726  : 
; 727  : 	pAction = &MyData.VetProgrActions[0];
; 728  : 	for (i=0;i<MyData.TotProgrActions;i++) {
; 729  : 		if (pAction->ActionType != AXN_FREE) {
; 730  : 			PerformMyProgrAction(pAction);
; 731  : 		}
; 732  : 		pAction++;
; 733  : 	}
; 734  : 
; 735  : 
; 736  : }

  00000	c3		 ret	 0
?cbProgrActionMine@@YAXXZ ENDP				; cbProgrActionMine
_TEXT	ENDS
PUBLIC	?cbCycleBegin@@YAXXZ				; cbCycleBegin
; Function compile flags: /Ogtp
;	COMDAT ?cbCycleBegin@@YAXXZ
_TEXT	SEGMENT
?cbCycleBegin@@YAXXZ PROC				; cbCycleBegin, COMDAT

; 694  : 	BinocularsZoom();

  00000	e9 00 00 00 00	 jmp	 ?BinocularsZoom@@YAXXZ	; BinocularsZoom
?cbCycleBegin@@YAXXZ ENDP				; cbCycleBegin
_TEXT	ENDS
PUBLIC	?cbParametersMine@@YAXGHPAF@Z			; cbParametersMine
; Function compile flags: /Ogtp
;	COMDAT ?cbParametersMine@@YAXGHPAF@Z
_TEXT	SEGMENT
_TotParam$ = -4						; size = 4
_ParameterValue$ = 8					; size = 2
_NumberOfItems$ = 12					; size = 4
_pItemArray$ = 16					; size = 4
?cbParametersMine@@YAXGHPAF@Z PROC			; cbParametersMine, COMDAT

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 568  : 	// here you can replace this default management of anonymous parameters commands
; 569  : 	// with your procedure where you can recognize each different Param_ value and 
; 570  : 	// save its arguments in meaningful names fields, or elaboriting them immediatly
; 571  : 	// when it is possible (warning: in this moment nothing of level it has been yet loaded, excepting the script section)
; 572  : 
; 573  : 	// ----- default management (optional)----
; 574  : 	// all parameters values will be saved in MyData structure
; 575  : 	DWORD SizeMem;
; 576  : 	StrGenericParameters *pMyParam;
; 577  : 	int TotParam;
; 578  : 
; 579  : 	// ask memory to have another (new) record of StrGenericparameters structure
; 580  : 	TotParam= MyData.BaseParametersMine.TotParameters;
; 581  : 	TotParam++;

  00004	a1 a5 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3237
  00009	53		 push	 ebx
  0000a	40		 inc	 eax
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 582  : 	SizeMem = TotParam * sizeof(StrGenericParameters);

  0000d	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
  00014	89 45 fc	 mov	 DWORD PTR _TotParam$[ebp], eax

; 583  : 	MyData.BaseParametersMine.pVetParameters = 
; 584  : 		(StrGenericParameters *) ResizeMemory(MyData.BaseParametersMine.pVetParameters, SizeMem);

  00017	a1 a9 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3241
  0001c	57		 push	 edi
  0001d	85 c0		 test	 eax, eax
  0001f	75 0b		 jne	 SHORT $LN3@cbParamete
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00027	83 c4 04	 add	 esp, 4
  0002a	eb 0a		 jmp	 SHORT $LN10@cbParamete
$LN3@cbParamete:
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00033	83 c4 08	 add	 esp, 8
$LN10@cbParamete:

; 585  : 
; 586  : 	pMyParam = & MyData.BaseParametersMine.pVetParameters[TotParam-1];
; 587  : 	
; 588  : 	// now require memory for all arguments (NumberOfItems) store in pItemArray
; 589  : 
; 590  : 	pMyParam->pVetArg = (short *) GetMemory(2 * NumberOfItems);

  00036	8b 5d 0c	 mov	 ebx, DWORD PTR _NumberOfItems$[ebp]
  00039	8b f0		 mov	 esi, eax
  0003b	03 db		 add	 ebx, ebx
  0003d	53		 push	 ebx
  0003e	89 35 a9 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3241, esi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 591  : 	// copy data
; 592  : 	pMyParam->NArguments = NumberOfItems;
; 593  : 	memcpy(pMyParam->pVetArg, pItemArray, 2*NumberOfItems);

  0004a	8b 55 10	 mov	 edx, DWORD PTR _pItemArray$[ebp]
  0004d	66 8b 4d 0c	 mov	 cx, WORD PTR _NumberOfItems$[ebp]
  00051	53		 push	 ebx
  00052	52		 push	 edx
  00053	50		 push	 eax
  00054	89 44 37 fc	 mov	 DWORD PTR [edi+esi-4], eax
  00058	66 89 4c 37 fa	 mov	 WORD PTR [edi+esi-6], cx
  0005d	e8 00 00 00 00	 call	 _memcpy

; 594  : 
; 595  : 	MyData.BaseParametersMine.TotParameters= TotParam;

  00062	8b 45 fc	 mov	 eax, DWORD PTR _TotParam$[ebp]
  00065	83 c4 10	 add	 esp, 16			; 00000010H
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	a3 a5 0c 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3237, eax
  0006f	5b		 pop	 ebx

; 596  : 	// ---- end of default managemnt for generic parameters -------------
; 597  : 
; 598  : 
; 599  : }

  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?cbParametersMine@@YAXGHPAF@Z ENDP			; cbParametersMine
_TEXT	ENDS
PUBLIC	?cbAssignSlotMine@@YAXGG@Z			; cbAssignSlotMine
; Function compile flags: /Ogtp
;	COMDAT ?cbAssignSlotMine@@YAXGG@Z
_TEXT	SEGMENT
_Slot$ = 8						; size = 2
_ObjType$ = 12						; size = 2
?cbAssignSlotMine@@YAXGG@Z PROC				; cbAssignSlotMine, COMDAT

; 545  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 546  : 	int i;
; 547  : 
; 548  : 	i = MyData.BaseAssignSlotMine.TotAssign;

  00003	a1 ad 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3245

; 549  : 
; 550  : 	if (i >= MAX_ASSIGN_SLOT_MINE) {

  00008	3d c8 00 00 00	 cmp	 eax, 200		; 000000c8H
  0000d	7c 0f		 jl	 SHORT $LN1@cbAssignSl

; 551  : 		SendToLog("ERROR: too many AssignSlot= commands for current plugin");

  0000f	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@
  00014	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00019	83 c4 04	 add	 esp, 4

; 558  : 
; 559  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
$LN1@cbAssignSl:

; 552  : 		return;
; 553  : 	}
; 554  : 
; 555  : 	MyData.BaseAssignSlotMine.VetAssignSlot[i].MioSlot = Slot;

  0001e	66 8b 4d 08	 mov	 cx, WORD PTR _Slot$[ebp]

; 556  : 	MyData.BaseAssignSlotMine.VetAssignSlot[i].TipoSlot = ObjType;

  00022	66 8b 55 0c	 mov	 dx, WORD PTR _ObjType$[ebp]
  00026	66 89 0c 85 b1
	0c 00 00	 mov	 WORD PTR ?MyData@@3UStrMyData@@A[eax*4+3249], cx
  0002e	66 89 14 85 b3
	0c 00 00	 mov	 WORD PTR ?MyData@@3UStrMyData@@A[eax*4+3251], dx

; 557  : 	MyData.BaseAssignSlotMine.TotAssign++;

  00036	ff 05 ad 0c 00
	00		 inc	 DWORD PTR ?MyData@@3UStrMyData@@A+3245

; 558  : 
; 559  : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?cbAssignSlotMine@@YAXGG@Z ENDP				; cbAssignSlotMine
_TEXT	ENDS
PUBLIC	?cbCustomizeMine@@YAXGHPAF@Z			; cbCustomizeMine
; Function compile flags: /Ogtp
;	COMDAT ?cbCustomizeMine@@YAXGHPAF@Z
_TEXT	SEGMENT
_TotCust$ = -4						; size = 4
_CustomizeValue$ = 8					; size = 2
_NumberOfItems$ = 12					; size = 4
_pItemArray$ = 16					; size = 4
?cbCustomizeMine@@YAXGHPAF@Z PROC			; cbCustomizeMine, COMDAT

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 511  : 	// here you can replace this default management of anonymous customize commands
; 512  : 	// with your procedure where you can recognize each different CUST_ value and 
; 513  : 	// save its arguments in meaningful names fields, or elaboriting them immediatly
; 514  : 	// when it is possible (warning: in this moment nothing of level it has been yet loaded, excepting the script section)
; 515  : 
; 516  : 	// ----- default management (optional)----
; 517  : 	// all customize values will be saved in MyData structure
; 518  : 	DWORD SizeMem;
; 519  : 	StrGenericCustomize *pMyCust;
; 520  : 	int TotCust;
; 521  : 
; 522  : 	// ask memory to have another (new) record of StrGenericCustomize structure
; 523  : 	TotCust= MyData.BaseCustomizeMine.TotCustomize;
; 524  : 	TotCust++;

  00004	a1 9d 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3229
  00009	53		 push	 ebx
  0000a	40		 inc	 eax
  0000b	56		 push	 esi
  0000c	57		 push	 edi

; 525  : 	SizeMem = TotCust * sizeof(StrGenericCustomize);

  0000d	8d 3c c5 00 00
	00 00		 lea	 edi, DWORD PTR [eax*8]
  00014	89 45 fc	 mov	 DWORD PTR _TotCust$[ebp], eax

; 526  : 	MyData.BaseCustomizeMine.pVetCustomize = 
; 527  : 				(StrGenericCustomize *) ResizeMemory(MyData.BaseCustomizeMine.pVetCustomize, SizeMem);

  00017	a1 a1 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3233
  0001c	57		 push	 edi
  0001d	85 c0		 test	 eax, eax
  0001f	75 0b		 jne	 SHORT $LN3@cbCustomiz
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00027	83 c4 04	 add	 esp, 4
  0002a	eb 0a		 jmp	 SHORT $LN10@cbCustomiz
$LN3@cbCustomiz:
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00033	83 c4 08	 add	 esp, 8
$LN10@cbCustomiz:

; 528  : 
; 529  : 	pMyCust = & MyData.BaseCustomizeMine.pVetCustomize[TotCust-1];
; 530  : 	
; 531  : 	// now require memory for all arguments (NumberOfItems) store in pItemArray
; 532  : 
; 533  : 	pMyCust->pVetArg = (short *) GetMemory(2 * NumberOfItems);

  00036	8b 5d 0c	 mov	 ebx, DWORD PTR _NumberOfItems$[ebp]
  00039	8b f0		 mov	 esi, eax
  0003b	03 db		 add	 ebx, ebx
  0003d	53		 push	 ebx
  0003e	89 35 a1 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3233, esi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 534  : 	// copy data
; 535  : 	pMyCust->NArguments = NumberOfItems;
; 536  : 	memcpy(pMyCust->pVetArg, pItemArray, 2*NumberOfItems);

  0004a	8b 55 10	 mov	 edx, DWORD PTR _pItemArray$[ebp]
  0004d	66 8b 4d 0c	 mov	 cx, WORD PTR _NumberOfItems$[ebp]
  00051	53		 push	 ebx
  00052	52		 push	 edx
  00053	50		 push	 eax
  00054	89 44 37 fc	 mov	 DWORD PTR [edi+esi-4], eax
  00058	66 89 4c 37 fa	 mov	 WORD PTR [edi+esi-6], cx
  0005d	e8 00 00 00 00	 call	 _memcpy

; 537  : 	pMyCust->CustValue = CustomizeValue;

  00062	66 8b 45 08	 mov	 ax, WORD PTR _CustomizeValue$[ebp]

; 538  : 
; 539  : 	MyData.BaseCustomizeMine.TotCustomize= TotCust;

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _TotCust$[ebp]
  00069	83 c4 10	 add	 esp, 16			; 00000010H
  0006c	66 89 44 37 f8	 mov	 WORD PTR [edi+esi-8], ax
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	89 0d 9d 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3229, ecx
  00079	5b		 pop	 ebx

; 540  : 	// ---- end of default managemnt for generic customize -------------	
; 541  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?cbCustomizeMine@@YAXGHPAF@Z ENDP			; cbCustomizeMine
_TEXT	ENDS
PUBLIC	?cbConditionMine@@YAHGHGG@Z			; cbConditionMine
; Function compile flags: /Ogtp
;	COMDAT ?cbConditionMine@@YAHGHGG@Z
_TEXT	SEGMENT
_ConditionIndex$ = 8					; size = 2
_ItemIndex$ = 12					; size = 4
_Extra$ = 16						; size = 2
_ActivationMode$ = 20					; size = 2
?cbConditionMine@@YAHGHGG@Z PROC			; cbConditionMine, COMDAT

; 482  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 483  : 	int RetValue;
; 484  : 	
; 485  : 	RetValue=CTRET_ONLY_ONCE_ON_TRUE;
; 486  : 
; 487  : 	switch (ConditionIndex){

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _ConditionIndex$[ebp]
  00007	83 f8 ff	 cmp	 eax, -1
  0000a	74 0e		 je	 SHORT $LN7@cbConditio

; 488  : 		// type here the code for your condition trigger, inserting the code in the section
; 489  : 		// beginning with "case NumberOfAction:" and ending with row "break;"
; 490  : 	case -1:
; 491  : 		// note: remove this "case -1:" and its "break;" it has been added only to avoid warning messages about empty switch
; 492  : 		break;
; 493  : 	default:
; 494  : 		SendToLog("WARNING: condition trigger number %d has not been handled in cbConditionMine() function", ConditionIndex);

  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@
  00012	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00017	83 c4 08	 add	 esp, 8
$LN7@cbConditio:

; 495  : 		break;
; 496  : 
; 497  : 
; 498  : 	}
; 499  : 	return RetValue;

  0001a	b8 10 00 00 00	 mov	 eax, 16			; 00000010H

; 500  : 	  
; 501  : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?cbConditionMine@@YAHGHGG@Z ENDP			; cbConditionMine
_TEXT	ENDS
PUBLIC	?cbActionMine@@YAHGHGG@Z			; cbActionMine
; Function compile flags: /Ogtp
;	COMDAT ?cbActionMine@@YAHGHGG@Z
_TEXT	SEGMENT
_ActionIndex$ = 8					; size = 2
_ItemIndex$ = 12					; size = 4
_Extra$ = 16						; size = 2
_ActivationMode$ = 20					; size = 2
?cbActionMine@@YAHGHGG@Z PROC				; cbActionMine, COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 457  : 	int RetValue;
; 458  : 	
; 459  : 	RetValue=TRET_PERFORM_ONCE_AND_GO;
; 460  : 
; 461  : 	switch (ActionIndex) {

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _ActionIndex$[ebp]
  00007	56		 push	 esi
  00008	be 01 00 00 00	 mov	 esi, 1
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	74 0e		 je	 SHORT $LN3@cbActionMi

; 462  : 		// type here the code per your action trigger.
; 463  : 		// add "case Number:" and complete the code with "break;" instruction
; 464  : 	case -1:
; 465  : 		// note: remove this "case -1:" and its "break;" it has been added only to avoid warning messages about empty switch
; 466  : 		break;
; 467  : 	default:
; 468  : 		SendToLog("WARNING: action trigger number %d has not been handled in cbActionMine() function", ActionIndex);

  00012	50		 push	 eax
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@
  00018	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0001d	83 c4 08	 add	 esp, 8
$LN3@cbActionMi:

; 469  : 		break;
; 470  : 	}
; 471  : 	
; 472  : 	// if there was the one-shot button enabled, return TRET_PERFORM_NEVER_MORE
; 473  : 	if (ActivationMode & enumSCANF.BUTTON_ONE_SHOT) RetValue= enumTRET.PERFORM_NEVER_MORE;

  00020	0f b7 45 14	 movzx	 eax, WORD PTR _ActivationMode$[ebp]
  00024	85 05 08 00 00
	00		 test	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+8, eax

; 474  : 	return RetValue;

  0002a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+8
  0002f	75 02		 jne	 SHORT $LN1@cbActionMi
  00031	8b c6		 mov	 eax, esi
$LN1@cbActionMi:
  00033	5e		 pop	 esi

; 475  : 
; 476  : 
; 477  : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?cbActionMine@@YAHGHGG@Z ENDP				; cbActionMine
_TEXT	ENDS
PUBLIC	?FreeLevelResources@@YAXXZ			; FreeLevelResources
; Function compile flags: /Ogtp
;	COMDAT ?FreeLevelResources@@YAXXZ
_TEXT	SEGMENT
?FreeLevelResources@@YAXXZ PROC				; FreeLevelResources, COMDAT

; 359  : 
; 360  : 	// free memory used to store all data about your customize commands loaded in previous level
; 361  : 	FreeMemoryCustomize();

  00000	e8 00 00 00 00	 call	 ?FreeMemoryCustomize@@YAXXZ ; FreeMemoryCustomize

; 362  : 	// free memory used to store all data about your parameters commands loaded in previous level
; 363  : 	FreeMemoryParameters();

  00005	e8 00 00 00 00	 call	 ?FreeMemoryParameters@@YAXXZ ; FreeMemoryParameters

; 364  : 	MyData.BaseAssignSlotMine.TotAssign=0;

  0000a	c7 05 ad 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3245, 0

; 365  : 
; 366  : }

  00014	c3		 ret	 0
?FreeLevelResources@@YAXXZ ENDP				; FreeLevelResources
_TEXT	ENDS
PUBLIC	?InitAlchemyPuzzle@@YAXXZ			; InitAlchemyPuzzle
; Function compile flags: /Ogtp
;	COMDAT ?InitAlchemyPuzzle@@YAXXZ
_TEXT	SEGMENT
?InitAlchemyPuzzle@@YAXXZ PROC				; InitAlchemyPuzzle, COMDAT

; 171  : 	SendToLog("Init Alchemy Puzzle");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KDOKDHCG@Init?5Alchemy?5Puzzle?$AA@
  00005	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog

; 172  : 	for (int i=0; i<4; i++)
; 173  : 	{
; 174  : 		MyData.Save.Global.Puzzle[i].Lock = false;

  0000a	33 c0		 xor	 eax, eax
  0000c	83 c4 04	 add	 esp, 4
  0000f	a2 04 00 00 00	 mov	 BYTE PTR ?MyData@@3UStrMyData@@A+4, al

; 175  : 		MyData.Save.Global.Puzzle[i].State = 0;

  00014	a3 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A, eax
  00019	a2 09 00 00 00	 mov	 BYTE PTR ?MyData@@3UStrMyData@@A+9, al
  0001e	a3 05 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+5, eax
  00023	a2 0e 00 00 00	 mov	 BYTE PTR ?MyData@@3UStrMyData@@A+14, al
  00028	a3 0a 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+10, eax
  0002d	a2 13 00 00 00	 mov	 BYTE PTR ?MyData@@3UStrMyData@@A+19, al
  00032	a3 0f 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+15, eax

; 176  : 	}
; 177  : }

  00037	c3		 ret	 0
?InitAlchemyPuzzle@@YAXXZ ENDP				; InitAlchemyPuzzle
;	COMDAT ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\trng.cpp
_BSS	SEGMENT
?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA DD 01H DUP (?) ; `cbSaveMyData'::`2'::pVetExtras
PUBLIC	?ReleaseAll@@YAXXZ				; ReleaseAll
; Function compile flags: /Ogtp
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\plugin_renaissance.cpp
;	COMDAT ?ReleaseAll@@YAXXZ
_TEXT	SEGMENT
?ReleaseAll@@YAXXZ PROC					; ReleaseAll, COMDAT

; 1261 : // ************  ReleaseAll() function  ******************
; 1262 : 	FreeLevelResources();

  00000	e8 00 00 00 00	 call	 ?FreeMemoryCustomize@@YAXXZ ; FreeMemoryCustomize
  00005	e8 00 00 00 00	 call	 ?FreeMemoryParameters@@YAXXZ ; FreeMemoryParameters
  0000a	c7 05 ad 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3245, 0

; 1263 : }

  00014	c3		 ret	 0
?ReleaseAll@@YAXXZ ENDP					; ReleaseAll
_TEXT	ENDS
PUBLIC	?cbFlipEffectMine@@YAHGGGG@Z			; cbFlipEffectMine
; Function compile flags: /Ogtp
;	COMDAT ?cbFlipEffectMine@@YAHGGGG@Z
_TEXT	SEGMENT
_FlipIndex$ = 8						; size = 2
_Timer$ = 12						; size = 2
_Extra$ = 16						; size = 2
_ActivationMode$ = 20					; size = 2
?cbFlipEffectMine@@YAHGGGG@Z PROC			; cbFlipEffectMine, COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  : 	int RetValue;
; 407  : 	WORD TimerFull;
; 408  : 
; 409  : 	RetValue = enumTRET.PERFORM_ONCE_AND_GO;
; 410  : 	// if the flip has no Extra paremeter you can handle a Timer value with values upto 32767
; 411  : 	// in this case you'll use the following TimerFull variable, where (with following code) we set a unique big number 
; 412  : 	// pasting togheter the timer+extra arguments:
; 413  : 	TimerFull = Timer | (Extra << 8);
; 414  : 
; 415  : 	switch (FlipIndex) {

  00003	0f b7 4d 08	 movzx	 ecx, WORD PTR _FlipIndex$[ebp]
  00007	53		 push	 ebx
  00008	8b 1d 04 00 00
	00		 mov	 ebx, DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+4
  0000e	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  00011	56		 push	 esi
  00012	83 f8 03	 cmp	 eax, 3
  00015	0f 87 be 00 00
	00		 ja	 $LN2@cbFlipEffe
  0001b	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN21@cbFlipEffe[eax*4]
$LN13@cbFlipEffe:
  00022	57		 push	 edi

; 416  : 		// here type the "case Number:" for each flipeffect number. At end of the code you'll use the "break;" instruction to signal the code ending
; 417  : 		// Note: when you'll add your first "case Number:" then you can remove the following "case -1: and break;" instructions
; 418  : 	case FE_ALCHEMY_MOVE: 
; 419  : 		SendToLog("FE_ALCHEMY_MOVE");

  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JKNOKBCP@FE_ALCHEMY_MOVE?$AA@
  00028	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0002d	83 c4 04	 add	 esp, 4

; 420  : 		for (int i=0; i<4; i++)

  00030	33 ff		 xor	 edi, edi
  00032	be 00 00 00 00	 mov	 esi, OFFSET ?MyData@@3UStrMyData@@A ; MyData
$LL12@cbFlipEffe:

; 421  : 		{
; 422  : 			SendToLog("Ring %d, Lock %b, State %d", i, MyData.Save.Global.Puzzle[i].Lock, MyData.Save.Global.Puzzle[i].State);

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	0f b6 4e 04	 movzx	 ecx, BYTE PTR [esi+4]
  0003d	50		 push	 eax
  0003e	51		 push	 ecx
  0003f	57		 push	 edi
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CMEKIMAC@Ring?5?$CFd?0?5Lock?5?$CFb?0?5State?5?$CFd?$AA@
  00045	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog

; 423  : 			if (MyData.Save.Global.Puzzle[i].Lock == false)

  0004a	8a 46 04	 mov	 al, BYTE PTR [esi+4]
  0004d	83 c4 10	 add	 esp, 16			; 00000010H
  00050	84 c0		 test	 al, al
  00052	75 02		 jne	 SHORT $LN9@cbFlipEffe

; 424  : 				MyData.Save.Global.Puzzle[i].State++;

  00054	ff 06		 inc	 DWORD PTR [esi]
$LN9@cbFlipEffe:

; 425  : 			SendToLog("Ring %d, Lock %b, State %d", i, MyData.Save.Global.Puzzle[i].Lock, MyData.Save.Global.Puzzle[i].State);

  00056	8b 16		 mov	 edx, DWORD PTR [esi]
  00058	52		 push	 edx
  00059	0f b6 c0	 movzx	 eax, al
  0005c	50		 push	 eax
  0005d	57		 push	 edi
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CMEKIMAC@Ring?5?$CFd?0?5Lock?5?$CFb?0?5State?5?$CFd?$AA@
  00063	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00068	83 c4 10	 add	 esp, 16			; 00000010H

; 426  : 			if (MyData.Save.Global.Puzzle[i].State > 3)

  0006b	83 3e 03	 cmp	 DWORD PTR [esi], 3
  0006e	7e 06		 jle	 SHORT $LN8@cbFlipEffe

; 427  : 				MyData.Save.Global.Puzzle[i].State = 0;

  00070	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN8@cbFlipEffe:

; 428  : 			SendToLog("Ring %d, Lock %b, State %d", i, MyData.Save.Global.Puzzle[i].Lock, MyData.Save.Global.Puzzle[i].State);

  00076	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00078	0f b6 56 04	 movzx	 edx, BYTE PTR [esi+4]
  0007c	51		 push	 ecx
  0007d	52		 push	 edx
  0007e	57		 push	 edi
  0007f	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@CMEKIMAC@Ring?5?$CFd?0?5Lock?5?$CFb?0?5State?5?$CFd?$AA@
  00084	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00089	83 c6 05	 add	 esi, 5
  0008c	83 c4 10	 add	 esp, 16			; 00000010H
  0008f	47		 inc	 edi
  00090	81 fe 14 00 00
	00		 cmp	 esi, OFFSET ?MyData@@3UStrMyData@@A+20
  00096	7c 9f		 jl	 SHORT $LL12@cbFlipEffe
  00098	5f		 pop	 edi

; 429  : 		}
; 430  : 		break;

  00099	eb 4c		 jmp	 SHORT $LN14@cbFlipEffe
$LN7@cbFlipEffe:

; 431  : 	case FE_ALCHEMY_RESET:
; 432  : 		InitAlchemyPuzzle();

  0009b	e8 00 00 00 00	 call	 ?InitAlchemyPuzzle@@YAXXZ ; InitAlchemyPuzzle

; 433  : 		break;

  000a0	eb 45		 jmp	 SHORT $LN14@cbFlipEffe
$LN6@cbFlipEffe:

; 434  : 	case FE_ALCHEMY_LOCK:
; 435  : 		SendToLog("FE_ALCHEMY_LOCK %d", Timer);

  000a2	0f b7 75 0c	 movzx	 esi, WORD PTR _Timer$[ebp]
  000a6	56		 push	 esi
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FKMCNLHN@FE_ALCHEMY_LOCK?5?$CFd?$AA@
  000ac	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  000b1	83 c4 08	 add	 esp, 8

; 436  : 		if (MyData.Save.Global.Puzzle[Timer].Lock == false)

  000b4	80 bc b6 04 00
	00 00 00	 cmp	 BYTE PTR ?MyData@@3UStrMyData@@A[esi+esi*4+4], 0
  000bc	0f 94 c0	 sete	 al
  000bf	88 84 b6 04 00
	00 00		 mov	 BYTE PTR ?MyData@@3UStrMyData@@A[esi+esi*4+4], al

; 437  : 			MyData.Save.Global.Puzzle[Timer].Lock = true;
; 438  : 		else
; 439  : 			MyData.Save.Global.Puzzle[Timer].Lock = false;
; 440  : 		break;

  000c6	eb 1f		 jmp	 SHORT $LN14@cbFlipEffe
$LN3@cbFlipEffe:

; 441  : 	case FE_ALCHEMY_FORCE:
; 442  : 		MyData.Save.Global.Puzzle[Timer].State = Extra;

  000c8	0f b7 4d 10	 movzx	 ecx, WORD PTR _Extra$[ebp]
  000cc	0f b7 45 0c	 movzx	 eax, WORD PTR _Timer$[ebp]
  000d0	89 8c 80 00 00
	00 00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A[eax+eax*4], ecx

; 443  : 		break;

  000d7	eb 0e		 jmp	 SHORT $LN14@cbFlipEffe
$LN2@cbFlipEffe:

; 444  : 	default:
; 445  : 		SendToLog("WARNING: Flipeffect trigger number %d has not been handled in cbFlipEffectMine() function", FlipIndex);

  000d9	51		 push	 ecx
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@
  000df	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  000e4	83 c4 08	 add	 esp, 8
$LN14@cbFlipEffe:

; 446  : 		break;
; 447  : 	}
; 448  : 
; 449  : 	// if there was the one-shot button enabled, return TRET_PERFORM_NEVER_MORE
; 450  : 	if (ActivationMode & enumSCANF.BUTTON_ONE_SHOT) RetValue= enumTRET.PERFORM_NEVER_MORE; 

  000e7	0f b7 55 14	 movzx	 edx, WORD PTR _ActivationMode$[ebp]

; 451  : 	return RetValue;

  000eb	a1 08 00 00 00	 mov	 eax, DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+8
  000f0	85 15 08 00 00
	00		 test	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+8, edx
  000f6	75 02		 jne	 SHORT $LN1@cbFlipEffe
  000f8	8b c3		 mov	 eax, ebx
$LN1@cbFlipEffe:
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx

; 452  : }

  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
  000fe	8b ff		 npad	 2
$LN21@cbFlipEffe:
  00100	00 00 00 00	 DD	 $LN13@cbFlipEffe
  00104	00 00 00 00	 DD	 $LN7@cbFlipEffe
  00108	00 00 00 00	 DD	 $LN6@cbFlipEffe
  0010c	00 00 00 00	 DD	 $LN3@cbFlipEffe
?cbFlipEffectMine@@YAHGGGG@Z ENDP			; cbFlipEffectMine
_TEXT	ENDS
PUBLIC	?cbInitLoadNewLevel@@YAXXZ			; cbInitLoadNewLevel
; Function compile flags: /Ogtp
;	COMDAT ?cbInitLoadNewLevel@@YAXXZ
_TEXT	SEGMENT
?cbInitLoadNewLevel@@YAXXZ PROC				; cbInitLoadNewLevel, COMDAT

; 379  : 
; 380  : 	// clear progressive actions
; 381  : 	pAction= &MyData.VetProgrActions[0];
; 382  : 
; 383  : 	for (i=0;i<MyData.TotProgrActions;i++) {

  00000	a1 15 00 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+21
  00005	53		 push	 ebx
  00006	33 db		 xor	 ebx, ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	88 1d 14 00 00
	00		 mov	 BYTE PTR ?MyData@@3UStrMyData@@A+20, bl
  00010	3b c3		 cmp	 eax, ebx
  00012	7e 1d		 jle	 SHORT $LN2@cbInitLoad

; 373  : 	int i;
; 374  : 
; 375  : 	StrProgressiveAction *pAction;
; 376  : 
; 377  : 	// clear all LOCAL variables
; 378  : 	ClearMemory(&MyData.Save.Local,sizeof(StrSavegameLocalData));

  00014	66 8b 0d 1d 00
	00 00		 mov	 cx, WORD PTR ?MyData@@3UStrMyData@@A+29
  0001b	eb 03 8d 49 00	 npad	 5
$LL4@cbInitLoad:

; 384  : 		if (pAction->ActionType != AXN_FREE) {

  00020	66 3b cb	 cmp	 cx, bx
  00023	74 02		 je	 SHORT $LN3@cbInitLoad

; 385  : 			// here you could analise to free resoruce allocated from this specific action
; 386  : 
; 387  : 			pAction->ActionType = AXN_FREE;

  00025	33 c9		 xor	 ecx, ecx
$LN3@cbInitLoad:

; 379  : 
; 380  : 	// clear progressive actions
; 381  : 	pAction= &MyData.VetProgrActions[0];
; 382  : 
; 383  : 	for (i=0;i<MyData.TotProgrActions;i++) {

  00027	48		 dec	 eax
  00028	75 f6		 jne	 SHORT $LL4@cbInitLoad

; 385  : 			// here you could analise to free resoruce allocated from this specific action
; 386  : 
; 387  : 			pAction->ActionType = AXN_FREE;

  0002a	66 89 0d 1d 00
	00 00		 mov	 WORD PTR ?MyData@@3UStrMyData@@A+29, cx
$LN2@cbInitLoad:

; 388  : 		}
; 389  : 	}
; 390  : 
; 391  : 	MyData.TotProgrActions=0;
; 392  : 	MyData.LastProgrActionIndex=0;
; 393  : 
; 394  : 	// here you can initialise other variables of MyData different than Local and progressive actions
; 395  : 	// free resources allocate in previous level
; 396  : 	FreeLevelResources();

  00031	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  00037	33 f6		 xor	 esi, esi
  00039	89 1d 15 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+21, ebx
  0003f	89 1d 19 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+25, ebx
  00045	39 1d 9d 0c 00
	00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+3229, ebx
  0004b	7e 32		 jle	 SHORT $LN11@cbInitLoad
  0004d	8d 49 00	 npad	 3
$LL14@cbInitLoad:
  00050	a1 a1 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3233
  00055	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  00059	51		 push	 ecx
  0005a	ff d7		 call	 edi
  0005c	a1 9d 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3229
  00061	46		 inc	 esi
  00062	83 c4 04	 add	 esp, 4
  00065	3b f0		 cmp	 esi, eax
  00067	7c e7		 jl	 SHORT $LL14@cbInitLoad
  00069	3b c3		 cmp	 eax, ebx
  0006b	7e 12		 jle	 SHORT $LN11@cbInitLoad
  0006d	8b 15 a1 0c 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+3233
  00073	52		 push	 edx
  00074	ff d7		 call	 edi
  00076	83 c4 04	 add	 esp, 4
  00079	89 1d 9d 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3229, ebx
$LN11@cbInitLoad:
  0007f	33 f6		 xor	 esi, esi
  00081	89 1d a1 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3233, ebx
  00087	39 1d a5 0c 00
	00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+3237, ebx
  0008d	7e 30		 jle	 SHORT $LN38@cbInitLoad
  0008f	90		 npad	 1
$LL24@cbInitLoad:
  00090	a1 a9 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3241
  00095	8b 4c f0 04	 mov	 ecx, DWORD PTR [eax+esi*8+4]
  00099	51		 push	 ecx
  0009a	ff d7		 call	 edi
  0009c	a1 a5 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3237
  000a1	46		 inc	 esi
  000a2	83 c4 04	 add	 esp, 4
  000a5	3b f0		 cmp	 esi, eax
  000a7	7c e7		 jl	 SHORT $LL24@cbInitLoad
  000a9	3b c3		 cmp	 eax, ebx
  000ab	7e 12		 jle	 SHORT $LN38@cbInitLoad
  000ad	8b 15 a9 0c 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+3241
  000b3	52		 push	 edx
  000b4	ff d7		 call	 edi
  000b6	83 c4 04	 add	 esp, 4
  000b9	89 1d a5 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3237, ebx
$LN38@cbInitLoad:
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	89 1d a9 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3241, ebx
  000c7	89 1d ad 0c 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3245, ebx
  000cd	5b		 pop	 ebx

; 397  : 
; 398  : }

  000ce	c3		 ret	 0
?cbInitLoadNewLevel@@YAXXZ ENDP				; cbInitLoadNewLevel
_TEXT	ENDS
PUBLIC	?cbSaveMyData@@YAKPAPAEH@Z			; cbSaveMyData
; Function compile flags: /Ogtp
;	COMDAT ?cbSaveMyData@@YAKPAPAEH@Z
_TEXT	SEGMENT
_TotNWords$ = -8					; size = 4
_i$ = -4						; size = 4
_pAdrZone$ = 8						; size = 4
_SavingType$ = 12					; size = 4
?cbSaveMyData@@YAKPAPAEH@Z PROC				; cbSaveMyData, COMDAT

; 201  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 202  : 	DWORD SizeData;
; 203  : 	int i;
; 204  : 	static WORD *pVetExtras;
; 205  : 	int TotNWords;
; 206  : 	int TotNewActions;
; 207  : 
; 208  : 
; 209  : 	if (SavingType & SAVT_COMPLETED) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _SavingType$[ebp]
  0000a	f7 c3 00 08 00
	00		 test	 ebx, 2048		; 00000800H
  00010	74 24		 je	 SHORT $LN8@cbSaveMyDa

; 210  : 		// this call is not to save data but only it is a confirm that the previous saving has been completed
; 211  : 		// now we can free the temporary memory used to save the data in previous call
; 212  : 		if (pVetExtras != NULL) {

  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00017	85 c0		 test	 eax, eax
  00019	74 14		 je	 SHORT $LN7@cbSaveMyDa

; 213  : 			FreeMemory(pVetExtras);

  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00022	83 c4 04	 add	 esp, 4

; 214  : 			pVetExtras=NULL;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, 0
$LN7@cbSaveMyDa:

; 215  : 		}
; 216  : 
; 217  : 		return 0;

  0002f	33 c0		 xor	 eax, eax
  00031	5b		 pop	 ebx

; 268  : 
; 269  : 	return SizeData;
; 270  : 	
; 271  : 
; 272  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN8@cbSaveMyDa:
  00036	56		 push	 esi
  00037	57		 push	 edi

; 218  : 	}
; 219  : 
; 220  : 
; 221  : 	TotNWords=0;
; 222  : 	pVetExtras = (WORD *) GetMemory(16);

  00038	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__malloc
  0003e	6a 10		 push	 16			; 00000010H
  00040	ff d7		 call	 edi

; 223  : 	// save id of my plugin in first word
; 224  : 
; 225  : 	pVetExtras[TotNWords++] = Trng.IdMyPlugin;

  00042	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00049	83 c4 04	 add	 esp, 4
  0004c	a3 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, eax
  00051	66 89 08	 mov	 WORD PTR [eax], cx
  00054	be 01 00 00 00	 mov	 esi, 1

; 226  : 
; 227  : 	if (SavingType & SAVT_LOCAL_DATA) {

  00059	f6 c3 01	 test	 bl, 1
  0005c	0f 84 a7 00 00
	00		 je	 $LN95@cbSaveMyDa

; 228  : 		// save local data
; 229  : 
; 230  : 		// save Local structure
; 231  : 		AddNGToken(NGTAG_LOCAL_DATA, NO_ARRAY, sizeof(StrSavegameLocalData), &MyData.Save.Local, 
; 232  : 						&pVetExtras, &TotNWords);

  00062	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00067	6a 6c		 push	 108			; 0000006cH
  00069	85 c0		 test	 eax, eax
  0006b	75 07		 jne	 SHORT $LN33@cbSaveMyDa
  0006d	ff d7		 call	 edi
  0006f	83 c4 04	 add	 esp, 4
  00072	eb 0a		 jmp	 SHORT $LN24@cbSaveMyDa
$LN33@cbSaveMyDa:
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0007b	83 c4 08	 add	 esp, 8
$LN24@cbSaveMyDa:
  0007e	c7 40 02 03 00
	02 00		 mov	 DWORD PTR [eax+2], 131075 ; 00020003H
  00085	8a 15 14 00 00
	00		 mov	 dl, BYTE PTR ?MyData@@3UStrMyData@@A+20
  0008b	88 50 06	 mov	 BYTE PTR [eax+6], dl

; 233  : 
; 234  : 
; 235  : 		// save all (currently enabled) progressive actions
; 236  : 		// before saving, compact progressive action array to remove intermediate free records
; 237  : 		TotNewActions=0;

  0008e	33 d2		 xor	 edx, edx
  00090	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _TotNWords$[ebp], 4
  00097	a3 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, eax

; 238  : 
; 239  : 		for (i=0;i<MyData.TotProgrActions;i++) {

  0009c	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
  0009f	39 15 15 00 00
	00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+21, edx
  000a5	7e 39		 jle	 SHORT $LN94@cbSaveMyDa

; 228  : 		// save local data
; 229  : 
; 230  : 		// save Local structure
; 231  : 		AddNGToken(NGTAG_LOCAL_DATA, NO_ARRAY, sizeof(StrSavegameLocalData), &MyData.Save.Local, 
; 232  : 						&pVetExtras, &TotNWords);

  000a7	bb 1d 00 00 00	 mov	 ebx, OFFSET ?MyData@@3UStrMyData@@A+29
  000ac	8b c3		 mov	 eax, ebx
  000ae	8b ff		 npad	 2
$LL96@cbSaveMyDa:

; 240  : 			if (MyData.VetProgrActions[i].ActionType != AXN_FREE) {

  000b0	66 83 38 00	 cmp	 WORD PTR [eax], 0
  000b4	74 15		 je	 SHORT $LN4@cbSaveMyDa

; 241  : 
; 242  : 				MyData.VetProgrActions[TotNewActions] = MyData.VetProgrActions[i];

  000b6	8b fb		 mov	 edi, ebx
  000b8	b9 08 00 00 00	 mov	 ecx, 8
  000bd	8b f0		 mov	 esi, eax
  000bf	f3 a5		 rep movsd

; 243  : 
; 244  : 				TotNewActions++;

  000c1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__malloc
  000c7	42		 inc	 edx
  000c8	83 c3 20	 add	 ebx, 32			; 00000020H
$LN4@cbSaveMyDa:

; 238  : 
; 239  : 		for (i=0;i<MyData.TotProgrActions;i++) {

  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000ce	41		 inc	 ecx
  000cf	83 c0 20	 add	 eax, 32			; 00000020H
  000d2	89 4d fc	 mov	 DWORD PTR _i$[ebp], ecx
  000d5	3b 0d 15 00 00
	00		 cmp	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+21
  000db	7c d3		 jl	 SHORT $LL96@cbSaveMyDa
  000dd	8b 5d 0c	 mov	 ebx, DWORD PTR _SavingType$[ebp]
$LN94@cbSaveMyDa:

; 245  : 			}
; 246  : 		}
; 247  : 		// update new valuese after recompatting
; 248  : 		MyData.LastProgrActionIndex =0;
; 249  : 		MyData.TotProgrActions= TotNewActions;
; 250  : 
; 251  : 		// store all progressive action records
; 252  : 		AddNGToken(NGTAG_PROGRESSIVE_ACTIONS, MyData.TotProgrActions, sizeof(StrProgressiveAction), 
; 253  : 				&MyData.VetProgrActions[0], &pVetExtras, &TotNWords);

  000e0	8d 45 f8	 lea	 eax, DWORD PTR _TotNWords$[ebp]
  000e3	50		 push	 eax
  000e4	68 1d 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+29
  000e9	6a 20		 push	 32			; 00000020H
  000eb	52		 push	 edx
  000ec	6a 01		 push	 1
  000ee	c7 05 19 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+25, 0
  000f8	89 15 15 00 00
	00		 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+21, edx
  000fe	e8 00 00 00 00	 call	 ?AddNGToken@@YAXGKKPAXPAPAGPAH@Z ; AddNGToken
  00103	8b 75 f8	 mov	 esi, DWORD PTR _TotNWords$[ebp]
  00106	83 c4 14	 add	 esp, 20			; 00000014H
$LN95@cbSaveMyDa:

; 254  : 
; 255  : 	}
; 256  : 
; 257  : 	if (SavingType & SAVT_GLOBAL_DATA) {

  00109	f6 c3 02	 test	 bl, 2
  0010c	74 67		 je	 SHORT $LN92@cbSaveMyDa

; 258  : 		// save global data
; 259  : 		AddNGToken(NGTAG_GLOBAL_DATA, NO_ARRAY, sizeof(StrSavegameGlobalData), &MyData.Save.Global , 
; 260  : 						&pVetExtras, &TotNWords);

  0010e	8d 44 36 7c	 lea	 eax, DWORD PTR [esi+esi+124]
  00112	50		 push	 eax
  00113	85 f6		 test	 esi, esi
  00115	74 16		 je	 SHORT $LN58@cbSaveMyDa
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  0011d	85 c9		 test	 ecx, ecx
  0011f	74 0c		 je	 SHORT $LN58@cbSaveMyDa
  00121	51		 push	 ecx
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00128	83 c4 08	 add	 esp, 8
  0012b	eb 05		 jmp	 SHORT $LN56@cbSaveMyDa
$LN58@cbSaveMyDa:
  0012d	ff d7		 call	 edi
  0012f	83 c4 04	 add	 esp, 4
$LN56@cbSaveMyDa:
  00132	c7 04 70 0c 00
	03 00		 mov	 DWORD PTR [eax+esi*2], 196620 ; 0003000cH
  00139	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A
  0013f	89 54 70 04	 mov	 DWORD PTR [eax+esi*2+4], edx
  00143	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+4
  00149	89 54 70 08	 mov	 DWORD PTR [eax+esi*2+8], edx
  0014d	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+8
  00153	89 54 70 0c	 mov	 DWORD PTR [eax+esi*2+12], edx
  00157	8b 15 0c 00 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+12
  0015d	89 54 70 10	 mov	 DWORD PTR [eax+esi*2+16], edx
  00161	8b 15 10 00 00
	00		 mov	 edx, DWORD PTR ?MyData@@3UStrMyData@@A+16
  00167	89 54 70 14	 mov	 DWORD PTR [eax+esi*2+20], edx
  0016b	83 c6 0c	 add	 esi, 12			; 0000000cH
  0016e	a3 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, eax
  00173	eb 05		 jmp	 SHORT $LN63@cbSaveMyDa
$LN92@cbSaveMyDa:
  00175	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
$LN63@cbSaveMyDa:

; 261  : 	}
; 262  : 	// write final sequence
; 263  : 	AddTokenFinalSequence(&pVetExtras, &TotNWords);

  0017a	8d 4c 36 04	 lea	 ecx, DWORD PTR [esi+esi+4]
  0017e	51		 push	 ecx
  0017f	85 f6		 test	 esi, esi
  00181	74 10		 je	 SHORT $LN80@cbSaveMyDa
  00183	85 c0		 test	 eax, eax
  00185	74 0c		 je	 SHORT $LN80@cbSaveMyDa
  00187	50		 push	 eax
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0018e	83 c4 08	 add	 esp, 8
  00191	eb 05		 jmp	 SHORT $LN79@cbSaveMyDa
$LN80@cbSaveMyDa:
  00193	ff d7		 call	 edi
  00195	83 c4 04	 add	 esp, 4
$LN79@cbSaveMyDa:
  00198	33 c9		 xor	 ecx, ecx
  0019a	89 0c 70	 mov	 DWORD PTR [eax+esi*2], ecx

; 264  : 
; 265  : 	// return to trng the infos about start of memory where there are our data and their size:
; 266  : 	*pAdrZone = (BYTE *) pVetExtras;

  0019d	8b 4d 08	 mov	 ecx, DWORD PTR _pAdrZone$[ebp]
  001a0	a3 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, eax
  001a5	5f		 pop	 edi
  001a6	89 01		 mov	 DWORD PTR [ecx], eax

; 267  : 	SizeData = TotNWords * 2;

  001a8	8d 44 36 04	 lea	 eax, DWORD PTR [esi+esi+4]
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx

; 268  : 
; 269  : 	return SizeData;
; 270  : 	
; 271  : 
; 272  : }

  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
?cbSaveMyData@@YAKPAPAEH@Z ENDP				; cbSaveMyData
PUBLIC	?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject
; Function compile flags: /Ogtp
;	COMDAT ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z
_TEXT	SEGMENT
_item$ = -4						; size = 4
_ItemIndex$ = 8						; size = 2
_lara$ = 12						; size = 4
_coll$ = 16						; size = 4
?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z PROC ; CollisionSearchObject, COMDAT

; 790  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx

; 791  : 	StrItemTr4 *item;
; 792  : 
; 793  : 	Get(enumGET.ITEM, ItemIndex, 0);

  00007	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	0f bf 75 08	 movsx	 esi, WORD PTR _ItemIndex$[ebp]
  00013	57		 push	 edi
  00014	8b c6		 mov	 eax, esi
  00016	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 794  : 	item = GET.pItem;
; 795  : 	//item = &items[ItemIndex];
; 796  : 
; 797  : 	if (lara->AnimationNow == SO1ANIM || lara->AnimationNow == SO2ANIM || lara->AnimationNow == SO3ANIM || lara->AnimationNow == SO4ANIM)

  0001b	8b 55 0c	 mov	 edx, DWORD PTR _lara$[ebp]
  0001e	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  00022	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00028	bf be 01 00 00	 mov	 edi, 446		; 000001beH
  0002d	89 4c 24 0c	 mov	 DWORD PTR _item$[esp+16], ecx
  00031	66 3b c7	 cmp	 ax, di
  00034	0f 84 a1 02 00
	00		 je	 $LN35@CollisionS
  0003a	bf bf 01 00 00	 mov	 edi, 447		; 000001bfH
  0003f	66 3b c7	 cmp	 ax, di
  00042	0f 84 93 02 00
	00		 je	 $LN35@CollisionS
  00048	bf c0 01 00 00	 mov	 edi, 448		; 000001c0H
  0004d	66 3b c7	 cmp	 ax, di
  00050	0f 84 85 02 00
	00		 je	 $LN35@CollisionS
  00056	bf c1 01 00 00	 mov	 edi, 449		; 000001c1H
  0005b	66 3b c7	 cmp	 ax, di
  0005e	0f 84 77 02 00
	00		 je	 $LN35@CollisionS

; 798  : 		return;
; 799  : 
; 800  : 	if (GetMaxDistance(&item->CordX, &lara->CordX, false) > 1024)

  00064	8d 7a 40	 lea	 edi, DWORD PTR [edx+64]
  00067	8d 59 40	 lea	 ebx, DWORD PTR [ecx+64]
  0006a	e8 00 00 00 00	 call	 ?GetMaxDistance@@YAHPAK0_N@Z ; GetMaxDistance
  0006f	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00074	0f 8f 61 02 00
	00		 jg	 $LN35@CollisionS

; 801  : 		return;
; 802  : 
; 803  : 	if (Trng.pGlobTomb4->TestAlignmentInProgress == true && *Trng.pGlobTomb4->pAdr->pObjectActive == ItemIndex)

  0007a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0007f	80 b8 a3 5e 21
	00 01		 cmp	 BYTE PTR [eax+2186915], 1
  00086	0f 85 8f 00 00
	00		 jne	 $LN39@CollisionS
  0008c	8b 80 4a 34 19
	00		 mov	 eax, DWORD PTR [eax+1651786]
  00092	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [eax+148]
  00098	39 31		 cmp	 DWORD PTR [ecx], esi
  0009a	75 7f		 jne	 SHORT $LN39@CollisionS

; 804  : 	{
; 805  : 		if (item->SlotID == SEARCH_OBJECT1)

  0009c	8b 5c 24 0c	 mov	 ebx, DWORD PTR _item$[esp+16]
  000a0	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  000a4	ba f2 01 00 00	 mov	 edx, 498		; 000001f2H
  000a9	66 3b c2	 cmp	 ax, dx

; 806  : 		{
; 807  : 			if (AlignLaraAtPosition(&SearchObject1TestPosition, ItemIndex) == false)
; 808  : 				return;
; 809  : 			ForceAnimationForLara(SO1ANIM, -1);
; 810  : 			return;

  000ac	0f 84 e6 00 00
	00		 je	 $LN41@CollisionS

; 811  : 		}
; 812  : 		else if (item->SlotID == SEARCH_OBJECT2)

  000b2	b9 f3 01 00 00	 mov	 ecx, 499		; 000001f3H
  000b7	66 3b c1	 cmp	 ax, cx

; 813  : 		{
; 814  : 			if (AlignLaraAtPosition(&SearchObject2TestPosition, ItemIndex) == false)
; 815  : 				return;
; 816  : 			ForceAnimationForLara(SO2ANIM, -1);
; 817  : 			return;

  000ba	0f 84 20 01 00
	00		 je	 $LN42@CollisionS

; 818  : 		}
; 819  : 		else if (item->SlotID == SEARCH_OBJECT3)

  000c0	ba f4 01 00 00	 mov	 edx, 500		; 000001f4H
  000c5	66 3b c2	 cmp	 ax, dx

; 820  : 		{
; 821  : 			if (AlignLaraAtPosition(&SearchObject3TestPosition, ItemIndex) == false)
; 822  : 				return;
; 823  : 			ForceAnimationForLara(SO3ANIM, -1);
; 824  : 			return;

  000c8	0f 84 56 01 00
	00		 je	 $LN43@CollisionS

; 825  : 		}
; 826  : 		else if (item->SlotID == SEARCH_OBJECT4)

  000ce	b9 f5 01 00 00	 mov	 ecx, 501		; 000001f5H
  000d3	66 3b c1	 cmp	 ax, cx
  000d6	75 47		 jne	 SHORT $LN23@CollisionS

; 827  : 		{
; 828  : 			if (AlignLaraAtPosition(&SearchObject4TestPosition, ItemIndex) == false)

  000d8	56		 push	 esi
  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
  000de	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  000e3	83 c4 04	 add	 esp, 4
  000e6	84 c0		 test	 al, al
  000e8	0f 84 ed 01 00
	00		 je	 $LN35@CollisionS

; 829  : 				return;
; 830  : 			//ForceAnimationForLara(SO4ANIM, -1); // makes it crash
; 831  : 			lara->AnimationNow = SO4ANIM;

  000ee	8b 75 0c	 mov	 esi, DWORD PTR _lara$[ebp]

; 832  : 			Get(enumGET.ANIMATION, lara->AnimationNow, 0);

  000f1	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  000f7	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  000fc	8b c2		 mov	 eax, edx
  000fe	66 89 56 14	 mov	 WORD PTR [esi+20], dx
  00102	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 833  : 			lara->FrameNow = GET.pAnimation->FrameStart;

  00107	a1 f2 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  0010c	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00110	66 89 4e 16	 mov	 WORD PTR [esi+22], cx

; 896  : }

  00114	5f		 pop	 edi
  00115	5e		 pop	 esi
  00116	5b		 pop	 ebx
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
$LN39@CollisionS:

; 834  : 			return;

  0011b	8b 5c 24 0c	 mov	 ebx, DWORD PTR _item$[esp+16]
$LN23@CollisionS:

; 835  : 		}
; 836  : 	}
; 837  : 	Get(enumGET.INPUT, 0, 0);

  0011f	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+44
  00125	33 c0		 xor	 eax, eax
  00127	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 838  : 	if (GET.Input.GameCommandsRead & enumCMD.ACTION)

  0012c	8b 15 24 00 00
	00		 mov	 edx, DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+36

; 839  : 	{
; 840  : 		if (lara->StateIdCurrent == 2 && (lara->AnimationNow == 11 || lara->AnimationNow == 103))

  00132	8b 7d 0c	 mov	 edi, DWORD PTR _lara$[ebp]
  00135	85 15 8e 00 00
	00		 test	 DWORD PTR ?GET@@3UStrGetLocator@@A+142, edx
  0013b	0f 84 62 01 00
	00		 je	 $LN4@CollisionS
  00141	66 83 7f 0e 02	 cmp	 WORD PTR [edi+14], 2
  00146	0f 85 57 01 00
	00		 jne	 $LN4@CollisionS
  0014c	0f b7 47 14	 movzx	 eax, WORD PTR [edi+20]
  00150	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00153	74 09		 je	 SHORT $LN19@CollisionS
  00155	83 f8 67	 cmp	 eax, 103		; 00000067H
  00158	0f 85 45 01 00
	00		 jne	 $LN4@CollisionS
$LN19@CollisionS:

; 841  : 		{
; 842  : 			if (*Trng.pGlobTomb4->pAdr->pFlagsLaraHands == FLH_ALMOST_FREE_HANDS)

  0015e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00163	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00169	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0016c	66 83 3a 00	 cmp	 WORD PTR [edx], 0
  00170	0f 85 2d 01 00
	00		 jne	 $LN4@CollisionS

; 843  : 			{
; 844  : 				if (item->SlotID == SEARCH_OBJECT1)

  00176	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  0017a	b9 f2 01 00 00	 mov	 ecx, 498		; 000001f2H
  0017f	66 3b c1	 cmp	 ax, cx
  00182	75 3e		 jne	 SHORT $LN17@CollisionS

; 845  : 				{
; 846  : 					if (CheckPositionAlignment(&SearchObject1TestPosition, ItemIndex) == true)

  00184	8b c6		 mov	 eax, esi
  00186	ba 00 00 00 00	 mov	 edx, OFFSET ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
  0018b	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  00190	3c 01		 cmp	 al, 1
  00192	0f 85 0b 01 00
	00		 jne	 $LN4@CollisionS
$LN41@CollisionS:

; 847  : 					{
; 848  : 						if (AlignLaraAtPosition(&SearchObject1TestPosition, ItemIndex) == false)

  00198	56		 push	 esi
  00199	b9 00 00 00 00	 mov	 ecx, OFFSET ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
  0019e	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  001a3	83 c4 04	 add	 esp, 4
  001a6	84 c0		 test	 al, al
  001a8	0f 84 2d 01 00
	00		 je	 $LN35@CollisionS

; 849  : 							return;
; 850  : 						ForceAnimationForLara(SO1ANIM, -1);

  001ae	83 cf ff	 or	 edi, -1
  001b1	b8 be 01 00 00	 mov	 eax, 446		; 000001beH
  001b6	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara

; 896  : }

  001bb	5f		 pop	 edi
  001bc	5e		 pop	 esi
  001bd	5b		 pop	 ebx
  001be	8b e5		 mov	 esp, ebp
  001c0	5d		 pop	 ebp
  001c1	c3		 ret	 0
$LN17@CollisionS:

; 851  : 						return;
; 852  : 					}
; 853  : 				}
; 854  : 				else if (item->SlotID == SEARCH_OBJECT2)

  001c2	ba f3 01 00 00	 mov	 edx, 499		; 000001f3H
  001c7	66 3b c2	 cmp	 ax, dx
  001ca	75 3e		 jne	 SHORT $LN13@CollisionS

; 855  : 				{
; 856  : 					if (CheckPositionAlignment(&SearchObject2TestPosition, ItemIndex) == true)

  001cc	8b c6		 mov	 eax, esi
  001ce	ba 00 00 00 00	 mov	 edx, OFFSET ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
  001d3	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  001d8	3c 01		 cmp	 al, 1
  001da	0f 85 c3 00 00
	00		 jne	 $LN4@CollisionS
$LN42@CollisionS:

; 857  : 					{
; 858  : 						if (AlignLaraAtPosition(&SearchObject2TestPosition, ItemIndex) == false)

  001e0	56		 push	 esi
  001e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
  001e6	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  001eb	83 c4 04	 add	 esp, 4
  001ee	84 c0		 test	 al, al
  001f0	0f 84 e5 00 00
	00		 je	 $LN35@CollisionS

; 859  : 							return;
; 860  : 						ForceAnimationForLara(SO2ANIM, -1);

  001f6	83 cf ff	 or	 edi, -1
  001f9	b8 bf 01 00 00	 mov	 eax, 447		; 000001bfH
  001fe	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara

; 896  : }

  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5b		 pop	 ebx
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
$LN13@CollisionS:

; 861  : 						return;
; 862  : 					}
; 863  : 				}
; 864  : 				else if (item->SlotID == SEARCH_OBJECT3)

  0020a	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  0020f	66 3b c1	 cmp	 ax, cx
  00212	75 3a		 jne	 SHORT $LN9@CollisionS

; 865  : 				{
; 866  : 					if (CheckPositionAlignment(&SearchObject3TestPosition, ItemIndex) == true)

  00214	8b c6		 mov	 eax, esi
  00216	ba 00 00 00 00	 mov	 edx, OFFSET ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
  0021b	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  00220	3c 01		 cmp	 al, 1
  00222	75 7f		 jne	 SHORT $LN4@CollisionS
$LN43@CollisionS:

; 867  : 					{
; 868  : 						if (AlignLaraAtPosition(&SearchObject3TestPosition, ItemIndex) == false)

  00224	56		 push	 esi
  00225	b9 00 00 00 00	 mov	 ecx, OFFSET ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
  0022a	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  0022f	83 c4 04	 add	 esp, 4
  00232	84 c0		 test	 al, al
  00234	0f 84 a1 00 00
	00		 je	 $LN35@CollisionS

; 869  : 							return;
; 870  : 						ForceAnimationForLara(SO3ANIM, -1);

  0023a	83 cf ff	 or	 edi, -1
  0023d	b8 c0 01 00 00	 mov	 eax, 448		; 000001c0H
  00242	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara

; 896  : }

  00247	5f		 pop	 edi
  00248	5e		 pop	 esi
  00249	5b		 pop	 ebx
  0024a	8b e5		 mov	 esp, ebp
  0024c	5d		 pop	 ebp
  0024d	c3		 ret	 0
$LN9@CollisionS:

; 871  : 						return;
; 872  : 					}
; 873  : 				}
; 874  : 				else if (item->SlotID == SEARCH_OBJECT4)

  0024e	ba f5 01 00 00	 mov	 edx, 501		; 000001f5H
  00253	66 3b c2	 cmp	 ax, dx
  00256	75 4b		 jne	 SHORT $LN4@CollisionS

; 875  : 				{
; 876  : 					if (CheckPositionAlignment(&SearchObject4TestPosition, ItemIndex) == true)

  00258	8b c6		 mov	 eax, esi
  0025a	ba 00 00 00 00	 mov	 edx, OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
  0025f	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  00264	3c 01		 cmp	 al, 1
  00266	75 3b		 jne	 SHORT $LN4@CollisionS

; 877  : 					{
; 878  : 						if (AlignLaraAtPosition(&SearchObject4TestPosition, ItemIndex) == false)

  00268	56		 push	 esi
  00269	b9 00 00 00 00	 mov	 ecx, OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
  0026e	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  00273	83 c4 04	 add	 esp, 4
  00276	84 c0		 test	 al, al
  00278	74 61		 je	 SHORT $LN35@CollisionS

; 879  : 							return;
; 880  : 						//ForceAnimationForLara(SO4ANIM, -1);
; 881  : 						lara->AnimationNow = SO4ANIM;
; 882  : 						Get(enumGET.ANIMATION, lara->AnimationNow, 0);

  0027a	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00280	b8 c1 01 00 00	 mov	 eax, 449		; 000001c1H
  00285	66 89 47 14	 mov	 WORD PTR [edi+20], ax
  00289	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 883  : 						lara->FrameNow = GET.pAnimation->FrameStart;

  0028e	8b 0d f2 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00294	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00298	66 89 57 16	 mov	 WORD PTR [edi+22], dx

; 896  : }

  0029c	5f		 pop	 edi
  0029d	5e		 pop	 esi
  0029e	5b		 pop	 ebx
  0029f	8b e5		 mov	 esp, ebp
  002a1	5d		 pop	 ebp
  002a2	c3		 ret	 0
$LN4@CollisionS:

; 884  : 						return;
; 885  : 					}
; 886  : 				}
; 887  : 			}
; 888  : 		}
; 889  : 	}
; 890  : 	if (!TestBoundCollide(item, lara, coll->LaraSizeX))

  002a3	8b 75 10	 mov	 esi, DWORD PTR _coll$[ebp]
  002a6	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  002a9	50		 push	 eax
  002aa	57		 push	 edi
  002ab	53		 push	 ebx
  002ac	b9 70 72 44 00	 mov	 ecx, 4485744		; 00447270H
  002b1	ff d1		 call	 ecx
  002b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b6	84 c0		 test	 al, al
  002b8	74 21		 je	 SHORT $LN35@CollisionS

; 891  : 		return;
; 892  : 	if (!TestCollision(item, lara))

  002ba	57		 push	 edi
  002bb	53		 push	 ebx
  002bc	ba 00 ed 45 00	 mov	 edx, 4582656		; 0045ed00H
  002c1	ff d2		 call	 edx
  002c3	83 c4 08	 add	 esp, 8
  002c6	85 c0		 test	 eax, eax
  002c8	74 11		 je	 SHORT $LN35@CollisionS

; 893  : 		return;
; 894  : 
; 895  : 	ItemPushLara(item, lara, coll, 0, 1);

  002ca	6a 01		 push	 1
  002cc	6a 00		 push	 0
  002ce	56		 push	 esi
  002cf	57		 push	 edi
  002d0	53		 push	 ebx
  002d1	b8 c0 6e 44 00	 mov	 eax, 4484800		; 00446ec0H
  002d6	ff d0		 call	 eax
  002d8	83 c4 14	 add	 esp, 20			; 00000014H
$LN35@CollisionS:

; 896  : }

  002db	5f		 pop	 edi
  002dc	5e		 pop	 esi
  002dd	5b		 pop	 ebx
  002de	8b e5		 mov	 esp, ebp
  002e0	5d		 pop	 ebp
  002e1	c3		 ret	 0
?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ENDP ; CollisionSearchObject
_TEXT	ENDS
PUBLIC	?InitialiseSearchObject@@YAXH@Z			; InitialiseSearchObject
; Function compile flags: /Ogtp
;	COMDAT ?InitialiseSearchObject@@YAXH@Z
_TEXT	SEGMENT
_ItemIndex$ = 8						; size = 4
?InitialiseSearchObject@@YAXH@Z PROC			; InitialiseSearchObject, COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 772  : 	StrItemTr4 *item;
; 773  : 	Get(enumGET.ITEM, ItemIndex, 0);

  00003	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR _ItemIndex$[ebp]
  0000e	8b c7		 mov	 eax, edi
  00010	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 774  : 	Get(enumGET.SLOT, GET.pItem->SlotID, 0);

  00015	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  0001a	0f b7 40 0c	 movzx	 eax, WORD PTR [eax+12]
  0001e	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00024	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 775  : 	item = GET.pItem;

  00029	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?GET@@3UStrGetLocator@@A+8

; 776  : 	//item = &items[ItemIndex];
; 777  : 
; 778  : 	//item->AnimationNow = GET.pSlot->IndexFirstAnim;
; 779  : 	Get(enumGET.ANIMATION, item->AnimationNow, 0);

  0002f	0f b7 46 14	 movzx	 eax, WORD PTR [esi+20]
  00033	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00039	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 780  : 	//item->AnimationNow = objects[item->SlotID].IndexFirstAnim;
; 781  : 	item->FrameNow = GET.pAnimation->FrameStart;

  0003e	8b 0d f2 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00044	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00048	66 89 56 16	 mov	 WORD PTR [esi+22], dx

; 782  : 	//item->FrameNow = anims[item->AnimationNow].FrameStart;
; 783  : 	item->StateIdCurrent = 0;

  0004c	33 c0		 xor	 eax, eax

; 784  : 	item->StateIdNext = 0;
; 785  : 	item->FlagsMain = CFITEM_COLLIDABLE;
; 786  : 	AddActiveItem(ItemIndex);

  0004e	57		 push	 edi
  0004f	ba 10 3c 45 00	 mov	 edx, 4537360		; 00453c10H
  00054	89 46 0e	 mov	 DWORD PTR [esi+14], eax
  00057	c7 86 ea 15 00
	00 20 00 00 00	 mov	 DWORD PTR [esi+5610], 32 ; 00000020H
  00061	ff d2		 call	 edx
  00063	83 c4 04	 add	 esp, 4
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi

; 787  : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?InitialiseSearchObject@@YAXH@Z ENDP			; InitialiseSearchObject
_TEXT	ENDS
PUBLIC	?InitAnimating@@YAXF@Z				; InitAnimating
; Function compile flags: /Ogtp
;	COMDAT ?InitAnimating@@YAXF@Z
_TEXT	SEGMENT
_ItemIndex$ = 8						; size = 2
?InitAnimating@@YAXF@Z PROC				; InitAnimating, COMDAT

; 743  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 744  : 	Get(enumGET.ITEM, ItemIndex, 0);

  00003	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  00007	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  0000d	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 745  : 
; 746  : 	GET.pItem->StateIdCurrent = 0;

  00012	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00018	33 c0		 xor	 eax, eax
  0001a	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 747  : 	GET.pItem->StateIdNext = 0;

  0001e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00023	33 d2		 xor	 edx, edx
  00025	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 748  : 
; 749  : 	Get(enumGET.SLOT, GET.pItem->SlotID, 0);

  00029	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  0002f	0f b7 41 0c	 movzx	 eax, WORD PTR [ecx+12]
  00033	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00039	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 750  : 	GET.pItem->AnimationNow = GET.pSlot->IndexFirstAnim;

  0003e	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00044	66 8b 42 26	 mov	 ax, WORD PTR [edx+38]
  00048	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  0004e	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 751  : 	Get(enumGET.ANIMATION, GET.pItem->AnimationNow, 0);

  00052	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00058	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  0005c	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00062	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 752  : 	GET.pItem->FrameNow = GET.pAnimation->FrameStart;

  00067	a1 f2 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  0006c	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00070	8b 15 08 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00076	66 89 4a 16	 mov	 WORD PTR [edx+22], cx

; 753  : 
; 754  : 	GET.pItem->FlagsMain = enumFITEM.NOT_YET_ENABLED;

  0007a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  0007f	8b 0d 1c 00 00
	00		 mov	 ecx, DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+28
  00085	89 88 ea 15 00
	00		 mov	 DWORD PTR [eax+5610], ecx

; 755  : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?InitAnimating@@YAXF@Z ENDP				; InitAnimating
_TEXT	ENDS
PUBLIC	__real@4049000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4044000000000000
PUBLIC	__real@403e000000000000
PUBLIC	?WideScreen@@YAXXZ				; WideScreen
EXTRN	__fltused:DWORD
;	COMDAT __real@4049000000000000
CONST	SEGMENT
__real@4049000000000000 DQ 04049000000000000r	; 50
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?WideScreen@@YAXXZ
_TEXT	SEGMENT
tv233 = -24						; size = 8
_ratio$ = -16						; size = 8
tv230 = -8						; size = 4
tv228 = -8						; size = 4
tv216 = -8						; size = 4
tv214 = -8						; size = 4
tv240 = -4						; size = 4
tv239 = -4						; size = 4
tv234 = -2						; size = 2
tv219 = -2						; size = 2
?WideScreen@@YAXXZ PROC					; WideScreen, COMDAT

; 655  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 656  : 	int w = Trng.pGlobTomb4->ScreenSizeX;
; 657  : 	int h = Trng.pGlobTomb4->ScreenSizeY;
; 658  : 	double ratio = (double) w / (double) h;

  00006	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0000b	0f bf 88 0b 20
	1a 00		 movsx	 ecx, WORD PTR [eax+1712139]
  00012	0f bf 90 0d 20
	1a 00		 movsx	 edx, WORD PTR [eax+1712141]
  00019	89 4d fc	 mov	 DWORD PTR tv240[ebp], ecx

; 659  : 	Get(enumGET.INFO_LARA, 0, 0);

  0001c	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+32
  00022	33 c0		 xor	 eax, eax
  00024	db 45 fc	 fild	 DWORD PTR tv240[ebp]
  00027	89 55 fc	 mov	 DWORD PTR tv239[ebp], edx
  0002a	db 45 fc	 fild	 DWORD PTR tv239[ebp]
  0002d	de f9		 fdivp	 ST(1), ST(0)
  0002f	dd 5d f0	 fstp	 QWORD PTR _ratio$[ebp]
  00032	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 660  : 
; 661  : 	//SendToLog("Flyby %d", *Trng.pGlobTomb4->pAdr->pTestFlybyInProgress);
; 662  : 	if ((*Trng.pGlobTomb4->pAdr->pTestFlybyInProgress != NoFlyby) && (*Trng.pGlobTomb4->pAdr->pLevelNow != 0))

  00037	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0003c	8b 80 4a 34 19
	00		 mov	 eax, DWORD PTR [eax+1651786]
  00042	8b 88 14 01 00
	00		 mov	 ecx, DWORD PTR [eax+276]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?NoFlyby@@3HA ; NoFlyby
  00050	74 0f		 je	 SHORT $LN7@WideScreen
  00052	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [eax+184]
  00058	80 38 00	 cmp	 BYTE PTR [eax], 0
  0005b	0f 85 04 01 00
	00		 jne	 $LN1@WideScreen
$LN7@WideScreen:

; 663  : 		return;
; 664  : 
; 665  : 	if (GET.LaraInfo.HoldedItem == HOLD_CROSSBOW)

  00061	83 3d 2b 00 00
	00 06		 cmp	 DWORD PTR ?GET@@3UStrGetLocator@@A+43, 6
  00068	75 39		 jne	 SHORT $LN4@WideScreen

; 666  : 	{
; 667  : 		Get(enumGET.LARA, 0, 0);

  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A
  00070	33 c0		 xor	 eax, eax
  00072	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 668  : 		if (GET.pLara->StateIdCurrent == AS_STOP)

  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A
  0007d	66 83 79 0e 02	 cmp	 WORD PTR [ecx+14], 2
  00082	75 1f		 jne	 SHORT $LN4@WideScreen

; 669  : 		{
; 670  : 			Get(enumGET.INPUT, 0, 0);

  00084	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+44
  0008a	33 c0		 xor	 eax, eax
  0008c	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 671  : 			if (GET.Input.GameCommandsRead & enumCMD.LOOK)

  00091	8b 15 30 00 00
	00		 mov	 edx, DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+48
  00097	85 15 8e 00 00
	00		 test	 DWORD PTR ?GET@@3UStrGetLocator@@A+142, edx
  0009d	0f 85 c2 00 00
	00		 jne	 $LN1@WideScreen
$LN4@WideScreen:

; 672  : 			{
; 673  : 				return;
; 674  : 			}
; 675  : 		}
; 676  : 	}
; 677  : 	if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_USING_LASER_SIGHT_OR_BINOCULARS)

  000a3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000a8	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000ae	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000b4	a0 10 00 00 00	 mov	 al, BYTE PTR ?enumFL2@@3UStrEnumFL2@@A+16
  000b9	84 02		 test	 BYTE PTR [edx], al
  000bb	0f 85 a4 00 00
	00		 jne	 $LN1@WideScreen

; 678  : 		return;
; 679  : 
; 680  : 	//if ((Trng.pGlobTomb4->ScreenSizeX % 16 == 0) && (Trng.pGlobTomb4->ScreenSizeY % 9 == 0))
; 681  : 		//AlterFOV(92 * ONE_DEGREE);	// 16:9
; 682  : 	
; 683  : 	// Joey's FOV formula
; 684  : 	AlterFOV((int)((ratio * 30) + 40) * ONE_DEGREE);

  000c1	dd 45 f0	 fld	 QWORD PTR _ratio$[ebp]
  000c4	ba b6 00 00 00	 mov	 edx, 182		; 000000b6H
  000c9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@403e000000000000
  000cf	d9 7d fe	 fnstcw	 WORD PTR tv234[ebp]
  000d2	0f b7 45 fe	 movzx	 eax, WORD PTR tv234[ebp]
  000d6	dd 55 e8	 fst	 QWORD PTR tv233[ebp]
  000d9	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4044000000000000
  000df	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000e4	89 45 f8	 mov	 DWORD PTR tv230[ebp], eax
  000e7	d9 6d f8	 fldcw	 WORD PTR tv230[ebp]
  000ea	db 5d f8	 fistp	 DWORD PTR tv228[ebp]
  000ed	66 8b 4d f8	 mov	 cx, WORD PTR tv228[ebp]
  000f1	d9 6d fe	 fldcw	 WORD PTR tv234[ebp]
  000f4	66 0f af ca	 imul	 cx, dx
  000f8	0f b7 c1	 movzx	 eax, cx
  000fb	50		 push	 eax
  000fc	b9 60 d6 48 00	 mov	 ecx, 4773472		; 0048d660H
  00101	ff d1		 call	 ecx

; 685  : 	if (*Trng.pGlobTomb4->pAdr->pLevelNow == 0)

  00103	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00109	8b 82 4a 34 19
	00		 mov	 eax, DWORD PTR [edx+1651786]
  0010f	8b 88 b8 00 00
	00		 mov	 ecx, DWORD PTR [eax+184]
  00115	83 c4 04	 add	 esp, 4
  00118	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0011b	75 48		 jne	 SHORT $LN1@WideScreen

; 686  : 		if (ratio > (4/3))

  0011d	d9 e8		 fld1
  0011f	dc 5d f0	 fcomp	 QWORD PTR _ratio$[ebp]
  00122	df e0		 fnstsw	 ax
  00124	f6 c4 05	 test	 ah, 5
  00127	7a 3c		 jp	 SHORT $LN1@WideScreen

; 687  : 			AlterFOV((int)((ratio * 30) + 50) * ONE_DEGREE);

  00129	dd 45 e8	 fld	 QWORD PTR tv233[ebp]
  0012c	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4049000000000000
  00132	d9 7d fe	 fnstcw	 WORD PTR tv219[ebp]
  00135	0f b7 45 fe	 movzx	 eax, WORD PTR tv219[ebp]
  00139	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0013e	89 45 f8	 mov	 DWORD PTR tv216[ebp], eax
  00141	b8 b6 00 00 00	 mov	 eax, 182		; 000000b6H
  00146	d9 6d f8	 fldcw	 WORD PTR tv216[ebp]
  00149	db 5d f8	 fistp	 DWORD PTR tv214[ebp]
  0014c	66 8b 55 f8	 mov	 dx, WORD PTR tv214[ebp]
  00150	d9 6d fe	 fldcw	 WORD PTR tv219[ebp]
  00153	66 0f af d0	 imul	 dx, ax
  00157	0f b7 ca	 movzx	 ecx, dx
  0015a	51		 push	 ecx
  0015b	ba 60 d6 48 00	 mov	 edx, 4773472		; 0048d660H
  00160	ff d2		 call	 edx
  00162	83 c4 04	 add	 esp, 4
$LN1@WideScreen:

; 688  : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c3		 ret	 0
?WideScreen@@YAXXZ ENDP					; WideScreen
_TEXT	ENDS
PUBLIC	?StepDownFix@@YAXXZ				; StepDownFix
; Function compile flags: /Ogtp
;	COMDAT ?StepDownFix@@YAXXZ
_TEXT	SEGMENT
?StepDownFix@@YAXXZ PROC				; StepDownFix, COMDAT

; 618  : 	Get(enumGET.LARA, 0, 0);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A
  00006	56		 push	 esi
  00007	33 c0		 xor	 eax, eax
  00009	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 619  : 	Get(enumGET.ANIMATION, GET.pLara->AnimationNow, 0);

  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00013	0f b7 40 14	 movzx	 eax, WORD PTR [eax+20]
  00017	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  0001d	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 620  : 
; 621  : 	if (GET.pLara->AnimationNow == 40)

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00027	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0002b	b2 01		 mov	 dl, 1
  0002d	83 f9 28	 cmp	 ecx, 40			; 00000028H
  00030	75 27		 jne	 SHORT $LN12@StepDownFi

; 622  : 	{
; 623  : 		if ((GET.pLara->FrameNow - GET.pAnimation->FrameStart >= 30) && (GET.pLara->FrameNow - GET.pAnimation->FrameStart <= 59))

  00032	8b 35 f2 00 00
	00		 mov	 esi, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00038	0f b7 76 18	 movzx	 esi, WORD PTR [esi+24]
  0003c	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  00040	2b c6		 sub	 eax, esi
  00042	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00045	7c 0b		 jl	 SHORT $LN3@StepDownFi

; 624  : 		{
; 625  : 			StepRight = true;

  00047	88 15 00 00 00
	00		 mov	 BYTE PTR ?StepRight@@3_NA, dl ; StepRight
  0004d	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  00050	7e 07		 jle	 SHORT $LN12@StepDownFi
$LN3@StepDownFi:

; 626  : 		} else {
; 627  : 			StepRight = false;

  00052	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?StepRight@@3_NA, 0 ; StepRight
$LN12@StepDownFi:

; 628  : 		}
; 629  : 	}
; 630  : 
; 631  : 	if (GET.pLara->AnimationNow == 61 && StepRight == true)

  00059	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  0005c	75 73		 jne	 SHORT $LN1@StepDownFi
  0005e	38 15 00 00 00
	00		 cmp	 BYTE PTR ?StepRight@@3_NA, dl ; StepRight
  00064	75 6b		 jne	 SHORT $LN1@StepDownFi

; 632  : 	{
; 633  : 		ForceAnimationForLara(62, 16);

  00066	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0006c	8b 91 4a 34 19
	00		 mov	 edx, DWORD PTR [ecx+1651786]
  00072	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00075	0f b7 40 26	 movzx	 eax, WORD PTR [eax+38]
  00079	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0007b	8b 52 30	 mov	 edx, DWORD PTR [edx+48]
  0007e	83 c0 3e	 add	 eax, 62			; 0000003eH
  00081	8d 34 80	 lea	 esi, DWORD PTR [eax+eax*4]
  00084	8d 14 f2	 lea	 edx, DWORD PTR [edx+esi*8]
  00087	0f b7 71 14	 movzx	 esi, WORD PTR [ecx+20]
  0008b	3b f0		 cmp	 esi, eax
  0008d	74 3b		 je	 SHORT $LN10@StepDownFi
  0008f	80 7a 05 00	 cmp	 BYTE PTR [edx+5], 0
  00093	75 18		 jne	 SHORT $LN8@StepDownFi
  00095	6a 3e		 push	 62			; 0000003eH
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HFDDJGMI@ERROR?3?5missing?5animation?5number?5@
  0009c	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  000a1	83 c4 08	 add	 esp, 8

; 634  : 		StepRight = false;

  000a4	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?StepRight@@3_NA, 0 ; StepRight
  000ab	5e		 pop	 esi

; 635  : 	}
; 636  : }

  000ac	c3		 ret	 0

; 632  : 	{
; 633  : 		ForceAnimationForLara(62, 16);

$LN8@StepDownFi:
  000ad	66 8b 72 18	 mov	 si, WORD PTR [edx+24]
  000b1	66 89 71 16	 mov	 WORD PTR [ecx+22], si
  000b5	66 8b 52 06	 mov	 dx, WORD PTR [edx+6]
  000b9	66 89 51 0e	 mov	 WORD PTR [ecx+14], dx
  000bd	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000c2	66 89 51 10	 mov	 WORD PTR [ecx+16], dx
  000c6	66 89 41 14	 mov	 WORD PTR [ecx+20], ax
$LN10@StepDownFi:

; 634  : 		StepRight = false;

  000ca	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?StepRight@@3_NA, 0 ; StepRight
$LN1@StepDownFi:
  000d1	5e		 pop	 esi

; 635  : 	}
; 636  : }

  000d2	c3		 ret	 0
?StepDownFix@@YAXXZ ENDP				; StepDownFix
_TEXT	ENDS
PUBLIC	?GetItem@@YAXHH_N@Z				; GetItem
; Function compile flags: /Ogtp
;	COMDAT ?GetItem@@YAXHH_N@Z
_TEXT	SEGMENT
?GetItem@@YAXHH_N@Z PROC				; GetItem, COMDAT
; _Item$ = edx

; 603  : 	for (int j = 0; j < Amount; j++)
; 604  : 	{
; 605  : 		for (int i = 0; i <= 128; i++)

  00000	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00006	33 c0		 xor	 eax, eax
  00008	81 c1 bb 03 1a
	00		 add	 ecx, 1704891		; 001a03bbH
  0000e	8b ff		 npad	 2
$LL4@GetItem:

; 606  : 		{
; 607  : 			if (Trng.pGlobTomb4->VetInventory[i] == Item)

  00010	39 11		 cmp	 DWORD PTR [ecx], edx
  00012	74 0c		 je	 SHORT $LN25@GetItem

; 603  : 	for (int j = 0; j < Amount; j++)
; 604  : 	{
; 605  : 		for (int i = 0; i <= 128; i++)

  00014	40		 inc	 eax
  00015	83 c1 04	 add	 ecx, 4
  00018	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0001d	7e f1		 jle	 SHORT $LL4@GetItem

; 610  : 				break;
; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  0001f	c3		 ret	 0
$LN25@GetItem:

; 608  : 			{
; 609  : 				PerformFlipeffect(NULL, 48, i, ShowPickup);

  00020	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00025	50		 push	 eax
  00026	6a 30		 push	 48			; 00000030H
  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 610  : 				break;
; 611  : 			}
; 612  : 		}
; 613  : 	}
; 614  : }

  00034	c3		 ret	 0
?GetItem@@YAXHH_N@Z ENDP				; GetItem
_TEXT	ENDS
PUBLIC	?InitAlchemyPuzzleObject@@YAXXZ			; InitAlchemyPuzzleObject
; Function compile flags: /Ogtp
;	COMDAT ?InitAlchemyPuzzleObject@@YAXXZ
_TEXT	SEGMENT
?InitAlchemyPuzzleObject@@YAXXZ PROC			; InitAlchemyPuzzleObject, COMDAT

; 1080 : 	Get(enumGET.SLOT, ALCHEMY_PUZZLE1, 0);

  00000	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00006	b8 f6 01 00 00	 mov	 eax, 502		; 000001f6H
  0000b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1081 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0)

  00010	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00015	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0001a	74 0d		 je	 SHORT $LN4@InitAlchem
  0001c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00023	0f 84 13 01 00
	00		 je	 $LN5@InitAlchem
$LN4@InitAlchem:
  00029	53		 push	 ebx
  0002a	56		 push	 esi

; 1082 : 		return;
; 1083 : 	GET.pSlot->pProcControl = AlchemyPuzzleControl;

  0002b	bb 00 00 00 00	 mov	 ebx, OFFSET ?AlchemyPuzzleControl@@YAXF@Z ; AlchemyPuzzleControl
  00030	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 1084 : 	GET.pSlot->pProcCollision = AnimatingCollision;

  00033	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00038	57		 push	 edi
  00039	bf 00 00 00 00	 mov	 edi, OFFSET ?AnimatingCollision@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; AnimatingCollision
  0003e	89 78 20	 mov	 DWORD PTR [eax+32], edi

; 1085 : 	GET.pSlot->pProcInitialise = InitAnimating;

  00041	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00047	be 00 00 00 00	 mov	 esi, OFFSET ?InitAnimating@@YAXF@Z ; InitAnimating
  0004c	89 71 0c	 mov	 DWORD PTR [ecx+12], esi

; 1086 : 	GET.pSlot->Flags = CFSLOT_SAVE_POSITION | CFSLOT_SAVE_FLAGS | CFSLOT_SAVE_ANIM;

  0004f	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234

; 1087 : 
; 1088 : 	Get(enumGET.SLOT, ALCHEMY_PUZZLE2, 0);

  00054	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  0005a	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  0005f	66 89 50 32	 mov	 WORD PTR [eax+50], dx
  00063	b8 f7 01 00 00	 mov	 eax, 503		; 000001f7H
  00068	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1089 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0)

  0006d	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00072	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  00077	74 0d		 je	 SHORT $LN3@InitAlchem
  00079	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00080	0f 84 b3 00 00
	00		 je	 $LN7@InitAlchem
$LN3@InitAlchem:

; 1090 : 		return;
; 1091 : 	GET.pSlot->pProcControl = AlchemyPuzzleControl;

  00086	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 1092 : 	GET.pSlot->pProcCollision = AnimatingCollision;

  00089	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0008f	89 79 20	 mov	 DWORD PTR [ecx+32], edi

; 1093 : 	GET.pSlot->pProcInitialise = InitAnimating;

  00092	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00098	89 72 0c	 mov	 DWORD PTR [edx+12], esi

; 1094 : 	GET.pSlot->Flags = CFSLOT_SAVE_POSITION | CFSLOT_SAVE_FLAGS | CFSLOT_SAVE_ANIM;

  0009b	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000a1	b8 68 00 00 00	 mov	 eax, 104		; 00000068H
  000a6	66 89 41 32	 mov	 WORD PTR [ecx+50], ax

; 1095 : 
; 1096 : 	Get(enumGET.SLOT, ALCHEMY_PUZZLE3, 0);

  000aa	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  000b0	b8 f8 01 00 00	 mov	 eax, 504		; 000001f8H
  000b5	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1097 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0)

  000ba	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000bf	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  000c4	74 09		 je	 SHORT $LN2@InitAlchem
  000c6	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  000cd	74 6a		 je	 SHORT $LN7@InitAlchem
$LN2@InitAlchem:

; 1098 : 		return;
; 1099 : 	GET.pSlot->pProcControl = AlchemyPuzzleControl;

  000cf	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 1100 : 	GET.pSlot->pProcCollision = AnimatingCollision;

  000d2	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000d8	89 7a 20	 mov	 DWORD PTR [edx+32], edi

; 1101 : 	GET.pSlot->pProcInitialise = InitAnimating;

  000db	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000e0	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 1102 : 	GET.pSlot->Flags = CFSLOT_SAVE_POSITION | CFSLOT_SAVE_FLAGS | CFSLOT_SAVE_ANIM;

  000e3	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000e9	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  000ee	66 89 4a 32	 mov	 WORD PTR [edx+50], cx

; 1103 : 
; 1104 : 	Get(enumGET.SLOT, ALCHEMY_PUZZLE4, 0);

  000f2	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  000f8	b8 f9 01 00 00	 mov	 eax, 505		; 000001f9H
  000fd	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1105 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0)

  00102	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00107	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0010c	74 09		 je	 SHORT $LN1@InitAlchem
  0010e	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00115	74 22		 je	 SHORT $LN7@InitAlchem
$LN1@InitAlchem:

; 1106 : 		return;
; 1107 : 	GET.pSlot->pProcControl = AlchemyPuzzleControl;

  00117	89 58 10	 mov	 DWORD PTR [eax+16], ebx

; 1108 : 	GET.pSlot->pProcCollision = AnimatingCollision;

  0011a	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0011f	89 78 20	 mov	 DWORD PTR [eax+32], edi

; 1109 : 	GET.pSlot->pProcInitialise = InitAnimating;

  00122	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00128	89 71 0c	 mov	 DWORD PTR [ecx+12], esi

; 1110 : 	GET.pSlot->Flags = CFSLOT_SAVE_POSITION | CFSLOT_SAVE_FLAGS | CFSLOT_SAVE_ANIM;

  0012b	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00130	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  00135	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN7@InitAlchem:
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi
  0013b	5b		 pop	 ebx
$LN5@InitAlchem:

; 1111 : }

  0013c	c3		 ret	 0
?InitAlchemyPuzzleObject@@YAXXZ ENDP			; InitAlchemyPuzzleObject
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SearchObjectControl@@YAXF@Z			; SearchObjectControl
; Function compile flags: /Ogtp
;	COMDAT ?SearchObjectControl@@YAXF@Z
_TEXT	SEGMENT
_pos$46138 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_ItemIndex$ = 8						; size = 2
?SearchObjectControl@@YAXF@Z PROC			; SearchObjectControl, COMDAT

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 900  : 	StrItemTr4 *item;
; 901  : 	StrItemTr4 *lara;
; 902  : 
; 903  : 	Get(enumGET.ITEM, ItemIndex, 0);

  00010	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  00014	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 904  : 	item = GET.pItem;

  00021	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?GET@@3UStrGetLocator@@A+8

; 905  : 	Get(enumGET.SLOT, item->SlotID, 0);

  00027	0f b7 46 0c	 movzx	 eax, WORD PTR [esi+12]
  0002b	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00031	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 906  : 	Get(enumGET.LARA, 0, 0);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A
  0003c	33 c0		 xor	 eax, eax
  0003e	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 907  : 	lara = GET.pLara;
; 908  : 
; 909  : 	// no need to animate if it's not the opening animation
; 910  : 	if (item->AnimationNow == GET.pSlot->IndexFirstAnim + 1)

  00043	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00048	0f b7 48 26	 movzx	 ecx, WORD PTR [eax+38]
  0004c	0f b7 56 14	 movzx	 edx, WORD PTR [esi+20]
  00050	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?GET@@3UStrGetLocator@@A
  00056	41		 inc	 ecx
  00057	3b d1		 cmp	 edx, ecx
  00059	75 0b		 jne	 SHORT $LN19@SearchObje

; 911  : 		AnimateItem(item);

  0005b	56		 push	 esi
  0005c	b8 80 92 44 00	 mov	 eax, 4493952		; 00449280H
  00061	ff d0		 call	 eax
  00063	83 c4 04	 add	 esp, 4
$LN19@SearchObje:

; 912  : 
; 913  : 	if (lara->AnimationNow == SO1ANIM || lara->AnimationNow == SO2ANIM || lara->AnimationNow == SO3ANIM || lara->AnimationNow == SO4ANIM)

  00066	0f b7 43 14	 movzx	 eax, WORD PTR [ebx+20]
  0006a	b9 be 01 00 00	 mov	 ecx, 446		; 000001beH
  0006f	66 3b c1	 cmp	 ax, cx
  00072	74 45		 je	 SHORT $LN17@SearchObje
  00074	ba bf 01 00 00	 mov	 edx, 447		; 000001bfH
  00079	66 3b c2	 cmp	 ax, dx
  0007c	74 3b		 je	 SHORT $LN17@SearchObje
  0007e	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  00083	66 3b c1	 cmp	 ax, cx
  00086	74 31		 je	 SHORT $LN17@SearchObje
  00088	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  0008d	66 3b c2	 cmp	 ax, dx
  00090	74 27		 je	 SHORT $LN17@SearchObje

; 970  : 				}
; 971  : 			}
; 972  : 		}
; 973  : 	}
; 974  : 	// Prevent opening animation from looping
; 975  : 	else if (!(item->AnimationNow == GET.pSlot->IndexFirstAnim))

  00092	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00097	0f b7 40 26	 movzx	 eax, WORD PTR [eax+38]
  0009b	66 39 46 14	 cmp	 WORD PTR [esi+20], ax
  0009f	0f 84 ac 01 00
	00		 je	 $LN3@SearchObje

; 976  : 	{
; 977  : 		item->AnimationNow = GET.pSlot->IndexFirstAnim;

  000a5	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx

; 978  : 	}
; 979  : 	return;
; 980  : }

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
$LN17@SearchObje:

; 914  : 	{
; 915  : 		if (GetMaxDistance(&item->CordX, &lara->CordX, false) < 512)

  000b9	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  000bc	2b 43 40	 sub	 eax, DWORD PTR [ebx+64]
  000bf	57		 push	 edi
  000c0	99		 cdq
  000c1	8b c8		 mov	 ecx, eax
  000c3	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  000c6	2b 43 44	 sub	 eax, DWORD PTR [ebx+68]
  000c9	33 ca		 xor	 ecx, edx
  000cb	2b ca		 sub	 ecx, edx
  000cd	99		 cdq
  000ce	8b f8		 mov	 edi, eax
  000d0	8b 46 48	 mov	 eax, DWORD PTR [esi+72]
  000d3	2b 43 48	 sub	 eax, DWORD PTR [ebx+72]
  000d6	33 fa		 xor	 edi, edx
  000d8	2b fa		 sub	 edi, edx
  000da	99		 cdq
  000db	33 c2		 xor	 eax, edx
  000dd	2b c2		 sub	 eax, edx
  000df	3b f9		 cmp	 edi, ecx
  000e1	76 02		 jbe	 SHORT $LN23@SearchObje
  000e3	8b cf		 mov	 ecx, edi
$LN23@SearchObje:
  000e5	5f		 pop	 edi
  000e6	3b c1		 cmp	 eax, ecx
  000e8	76 02		 jbe	 SHORT $LN22@SearchObje
  000ea	8b c8		 mov	 ecx, eax
$LN22@SearchObje:
  000ec	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  000f2	7d 36		 jge	 SHORT $LN15@SearchObje

; 916  : 		{
; 917  : 			//ForceAnimationForItem(item, GetRelativeAnimation(GET.pItem) + 1, 0);
; 918  : 			if (item->AnimationNow != GET.pSlot->IndexFirstAnim + 1)

  000f4	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000fa	0f b7 41 26	 movzx	 eax, WORD PTR [ecx+38]
  000fe	0f b7 4e 14	 movzx	 ecx, WORD PTR [esi+20]
  00102	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  00105	3b ca		 cmp	 ecx, edx
  00107	74 21		 je	 SHORT $LN15@SearchObje

; 919  : 			{
; 920  : 				item->AnimationNow = GET.pSlot->IndexFirstAnim + 1;
; 921  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00109	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  0010f	40		 inc	 eax
  00110	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  00114	0f b7 c0	 movzx	 eax, ax
  00117	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 922  : 				item->FrameNow = GET.pAnimation->FrameStart;

  0011c	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00122	66 8b 42 18	 mov	 ax, WORD PTR [edx+24]
  00126	66 89 46 16	 mov	 WORD PTR [esi+22], ax
$LN15@SearchObje:

; 923  : 			}
; 924  : 		}
; 925  : 		if (item->OcbCode != 0)

  0012a	66 83 7e 2c 00	 cmp	 WORD PTR [esi+44], 0
  0012f	0f 84 1c 01 00
	00		 je	 $LN3@SearchObje

; 926  : 		{
; 927  : 			StrMovePosition pos;
; 928  : 			pos.RelX = lara->CordX;
; 929  : 			pos.RelY = lara->CordY;
; 930  : 			pos.RelZ = lara->CordZ;

  00135	8b 43 48	 mov	 eax, DWORD PTR [ebx+72]
  00138	8b 4b 40	 mov	 ecx, DWORD PTR [ebx+64]
  0013b	8b 53 44	 mov	 edx, DWORD PTR [ebx+68]
  0013e	89 45 f8	 mov	 DWORD PTR _pos$46138[ebp+8], eax

; 931  : 
; 932  : 			if (item->SlotID == SEARCH_OBJECT1)

  00141	0f b7 46 0c	 movzx	 eax, WORD PTR [esi+12]
  00145	89 4d f0	 mov	 DWORD PTR _pos$46138[ebp], ecx
  00148	b9 f2 01 00 00	 mov	 ecx, 498		; 000001f2H
  0014d	89 55 f4	 mov	 DWORD PTR _pos$46138[ebp+4], edx
  00150	66 3b c1	 cmp	 ax, cx
  00153	75 5a		 jne	 SHORT $LN13@SearchObje

; 933  : 			{
; 934  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00155	0f b7 46 14	 movzx	 eax, WORD PTR [esi+20]
  00159	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  0015f	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 935  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO1)

  00164	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  0016a	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  0016e	05 b4 00 00 00	 add	 eax, 180		; 000000b4H
$LN37@SearchObje:
  00173	0f b7 4e 16	 movzx	 ecx, WORD PTR [esi+22]
  00177	3b c8		 cmp	 ecx, eax
  00179	0f 85 d2 00 00
	00		 jne	 $LN3@SearchObje

; 936  : 				{
; 937  : 					GetItem(item->OcbCode, 1, 1);

  0017f	0f b7 56 2c	 movzx	 edx, WORD PTR [esi+44]
  00183	e8 00 00 00 00	 call	 ?GetItem@@YAXHH_N@Z	; GetItem

; 938  : 					item->OcbCode = 0;

  00188	33 d2		 xor	 edx, edx

; 939  : 					SoundEffect(62, &pos, 0);

  0018a	52		 push	 edx
  0018b	8d 45 f0	 lea	 eax, DWORD PTR _pos$46138[ebp]
  0018e	50		 push	 eax
  0018f	6a 3e		 push	 62			; 0000003eH
  00191	b9 40 e4 45 00	 mov	 ecx, 4580416		; 0045e440H
  00196	66 89 56 2c	 mov	 WORD PTR [esi+44], dx
  0019a	ff d1		 call	 ecx

; 968  : 					item->OcbCode = 0;
; 969  : 					SoundEffect(62, &pos, 0);

  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019f	5e		 pop	 esi
  001a0	5b		 pop	 ebx

; 978  : 	}
; 979  : 	return;
; 980  : }

  001a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a4	33 cd		 xor	 ecx, ebp
  001a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c3		 ret	 0
$LN13@SearchObje:

; 940  : 				}
; 941  : 			}
; 942  : 			else if (item->SlotID == SEARCH_OBJECT2)

  001af	ba f3 01 00 00	 mov	 edx, 499		; 000001f3H
  001b4	66 3b c2	 cmp	 ax, dx
  001b7	75 1d		 jne	 SHORT $LN10@SearchObje

; 943  : 			{
; 944  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  001b9	0f b7 46 14	 movzx	 eax, WORD PTR [esi+20]
  001bd	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  001c3	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 945  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO2)

  001c8	a1 f2 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  001cd	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  001d1	83 c1 64	 add	 ecx, 100		; 00000064H

; 946  : 				{
; 947  : 					GetItem(item->OcbCode, 1, 1);
; 948  : 					item->OcbCode = 0;
; 949  : 					SoundEffect(62, &pos, 0);
; 950  : 				}
; 951  : 			}

  001d4	eb 52		 jmp	 SHORT $LN36@SearchObje
$LN10@SearchObje:

; 952  : 			else if (item->SlotID == SEARCH_OBJECT3)

  001d6	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  001db	66 3b c1	 cmp	 ax, cx
  001de	75 23		 jne	 SHORT $LN7@SearchObje

; 953  : 			{
; 954  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  001e0	0f b7 46 14	 movzx	 eax, WORD PTR [esi+20]
  001e4	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  001ea	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 955  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO3)

  001ef	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  001f5	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  001f9	05 99 00 00 00	 add	 eax, 153		; 00000099H

; 956  : 				{
; 957  : 					GetItem(item->OcbCode, 1, 1);
; 958  : 					item->OcbCode = 0;
; 959  : 					SoundEffect(62, &pos, 0);
; 960  : 				}
; 961  : 			}

  001fe	e9 70 ff ff ff	 jmp	 $LN37@SearchObje
$LN7@SearchObje:

; 962  : 			else if (item->SlotID == SEARCH_OBJECT4)

  00203	ba f5 01 00 00	 mov	 edx, 501		; 000001f5H
  00208	66 3b c2	 cmp	 ax, dx
  0020b	75 44		 jne	 SHORT $LN3@SearchObje

; 963  : 			{
; 964  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  0020d	0f b7 46 14	 movzx	 eax, WORD PTR [esi+20]
  00211	8b 0d 64 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00217	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 965  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO4)

  0021c	a1 f2 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00221	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  00225	83 c1 53	 add	 ecx, 83			; 00000053H
$LN36@SearchObje:
  00228	0f b7 56 16	 movzx	 edx, WORD PTR [esi+22]
  0022c	3b d1		 cmp	 edx, ecx
  0022e	75 21		 jne	 SHORT $LN3@SearchObje

; 966  : 				{
; 967  : 					GetItem(item->OcbCode, 1, 1);

  00230	0f b7 56 2c	 movzx	 edx, WORD PTR [esi+44]
  00234	e8 00 00 00 00	 call	 ?GetItem@@YAXHH_N@Z	; GetItem

; 968  : 					item->OcbCode = 0;
; 969  : 					SoundEffect(62, &pos, 0);

  00239	6a 00		 push	 0
  0023b	8d 4d f0	 lea	 ecx, DWORD PTR _pos$46138[ebp]
  0023e	51		 push	 ecx
  0023f	33 c0		 xor	 eax, eax
  00241	6a 3e		 push	 62			; 0000003eH
  00243	ba 40 e4 45 00	 mov	 edx, 4580416		; 0045e440H
  00248	66 89 46 2c	 mov	 WORD PTR [esi+44], ax
  0024c	ff d2		 call	 edx
  0024e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SearchObje:

; 978  : 	}
; 979  : 	return;
; 980  : }

  00251	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00254	5e		 pop	 esi
  00255	33 cd		 xor	 ecx, ebp
  00257	5b		 pop	 ebx
  00258	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c3		 ret	 0
?SearchObjectControl@@YAXF@Z ENDP			; SearchObjectControl
_TEXT	ENDS
PUBLIC	?cbCycleEnd@@YAHXZ				; cbCycleEnd
; Function compile flags: /Ogtp
;	COMDAT ?cbCycleEnd@@YAHXZ
_TEXT	SEGMENT
?cbCycleEnd@@YAHXZ PROC					; cbCycleEnd, COMDAT

; 703  : 	StepDownFix();

  00000	e8 00 00 00 00	 call	 ?StepDownFix@@YAXXZ	; StepDownFix

; 704  : 	WideScreen();

  00005	e8 00 00 00 00	 call	 ?WideScreen@@YAXXZ	; WideScreen

; 705  : 	return RET_CYCLE_CONTINUE;	

  0000a	33 c0		 xor	 eax, eax

; 706  : }

  0000c	c3		 ret	 0
?cbCycleEnd@@YAHXZ ENDP					; cbCycleEnd
_TEXT	ENDS
PUBLIC	?InitSearchObject4@@YAXXZ			; InitSearchObject4
; Function compile flags: /Ogtp
;	COMDAT ?InitSearchObject4@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject4@@YAXXZ PROC				; InitSearchObject4, COMDAT

; 1068 : 	Get(enumGET.SLOT, SEARCH_OBJECT4, 0);

  00000	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00006	b8 f5 01 00 00	 mov	 eax, 501		; 000001f5H
  0000b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1069 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0)

  00010	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00015	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0001a	74 09		 je	 SHORT $LN1@InitSearch
  0001c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00023	74 2e		 je	 SHORT $LN2@InitSearch
$LN1@InitSearch:

; 1070 : 		return;
; 1071 : 
; 1072 : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  00025	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 1073 : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  0002c	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00031	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 1074 : 	GET.pSlot->pProcControl = SearchObjectControl;

  00038	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0003e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 1075 : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  00045	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0004a	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0004f	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN2@InitSearch:

; 1076 : }

  00053	c3		 ret	 0
?InitSearchObject4@@YAXXZ ENDP				; InitSearchObject4
_TEXT	ENDS
PUBLIC	?InitSearchObject3@@YAXXZ			; InitSearchObject3
; Function compile flags: /Ogtp
;	COMDAT ?InitSearchObject3@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject3@@YAXXZ PROC				; InitSearchObject3, COMDAT

; 1056 : 	Get(enumGET.SLOT, SEARCH_OBJECT3, 0);

  00000	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00006	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  0000b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1057 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0) {

  00010	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00015	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0001a	74 09		 je	 SHORT $LN1@InitSearch@2
  0001c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00023	74 2e		 je	 SHORT $LN2@InitSearch@2
$LN1@InitSearch@2:

; 1058 : 		return;
; 1059 : 	}
; 1060 : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  00025	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 1061 : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  0002c	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00031	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 1062 : 	GET.pSlot->pProcControl = SearchObjectControl;

  00038	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0003e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 1063 : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  00045	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0004a	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0004f	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN2@InitSearch@2:

; 1064 : }

  00053	c3		 ret	 0
?InitSearchObject3@@YAXXZ ENDP				; InitSearchObject3
_TEXT	ENDS
PUBLIC	?InitSearchObject2@@YAXXZ			; InitSearchObject2
; Function compile flags: /Ogtp
;	COMDAT ?InitSearchObject2@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject2@@YAXXZ PROC				; InitSearchObject2, COMDAT

; 1044 : 	Get(enumGET.SLOT, SEARCH_OBJECT2, 0);

  00000	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00006	b8 f3 01 00 00	 mov	 eax, 499		; 000001f3H
  0000b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1045 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0) {

  00010	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00015	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0001a	74 09		 je	 SHORT $LN1@InitSearch@3
  0001c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00023	74 2e		 je	 SHORT $LN2@InitSearch@3
$LN1@InitSearch@3:

; 1046 : 		return;
; 1047 : 	}
; 1048 : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  00025	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 1049 : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  0002c	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00031	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 1050 : 	GET.pSlot->pProcControl = SearchObjectControl;

  00038	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0003e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 1051 : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  00045	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0004a	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0004f	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN2@InitSearch@3:

; 1052 : }

  00053	c3		 ret	 0
?InitSearchObject2@@YAXXZ ENDP				; InitSearchObject2
_TEXT	ENDS
PUBLIC	?InitSearchObject1@@YAXXZ			; InitSearchObject1
; Function compile flags: /Ogtp
;	COMDAT ?InitSearchObject1@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject1@@YAXXZ PROC				; InitSearchObject1, COMDAT

; 1032 : 	Get(enumGET.SLOT, SEARCH_OBJECT1, 0);

  00000	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00006	b8 f2 01 00 00	 mov	 eax, 498		; 000001f2H
  0000b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get

; 1033 : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0) {

  00010	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00015	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0001a	74 09		 je	 SHORT $LN1@InitSearch@4
  0001c	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00023	74 2e		 je	 SHORT $LN2@InitSearch@4
$LN1@InitSearch@4:

; 1034 : 		return;
; 1035 : 	}
; 1036 : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  00025	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 1037 : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  0002c	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00031	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 1038 : 	GET.pSlot->pProcControl = SearchObjectControl;

  00038	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0003e	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 1039 : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  00045	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0004a	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0004f	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN2@InitSearch@4:

; 1040 : }

  00053	c3		 ret	 0
?InitSearchObject1@@YAXXZ ENDP				; InitSearchObject1
_TEXT	ENDS
PUBLIC	?cbInitObjects@@YAXXZ				; cbInitObjects
; Function compile flags: /Ogtp
;	COMDAT ?cbInitObjects@@YAXXZ
_TEXT	SEGMENT
?cbInitObjects@@YAXXZ PROC				; cbInitObjects, COMDAT

; 1115 : 	InitSearchObject1();

  00000	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	b8 f2 01 00 00	 mov	 eax, 498		; 000001f2H
  0000e	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00013	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00018	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  0001d	bb 00 00 00 00	 mov	 ebx, OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject
  00022	bf 00 00 00 00	 mov	 edi, OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject
  00027	be 00 00 00 00	 mov	 esi, OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl
  0002c	74 09		 je	 SHORT $LN3@cbInitObje
  0002e	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00035	74 22		 je	 SHORT $LN4@cbInitObje
$LN3@cbInitObje:
  00037	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  0003a	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0003f	89 78 20	 mov	 DWORD PTR [eax+32], edi
  00042	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00048	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  0004b	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00050	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00055	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN4@cbInitObje:

; 1116 : 	InitSearchObject2();

  00059	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  0005f	b8 f3 01 00 00	 mov	 eax, 499		; 000001f3H
  00064	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00069	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0006e	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  00073	74 09		 je	 SHORT $LN6@cbInitObje
  00075	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  0007c	74 24		 je	 SHORT $LN7@cbInitObje
$LN6@cbInitObje:
  0007e	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  00081	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00087	89 79 20	 mov	 DWORD PTR [ecx+32], edi
  0008a	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00090	89 72 10	 mov	 DWORD PTR [edx+16], esi
  00093	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00099	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0009e	66 89 41 32	 mov	 WORD PTR [ecx+50], ax
$LN7@cbInitObje:

; 1117 : 	InitSearchObject3();

  000a2	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  000a8	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  000ad	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  000b2	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000b7	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  000bc	74 09		 je	 SHORT $LN9@cbInitObje
  000be	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  000c5	74 23		 je	 SHORT $LN10@cbInitObje
$LN9@cbInitObje:
  000c7	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  000ca	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000d0	89 7a 20	 mov	 DWORD PTR [edx+32], edi
  000d3	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000d8	89 70 10	 mov	 DWORD PTR [eax+16], esi
  000db	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000e1	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  000e6	66 89 4a 32	 mov	 WORD PTR [edx+50], cx
$LN10@cbInitObje:

; 1118 : 	InitSearchObject4();

  000ea	8b 0d 5c 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  000f0	b8 f5 01 00 00	 mov	 eax, 501		; 000001f5H
  000f5	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  000fa	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  000ff	66 83 78 32 00	 cmp	 WORD PTR [eax+50], 0
  00104	74 09		 je	 SHORT $LN12@cbInitObje
  00106	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  0010d	74 22		 je	 SHORT $LN13@cbInitObje
$LN12@cbInitObje:
  0010f	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  00112	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00117	89 78 20	 mov	 DWORD PTR [eax+32], edi
  0011a	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00120	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00123	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00128	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  0012d	66 89 50 32	 mov	 WORD PTR [eax+50], dx
$LN13@cbInitObje:
  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx

; 1119 : 	InitAlchemyPuzzleObject();

  00134	e9 00 00 00 00	 jmp	 ?InitAlchemyPuzzleObject@@YAXXZ ; InitAlchemyPuzzleObject
?cbInitObjects@@YAXXZ ENDP				; cbInitObjects
_TEXT	ENDS
PUBLIC	?RequireMyCallBacks@@YA_NXZ			; RequireMyCallBacks
; Function compile flags: /Ogtp
;	COMDAT ?RequireMyCallBacks@@YA_NXZ
_TEXT	SEGMENT
?RequireMyCallBacks@@YA_NXZ PROC			; RequireMyCallBacks, COMDAT

; 1130 : // ************  RequireMyCallBacks() function  *****************
; 1131 : 	// protype of GET_CALLBACK:
; 1132 : 	// GET_CALLBACK(CallBackCB, CBT_Flags, Index, MyProcToCall)
; 1133 : 	// default callbacks required always 
; 1134 : 	GET_CALLBACK(CB_INIT_PROGRAM, 0, 0, cbInitProgram)

  00000	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00007	68 00 00 00 00	 push	 OFFSET ?cbInitProgram@@YAXHQAPAD@Z ; cbInitProgram
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	6a 00		 push	 0
  00012	50		 push	 eax
  00013	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00019	84 c0		 test	 al, al
  0001b	75 03		 jne	 SHORT $LN16@RequireMyC
$LN51@RequireMyC:
  0001d	32 c0		 xor	 al, al

; 1150 : 
; 1151 : 	return true;
; 1152 : }

  0001f	c3		 ret	 0
$LN16@RequireMyC:

; 1135 : 	GET_CALLBACK(CB_INIT_GAME, 0, 0, cbInitGame)

  00020	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00027	68 00 00 00 00	 push	 OFFSET ?cbInitGame@@YAXXZ ; cbInitGame
  0002c	6a 00		 push	 0
  0002e	6a 00		 push	 0
  00030	6a 03		 push	 3
  00032	51		 push	 ecx
  00033	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00039	84 c0		 test	 al, al
  0003b	74 e0		 je	 SHORT $LN51@RequireMyC

; 1136 : 	GET_CALLBACK(CB_INIT_LEVEL, 0,0, cbInitLevel)

  0003d	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00044	68 00 00 00 00	 push	 OFFSET ?cbInitLevel@@YAXHHK@Z ; cbInitLevel
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	6a 10		 push	 16			; 00000010H
  0004f	52		 push	 edx
  00050	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00056	84 c0		 test	 al, al
  00058	74 c3		 je	 SHORT $LN51@RequireMyC

; 1137 : 	GET_CALLBACK(CB_SAVING_GAME, 0, 0, cbSaveMyData)

  0005a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00061	68 00 00 00 00	 push	 OFFSET ?cbSaveMyData@@YAKPAPAEH@Z ; cbSaveMyData
  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 01		 push	 1
  0006c	50		 push	 eax
  0006d	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00073	84 c0		 test	 al, al
  00075	74 a6		 je	 SHORT $LN51@RequireMyC

; 1138 : 	GET_CALLBACK(CB_LOADING_GAME, 0, 0, cbLoadMyData)

  00077	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  0007e	68 00 00 00 00	 push	 OFFSET ?cbLoadMyData@@YAXPAEK@Z ; cbLoadMyData
  00083	6a 00		 push	 0
  00085	6a 00		 push	 0
  00087	6a 02		 push	 2
  00089	51		 push	 ecx
  0008a	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00090	84 c0		 test	 al, al
  00092	74 89		 je	 SHORT $LN51@RequireMyC

; 1139 : 	GET_CALLBACK(CB_INIT_LOAD_NEW_LEVEL, 0,0, cbInitLoadNewLevel);

  00094	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  0009b	68 00 00 00 00	 push	 OFFSET ?cbInitLoadNewLevel@@YAXXZ ; cbInitLoadNewLevel
  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	6a 04		 push	 4
  000a6	52		 push	 edx
  000a7	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  000ad	84 c0		 test	 al, al
  000af	0f 84 68 ff ff
	ff		 je	 $LN51@RequireMyC

; 1140 : 	GET_CALLBACK(CB_FLIPEFFECT_MINE, 0, 0, cbFlipEffectMine);

  000b5	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Trng@@3UStrTrngInfos@@A
  000bc	68 00 00 00 00	 push	 OFFSET ?cbFlipEffectMine@@YAHGGGG@Z ; cbFlipEffectMine
  000c1	6a 00		 push	 0
  000c3	6a 00		 push	 0
  000c5	6a 05		 push	 5
  000c7	50		 push	 eax
  000c8	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  000ce	84 c0		 test	 al, al
  000d0	0f 84 47 ff ff
	ff		 je	 $LN51@RequireMyC

; 1141 : 	GET_CALLBACK(CB_ACTION_MINE, 0,0, cbActionMine);

  000d6	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  000dd	68 00 00 00 00	 push	 OFFSET ?cbActionMine@@YAHGHGG@Z ; cbActionMine
  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	6a 06		 push	 6
  000e8	51		 push	 ecx
  000e9	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  000ef	84 c0		 test	 al, al
  000f1	0f 84 26 ff ff
	ff		 je	 $LN51@RequireMyC

; 1142 : 	GET_CALLBACK(CB_CONDITION_MINE,0,0,cbConditionMine);

  000f7	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  000fe	68 00 00 00 00	 push	 OFFSET ?cbConditionMine@@YAHGHGG@Z ; cbConditionMine
  00103	6a 00		 push	 0
  00105	6a 00		 push	 0
  00107	6a 07		 push	 7
  00109	52		 push	 edx
  0010a	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00110	84 c0		 test	 al, al
  00112	0f 84 05 ff ff
	ff		 je	 $LN51@RequireMyC

; 1143 : 	GET_CALLBACK(CB_CUSTOMIZE_MINE, 0,0, cbCustomizeMine);

  00118	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Trng@@3UStrTrngInfos@@A
  0011f	68 00 00 00 00	 push	 OFFSET ?cbCustomizeMine@@YAXGHPAF@Z ; cbCustomizeMine
  00124	6a 00		 push	 0
  00126	6a 00		 push	 0
  00128	6a 08		 push	 8
  0012a	50		 push	 eax
  0012b	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00131	84 c0		 test	 al, al
  00133	0f 84 e4 fe ff
	ff		 je	 $LN51@RequireMyC

; 1144 : 	GET_CALLBACK(CB_PARAMETER_MINE, 0, 0, cbParametersMine);

  00139	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00140	68 00 00 00 00	 push	 OFFSET ?cbParametersMine@@YAXGHPAF@Z ; cbParametersMine
  00145	6a 00		 push	 0
  00147	6a 00		 push	 0
  00149	6a 09		 push	 9
  0014b	51		 push	 ecx
  0014c	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00152	84 c0		 test	 al, al
  00154	0f 84 c3 fe ff
	ff		 je	 $LN51@RequireMyC

; 1145 : 	GET_CALLBACK(CB_ASSIGN_SLOT_MINE, 0,0, cbAssignSlotMine);

  0015a	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00161	68 00 00 00 00	 push	 OFFSET ?cbAssignSlotMine@@YAXGG@Z ; cbAssignSlotMine
  00166	6a 00		 push	 0
  00168	6a 00		 push	 0
  0016a	6a 13		 push	 19			; 00000013H
  0016c	52		 push	 edx
  0016d	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00173	84 c0		 test	 al, al
  00175	0f 84 a2 fe ff
	ff		 je	 $LN51@RequireMyC

; 1146 : 	GET_CALLBACK(CB_CYCLE_BEGIN, 0, 0, cbCycleBegin);

  0017b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00182	68 00 00 00 00	 push	 OFFSET ?cbCycleBegin@@YAXXZ ; cbCycleBegin
  00187	6a 00		 push	 0
  00189	6a 00		 push	 0
  0018b	6a 0a		 push	 10			; 0000000aH
  0018d	50		 push	 eax
  0018e	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  00194	84 c0		 test	 al, al
  00196	0f 84 81 fe ff
	ff		 je	 $LN51@RequireMyC

; 1147 : 	GET_CALLBACK(CB_PROGR_ACTION_MINE, 0, 0, cbProgrActionMine);

  0019c	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  001a3	68 00 00 00 00	 push	 OFFSET ?cbProgrActionMine@@YAXXZ ; cbProgrActionMine
  001a8	6a 00		 push	 0
  001aa	6a 00		 push	 0
  001ac	6a 0e		 push	 14			; 0000000eH
  001ae	51		 push	 ecx
  001af	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  001b5	84 c0		 test	 al, al
  001b7	0f 84 60 fe ff
	ff		 je	 $LN51@RequireMyC

; 1148 : 	GET_CALLBACK(CB_INIT_OBJECTS, 0, 0, cbInitObjects);

  001bd	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  001c4	68 00 00 00 00	 push	 OFFSET ?cbInitObjects@@YAXXZ ; cbInitObjects
  001c9	6a 00		 push	 0
  001cb	6a 00		 push	 0
  001cd	6a 0d		 push	 13			; 0000000dH
  001cf	52		 push	 edx
  001d0	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  001d6	84 c0		 test	 al, al
  001d8	0f 84 3f fe ff
	ff		 je	 $LN51@RequireMyC

; 1149 : 	GET_CALLBACK(CB_CYCLE_END, 0, 0, cbCycleEnd);

  001de	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?Trng@@3UStrTrngInfos@@A
  001e5	68 00 00 00 00	 push	 OFFSET ?cbCycleEnd@@YAHXZ ; cbCycleEnd
  001ea	6a 00		 push	 0
  001ec	6a 00		 push	 0
  001ee	6a 0b		 push	 11			; 0000000bH
  001f0	50		 push	 eax
  001f1	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  001f7	84 c0		 test	 al, al
  001f9	0f 95 c0	 setne	 al

; 1150 : 
; 1151 : 	return true;
; 1152 : }

  001fc	c3		 ret	 0
?RequireMyCallBacks@@YA_NXZ ENDP			; RequireMyCallBacks
_TEXT	ENDS
PUBLIC	?InitializeAll@@YA_NXZ				; InitializeAll
; Function compile flags: /Ogtp
;	COMDAT ?InitializeAll@@YA_NXZ
_TEXT	SEGMENT
?InitializeAll@@YA_NXZ PROC				; InitializeAll, COMDAT

; 1163 : 	StrTestPosition *pPos;
; 1164 : 	OldZoom = 128;

  00000	c7 05 00 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?OldZoom@@3HA, 128 ; OldZoom, 00000080H

; 1165 : // ************  InitializeAll() function  ****************
; 1166 : 	//  perform all your patches
; 1167 : 	CALL_CHECK(CreateMyCodePatches)
; 1168 : 
; 1169 : 	// call the function that requires all callback you need
; 1170 : 	CALL_CHECK(RequireMyCallBacks)

  0000a	e8 00 00 00 00	 call	 ?RequireMyCallBacks@@YA_NXZ ; RequireMyCallBacks
  0000f	84 c0		 test	 al, al
  00011	75 01		 jne	 SHORT $LN1@Initialize

; 1254 : }

  00013	c3		 ret	 0
$LN1@Initialize:

; 1171 : 
; 1172 : 	// TYPE_HERE: code to allocate global resource to use in the whole game
; 1173 : 
; 1174 : 	SearchObject1TestPosition.Slot = SEARCH_OBJECT1;
; 1175 : 	pPos = &SearchObject1TestPosition.DatiPosition;
; 1176 : 	pPos->Distance.MinX = 0 - 256;
; 1177 : 	pPos->Distance.MaxX = 0 + 256;
; 1178 : 	pPos->Distance.MinY = 0;
; 1179 : 	pPos->Distance.MaxY = 0;
; 1180 : 	pPos->Distance.MinZ = 0 - 512;
; 1181 : 	pPos->Distance.MaxZ = 0 + 512;

  00014	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00019	66 a3 10 00 00
	00		 mov	 WORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+16, ax

; 1182 : 	pPos->Orienting.OrientHMin = -10 * ONE_DEGREE;
; 1183 : 	pPos->Orienting.OrientHMax = 10 * ONE_DEGREE;
; 1184 : 	pPos->Orienting.OrientRMin = -30 * ONE_DEGREE;
; 1185 : 	pPos->Orienting.OrientRMax = 30 * ONE_DEGREE;
; 1186 : 	pPos->Orienting.OrientVMin = -10 * ONE_DEGREE;
; 1187 : 	pPos->Orienting.OrientVMax = 10 * ONE_DEGREE;
; 1188 : 	/*pPos->Distance.MinX = -512;
; 1189 : 	pPos->Distance.MaxX = 512;
; 1190 : 	pPos->Distance.MinY = -128;
; 1191 : 	pPos->Distance.MaxY = 128;
; 1192 : 	pPos->Distance.MinZ = -192;
; 1193 : 	pPos->Distance.MaxZ = 192;
; 1194 : 
; 1195 : 	pPos->Orienting.OrientHMin = -6000;
; 1196 : 	pPos->Orienting.OrientHMax = 6000;
; 1197 : 	pPos->Orienting.OrientVMin = -1000;
; 1198 : 	pPos->Orienting.OrientVMax = 1000;
; 1199 : 	pPos->Orienting.OrientRMin = -1000;
; 1200 : 	pPos->Orienting.OrientRMax = 1000;*/
; 1201 : 
; 1202 : 	// Search Object2
; 1203 : 	SearchObject2TestPosition.Slot = SEARCH_OBJECT2;
; 1204 : 	pPos = &SearchObject2TestPosition.DatiPosition;
; 1205 : 	pPos->Distance.MinX = -256;
; 1206 : 	pPos->Distance.MaxX = 256;
; 1207 : 	pPos->Distance.MinY = -128;
; 1208 : 	pPos->Distance.MaxY = 128;
; 1209 : 	pPos->Distance.MinZ = 128-332;
; 1210 : 	pPos->Distance.MaxZ = 160;
; 1211 : 
; 1212 : 	pPos->Orienting.OrientHMin = -6000;
; 1213 : 	pPos->Orienting.OrientHMax = 6000;
; 1214 : 	pPos->Orienting.OrientVMin = -1000;
; 1215 : 	pPos->Orienting.OrientVMax = 1000;
; 1216 : 	pPos->Orienting.OrientRMin = -1000;
; 1217 : 	pPos->Orienting.OrientRMax = 1000;
; 1218 : 
; 1219 : 	// Search Object3
; 1220 : 	SearchObject3TestPosition.Slot = SEARCH_OBJECT3;
; 1221 : 	pPos = &SearchObject3TestPosition.DatiPosition;
; 1222 : 	pPos->Distance.MinX = -512;
; 1223 : 	pPos->Distance.MaxX = 512;
; 1224 : 	pPos->Distance.MinY = -128;
; 1225 : 	pPos->Distance.MaxY = 128;
; 1226 : 	pPos->Distance.MinZ = -192;
; 1227 : 	pPos->Distance.MaxZ = 192;
; 1228 : 
; 1229 : 	pPos->Orienting.OrientHMin = -6000;
; 1230 : 	pPos->Orienting.OrientHMax = 6000;
; 1231 : 	pPos->Orienting.OrientVMin = -1000;
; 1232 : 	pPos->Orienting.OrientVMax = 1000;
; 1233 : 	pPos->Orienting.OrientRMin = -1000;
; 1234 : 	pPos->Orienting.OrientRMax = 1000;
; 1235 : 
; 1236 : 	// Search Object 4
; 1237 : 	SearchObject4TestPosition.Slot = SEARCH_OBJECT4;
; 1238 : 	pPos = &SearchObject4TestPosition.DatiPosition;
; 1239 : 	pPos->Distance.MinX = 0 - 256;
; 1240 : 	pPos->Distance.MaxX = 0 + 256;
; 1241 : 	pPos->Distance.MinY = 0;
; 1242 : 	pPos->Distance.MaxY = 0;
; 1243 : 	pPos->Distance.MinZ = -313 - 256;
; 1244 : 	pPos->Distance.MaxZ = -313 + 256;

  0001f	b8 c7 ff ff ff	 mov	 eax, -57		; ffffffc7H
  00024	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H
  00029	ba c0 00 00 00	 mov	 edx, 192		; 000000c0H
  0002e	66 a3 10 00 00
	00		 mov	 WORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+16, ax
  00034	c7 05 04 00 00
	00 f2 01 00 ff	 mov	 DWORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+4, -16776718 ; ff0001f2H
  0003e	c7 05 08 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+8, 256 ; 00000100H
  00048	c7 05 0c 00 00
	00 00 00 00 fe	 mov	 DWORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+12, -33554432 ; fe000000H
  00052	c7 05 16 00 00
	00 e4 f8 1c 07	 mov	 DWORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+22, 119339236 ; 071cf8e4H
  0005c	c7 05 1a 00 00
	00 ac ea 54 15	 mov	 DWORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+26, 357886636 ; 1554eaacH
  00066	c7 05 12 00 00
	00 e4 f8 1c 07	 mov	 DWORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+18, 119339236 ; 071cf8e4H
  00070	c7 05 04 00 00
	00 f3 01 00 ff	 mov	 DWORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+4, -16776717 ; ff0001f3H
  0007a	c7 05 08 00 00
	00 00 01 80 ff	 mov	 DWORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+8, -8388352 ; ff800100H
  00084	c7 05 0c 00 00
	00 80 00 34 ff	 mov	 DWORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+12, -13369216 ; ff340080H
  0008e	66 89 0d 10 00
	00 00		 mov	 WORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+16, cx
  00095	c7 05 16 00 00
	00 90 e8 70 17	 mov	 DWORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+22, 393275536 ; 1770e890H
  0009f	c7 05 12 00 00
	00 18 fc e8 03	 mov	 DWORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+18, 65600536 ; 03e8fc18H
  000a9	c7 05 1a 00 00
	00 18 fc e8 03	 mov	 DWORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+26, 65600536 ; 03e8fc18H
  000b3	c7 05 04 00 00
	00 f4 01 00 fe	 mov	 DWORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+4, -33553932 ; fe0001f4H
  000bd	c7 05 08 00 00
	00 00 02 80 ff	 mov	 DWORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+8, -8388096 ; ff800200H
  000c7	c7 05 0c 00 00
	00 80 00 40 ff	 mov	 DWORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+12, -12582784 ; ff400080H
  000d1	66 89 15 10 00
	00 00		 mov	 WORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+16, dx
  000d8	c7 05 16 00 00
	00 90 e8 70 17	 mov	 DWORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+22, 393275536 ; 1770e890H
  000e2	c7 05 12 00 00
	00 18 fc e8 03	 mov	 DWORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+18, 65600536 ; 03e8fc18H
  000ec	c7 05 1a 00 00
	00 18 fc e8 03	 mov	 DWORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+26, 65600536 ; 03e8fc18H
  000f6	c7 05 04 00 00
	00 f5 01 00 ff	 mov	 DWORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+4, -16776715 ; ff0001f5H
  00100	c7 05 08 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+8, 256 ; 00000100H
  0010a	c7 05 0c 00 00
	00 00 00 c7 fd	 mov	 DWORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+12, -37289984 ; fdc70000H

; 1245 : 	pPos->Orienting.OrientHMin = -10 * ONE_DEGREE;

  00114	c7 05 16 00 00
	00 e4 f8 1c 07	 mov	 DWORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+22, 119339236 ; 071cf8e4H

; 1246 : 	pPos->Orienting.OrientHMax = 10 * ONE_DEGREE;
; 1247 : 	pPos->Orienting.OrientRMin = -30 * ONE_DEGREE;

  0011e	c7 05 1a 00 00
	00 ac ea 54 15	 mov	 DWORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+26, 357886636 ; 1554eaacH

; 1248 : 	pPos->Orienting.OrientRMax = 30 * ONE_DEGREE;
; 1249 : 	pPos->Orienting.OrientVMin = -10 * ONE_DEGREE;

  00128	c7 05 12 00 00
	00 e4 f8 1c 07	 mov	 DWORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+18, 119339236 ; 071cf8e4H

; 1250 : 	pPos->Orienting.OrientVMax = 10 * ONE_DEGREE;
; 1251 : 
; 1252 : 	//InitAlchemyPuzzle();
; 1253 : 	return true;

  00132	b0 01		 mov	 al, 1

; 1254 : }

  00134	c3		 ret	 0
?InitializeAll@@YA_NXZ ENDP				; InitializeAll
_TEXT	ENDS
PUBLIC	_DllMain@12
; Function compile flags: /Ogtp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_hInstanceDll$ = 8					; size = 4
_ul_reason_for_call$ = 12				; size = 4
_lpReserved$ = 16					; size = 4
_DllMain@12 PROC					; COMDAT

; 1269 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1270 : 
; 1271 :     switch (ul_reason_for_call)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _ul_reason_for_call$[ebp]
  00006	83 e8 00	 sub	 eax, 0
  00009	74 52		 je	 SHORT $LN1@DllMain
  0000b	48		 dec	 eax
  0000c	75 63		 jne	 SHORT $LN5@DllMain

; 1272 : 	{
; 1273 : 		case DLL_PROCESS_ATTACH:
; 1274 : 			MyDllInstance = hInstanceDll;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _hInstanceDll$[ebp]
  00011	a3 00 00 00 00	 mov	 DWORD PTR ?MyDllInstance@@3PAUHINSTANCE__@@A, eax ; MyDllInstance

; 1275 : 			GetTrngInfo();

  00016	e8 00 00 00 00	 call	 ?GetTrngInfo@@YAXXZ	; GetTrngInfo

; 1276 : 			// control per check control value about size and alignment with globtomb4 structure
; 1277 : 			if (CheckControlGlobTomb4() == false) return FALSE;

  0001b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00021	81 b9 a8 5e 21
	00 67 45 23 01	 cmp	 DWORD PTR [ecx+2186920], 19088743 ; 01234567H
  0002b	74 1e		 je	 SHORT $LN3@DllMain
  0002d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00033	6a 00		 push	 0
  00035	52		 push	 edx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@LGLKDBFF@ERROR?3?5failed?5check?5of?5alignment@
  0003b	6a 11		 push	 17			; 00000011H
  0003d	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	33 c0		 xor	 eax, eax

; 1290 : }

  00047	5d		 pop	 ebp
  00048	c2 0c 00	 ret	 12			; 0000000cH
$LN3@DllMain:

; 1278 : 
; 1279 : 			if  (InitializeAll()==false) {

  0004b	e8 00 00 00 00	 call	 ?InitializeAll@@YA_NXZ	; InitializeAll
  00050	33 c9		 xor	 ecx, ecx
  00052	84 c0		 test	 al, al
  00054	0f 95 c1	 setne	 cl
  00057	8b c1		 mov	 eax, ecx

; 1290 : }

  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$LN1@DllMain:

; 1280 : 				return FALSE;
; 1281 : 			}
; 1282 : 			return TRUE;
; 1283 : 			
; 1284 : 
; 1285 : 		case DLL_PROCESS_DETACH:
; 1286 : 			ReleaseAll();

  0005d	e8 00 00 00 00	 call	 ?FreeMemoryCustomize@@YAXXZ ; FreeMemoryCustomize
  00062	e8 00 00 00 00	 call	 ?FreeMemoryParameters@@YAXXZ ; FreeMemoryParameters
  00067	c7 05 ad 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3245, 0
$LN5@DllMain:

; 1287 : 			break;
; 1288 :     }
; 1289 :     return TRUE;

  00071	b8 01 00 00 00	 mov	 eax, 1

; 1290 : }

  00076	5d		 pop	 ebp
  00077	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
END
