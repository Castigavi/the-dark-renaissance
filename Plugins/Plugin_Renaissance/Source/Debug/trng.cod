; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\Dominik\Google Drive\TLD\Script\Plugin_Renaissance\Source\trng.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?enumSAVT@@3UStrEnumSAVT@@A			; enumSAVT
PUBLIC	?enumPHASE@@3UStrEnumPHASE@@A			; enumPHASE
PUBLIC	?enumFWEAP@@3UStrEnumFWEAP@@A			; enumFWEAP
PUBLIC	?enumFSLOT@@3UStrEnumFSLOT@@A			; enumFSLOT
PUBLIC	?enumCOLF@@3UStrEnumCOLF@@A			; enumCOLF
PUBLIC	?enumDENV@@3UStrEnumDENV@@A			; enumDENV
PUBLIC	?enumFC@@3UStrEnumFC@@A				; enumFC
PUBLIC	?enumSMAIN@@3UStrEnumSMAIN@@A			; enumSMAIN
PUBLIC	?enumWTF@@3UStrEnumWTF@@A			; enumWTF
PUBLIC	?enumAPPC@@3UStrEnumAPPC@@A			; enumAPPC
PUBLIC	?enumCPU@@3UStrEnumCPU@@A			; enumCPU
PUBLIC	?enumFIND@@3UStrEnumFIND@@A			; enumFIND
PUBLIC	?enumCTRET@@3UStrEnumCTRET@@A			; enumCTRET
PUBLIC	?enumFLH@@3UStrEnumFLH@@A			; enumFLH
PUBLIC	?enumCBEET@@3UStrEnumCBEET@@A			; enumCBEET
PUBLIC	?enumJOINT@@3UStrEnumJOINT@@A			; enumJOINT
PUBLIC	?enumFITEM@@3UStrEnumFITEM@@A			; enumFITEM
PUBLIC	?enumWSKIN@@3UStrEnumWSKIN@@A			; enumWSKIN
PUBLIC	?enumSC@@3UStrEnumSC@@A				; enumSC
PUBLIC	?enumSCANF@@3UStrEnumSCANF@@A			; enumSCANF
PUBLIC	?enumGET@@3UStrEnumGET@@A			; enumGET
PUBLIC	?enumFTS@@3UStrEnumFTS@@A			; enumFTS
PUBLIC	?enumSRET@@3UStrEnumSRET@@A			; enumSRET
PUBLIC	?enumTRET@@3UStrEnumTRET@@A			; enumTRET
PUBLIC	?enumFROOM@@3UStrEnumFROOM@@A			; enumFROOM
PUBLIC	?enumKCOMBO@@3UStrEnumKCOMBO@@A			; enumKCOMBO
PUBLIC	?enumSLOPE@@3UStrEnumSLOPE@@A			; enumSLOPE
PUBLIC	?enumCB@@3UStrEnumCB@@A				; enumCB
PUBLIC	?enumCOMBO@@3UStrEnumCOMBO@@A			; enumCOMBO
PUBLIC	?GET@@3UStrGetLocator@@A			; GET
PUBLIC	?enumFAN@@3UStrEnumFAN@@A			; enumFAN
PUBLIC	?enumPCOMBO@@3UStrEnumPCOMBO@@A			; enumPCOMBO
PUBLIC	?enumEDGX@@3UStrEnumEDGX@@A			; enumEDGX
PUBLIC	?enumCMD@@3UStrEnumCMD@@A			; enumCMD
PUBLIC	?TempRoomIndex@@3GA				; TempRoomIndex
PUBLIC	?enumMEMT@@3UStrEnumMEMT@@A			; enumMEMT
PUBLIC	?Trng@@3UStrTrngInfos@@A			; Trng
PUBLIC	?BufferLog@@3PADA				; BufferLog
PUBLIC	?enumSLOT@@3UStrEnumSLOT@@A			; enumSLOT
PUBLIC	?enumPRET@@3UStrEnumPRET@@A			; enumPRET
PUBLIC	?FLOOR@@3UStrFloorAnalyse@@A			; FLOOR
PUBLIC	?enumEX16@@3UStrEnumEX16@@A			; enumEX16
PUBLIC	?enumSKIP@@3UStrEnumSKIP@@A			; enumSKIP
PUBLIC	?enumHOLD@@3UStrEnumHOLD@@A			; enumHOLD
PUBLIC	?enumCBT@@3UStrEnumCBT@@A			; enumCBT
PUBLIC	?enumFT@@3UStrEnumFT@@A				; enumFT
PUBLIC	?enumFL2@@3UStrEnumFL2@@A			; enumFL2
PUBLIC	?enumRIB@@3UStrEnumRIB@@A			; enumRIB
PUBLIC	?FIND@@3UStrFind@@A				; FIND
PUBLIC	?enumFL@@3UStrEnumFL@@A				; enumFL
PUBLIC	?LOF@@3UStrLOFData@@A				; LOF
PUBLIC	?enumLLF@@3UStrEnumLLF@@A			; enumLLF
PUBLIC	?enumSLEV@@3UStrEnumSLEV@@A			; enumSLEV
PUBLIC	?COLLIDE@@3UStrCollisionLast@@A			; COLLIDE
PUBLIC	?enumIRET@@3UStrEnumIRET@@A			; enumIRET
PUBLIC	?enumSRV@@3UStrEnumSRV@@A			; enumSRV
PUBLIC	?enumMESH@@3UStrEnumMESH@@A			; enumMESH
PUBLIC	?enumSTRING@@3UStrEnumSTRING@@A			; enumSTRING
PUBLIC	?enumDGX@@3UStrEnumDGX@@A			; enumDGX
PUBLIC	?enumD3D@@3UStrEnumD3D@@A			; enumD3D
PUBLIC	?enumSSLOT@@3UStrEnumSSLOT@@A			; enumSSLOT
PUBLIC	?enumORIENT@@3UStrEnumORIENT@@A			; enumORIENT
PUBLIC	?TempStaticIndex@@3GA				; TempStaticIndex
PUBLIC	?enumFIL@@3UStrEnumFIL@@A			; enumFIL
PUBLIC	?enumENV@@3UStrEnumENV@@A			; enumENV
PUBLIC	?enumADD@@3UStrEnumADD@@A			; enumADD
PUBLIC	?enumCONV@@3UStrEnumCONV@@A			; enumCONV
_BSS	SEGMENT
?enumSAVT@@3UStrEnumSAVT@@A DB 0cH DUP (?)		; enumSAVT
?enumPHASE@@3UStrEnumPHASE@@A DB 028H DUP (?)		; enumPHASE
?enumFWEAP@@3UStrEnumFWEAP@@A DB 014H DUP (?)		; enumFWEAP
?enumFSLOT@@3UStrEnumFSLOT@@A DB 034H DUP (?)		; enumFSLOT
	ALIGN	8

?enumCOLF@@3UStrEnumCOLF@@A DQ 01H DUP (?)		; enumCOLF
?enumDENV@@3UStrEnumDENV@@A DB 010H DUP (?)		; enumDENV
?enumFC@@3UStrEnumFC@@A DB 020H DUP (?)			; enumFC
?enumSMAIN@@3UStrEnumSMAIN@@A DB 014H DUP (?)		; enumSMAIN
?enumWTF@@3UStrEnumWTF@@A DB 024H DUP (?)		; enumWTF
?enumAPPC@@3UStrEnumAPPC@@A DB 03cH DUP (?)		; enumAPPC
?enumCPU@@3UStrEnumCPU@@A DB 010H DUP (?)		; enumCPU
?enumFIND@@3UStrEnumFIND@@A DB 044H DUP (?)		; enumFIND
?enumCTRET@@3UStrEnumCTRET@@A DB 020H DUP (?)		; enumCTRET
?enumFLH@@3UStrEnumFLH@@A DB 014H DUP (?)		; enumFLH
?enumCBEET@@3UStrEnumCBEET@@A DB 0cH DUP (?)		; enumCBEET
?enumJOINT@@3UStrEnumJOINT@@A DB 038H DUP (?)		; enumJOINT
?enumFITEM@@3UStrEnumFITEM@@A DB 040H DUP (?)		; enumFITEM
?enumWSKIN@@3UStrEnumWSKIN@@A DB 014H DUP (?)		; enumWSKIN
?enumSC@@3UStrEnumSC@@A DB 01cH DUP (?)			; enumSC
?enumSCANF@@3UStrEnumSCANF@@A DB 020H DUP (?)		; enumSCANF
?enumGET@@3UStrEnumGET@@A DB 074H DUP (?)		; enumGET
?enumFTS@@3UStrEnumFTS@@A DB 014H DUP (?)		; enumFTS
?enumSRET@@3UStrEnumSRET@@A DB 0cH DUP (?)		; enumSRET
?enumTRET@@3UStrEnumTRET@@A DB 010H DUP (?)		; enumTRET
?enumFROOM@@3UStrEnumFROOM@@A DB 034H DUP (?)		; enumFROOM
?enumKCOMBO@@3UStrEnumKCOMBO@@A DB 040H DUP (?)		; enumKCOMBO
?enumSLOPE@@3UStrEnumSLOPE@@A DB 014H DUP (?)		; enumSLOPE
?enumCB@@3UStrEnumCB@@A DB 0dcH DUP (?)			; enumCB
?enumCOMBO@@3UStrEnumCOMBO@@A DB 040H DUP (?)		; enumCOMBO
?GET@@3UStrGetLocator@@A DB 0254H DUP (?)		; GET
?enumFAN@@3UStrEnumFAN@@A DB 064H DUP (?)		; enumFAN
?enumPCOMBO@@3UStrEnumPCOMBO@@A DB 040H DUP (?)		; enumPCOMBO
?enumEDGX@@3UStrEnumEDGX@@A DB 020H DUP (?)		; enumEDGX
?enumCMD@@3UStrEnumCMD@@A DB 058H DUP (?)		; enumCMD
?TempRoomIndex@@3GA DW 01H DUP (?)			; TempRoomIndex
	ALIGN	4

?enumMEMT@@3UStrEnumMEMT@@A DB 018H DUP (?)		; enumMEMT
?Trng@@3UStrTrngInfos@@A DB 034H DUP (?)		; Trng
?BufferLog@@3PADA DB 01000H DUP (?)			; BufferLog
?enumSLOT@@3UStrEnumSLOT@@A DB 0824H DUP (?)		; enumSLOT
?enumPRET@@3UStrEnumPRET@@A DB 0cH DUP (?)		; enumPRET
?FLOOR@@3UStrFloorAnalyse@@A DB 04bH DUP (?)		; FLOOR
	ALIGN	4

?enumEX16@@3UStrEnumEX16@@A DB 040H DUP (?)		; enumEX16
?enumSKIP@@3UStrEnumSKIP@@A DB 02cH DUP (?)		; enumSKIP
?enumHOLD@@3UStrEnumHOLD@@A DB 044H DUP (?)		; enumHOLD
?enumCBT@@3UStrEnumCBT@@A DB 01cH DUP (?)		; enumCBT
?enumFT@@3UStrEnumFT@@A DB 020H DUP (?)			; enumFT
?enumFL2@@3UStrEnumFL2@@A DB 01cH DUP (?)		; enumFL2
?enumRIB@@3UStrEnumRIB@@A DB 034H DUP (?)		; enumRIB
?FIND@@3UStrFind@@A DB 014aeH DUP (?)			; FIND
	ALIGN	4

?enumFL@@3UStrEnumFL@@A DB 01cH DUP (?)			; enumFL
?LOF@@3UStrLOFData@@A DB 036H DUP (?)			; LOF
	ALIGN	4

?enumLLF@@3UStrEnumLLF@@A DB 014H DUP (?)		; enumLLF
?enumSLEV@@3UStrEnumSLEV@@A DB 040H DUP (?)		; enumSLEV
?COLLIDE@@3UStrCollisionLast@@A DB 03cH DUP (?)		; COLLIDE
?enumIRET@@3UStrEnumIRET@@A DB 0cH DUP (?)		; enumIRET
?enumSRV@@3UStrEnumSRV@@A DB 0f4H DUP (?)		; enumSRV
?enumMESH@@3UStrEnumMESH@@A DB 03cH DUP (?)		; enumMESH
?enumSTRING@@3UStrEnumSTRING@@A DB 030H DUP (?)		; enumSTRING
?enumDGX@@3UStrEnumDGX@@A DB 040H DUP (?)		; enumDGX
?enumD3D@@3UStrEnumD3D@@A DB 018H DUP (?)		; enumD3D
?enumSSLOT@@3UStrEnumSSLOT@@A DB 0284H DUP (?)		; enumSSLOT
?enumORIENT@@3UStrEnumORIENT@@A DB 020H DUP (?)		; enumORIENT
?TempStaticIndex@@3GA DW 01H DUP (?)			; TempStaticIndex
	ALIGN	4

?enumFIL@@3UStrEnumFIL@@A DB 018H DUP (?)		; enumFIL
?enumENV@@3UStrEnumENV@@A DB 014cH DUP (?)		; enumENV
?enumADD@@3UStrEnumADD@@A DB 020H DUP (?)		; enumADD
?enumCONV@@3UStrEnumCONV@@A DB 030H DUP (?)		; enumCONV
_BSS	ENDS
_DATA	SEGMENT
?pTombWind4@?1??SendToLog@@YA_NPADZZ@4PAKA DD 075385cH	; `SendToLog'::`2'::pTombWind4
?pTombWind4@?1??LogOnDebug@@YA_NPADZZ@4PAKA DD 075385cH	; `LogOnDebug'::`2'::pTombWind4
?pTombWind4@?1??MyMessageBox@@YAXPAD0@Z@4PAPAUHWND__@@A DD 075385cH ; `MyMessageBox'::`2'::pTombWind4
?pTombWind4@?1??TryMessageBox@@YA_NPAD@Z@4PAKA DD 075385cH ; `TryMessageBox'::`2'::pTombWind4
?p2IndiciStringheDat@?1??GetString@@YAPADH@Z@4PAPAGA DD 07fd154H ; `GetString'::`2'::p2IndiciStringheDat
?p2StringheScriptDat@?1??GetString@@YAPADH@Z@4PAPADA DD 07fd198H ; `GetString'::`2'::p2StringheScriptDat
?MexNotFound@?1??GetString@@YAPADH@Z@4PADA DB 'STRING NOT FOUND', 00H ; `GetString'::`2'::MexNotFound
_DATA	ENDS
PUBLIC	?InitialiseEnums@@YAXXZ				; InitialiseEnums
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\trng.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?InitialiseEnums@@YAXXZ
_TEXT	SEGMENT
?InitialiseEnums@@YAXXZ PROC				; InitialiseEnums, COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 159  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumD3D----------------------
; 160  : 	enumD3D.NO_LIGHT = D3D_NO_LIGHT;

  0001e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?enumD3D@@3UStrEnumD3D@@A, -1

; 161  : 	enumD3D.SUN = D3D_SUN;

  00028	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumD3D@@3UStrEnumD3D@@A+4, 0

; 162  : 	enumD3D.LIGHT = D3D_LIGHT;

  00032	c7 05 08 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumD3D@@3UStrEnumD3D@@A+8, 1

; 163  : 	enumD3D.SPOT_OR_EFFECT = D3D_SPOT_OR_EFFECT;

  0003c	c7 05 0c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumD3D@@3UStrEnumD3D@@A+12, 2

; 164  : 	enumD3D.SHADOW = D3D_SHADOW;

  00046	c7 05 10 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumD3D@@3UStrEnumD3D@@A+16, 3

; 165  : 	enumD3D.FOG_BULB = D3D_FOG_BULB;

  00050	c7 05 14 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumD3D@@3UStrEnumD3D@@A+20, 4

; 166  : 
; 167  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCOLF----------------------
; 168  : 	enumCOLF.WINDOWS_COLOR = COLF_WINDOWS_COLOR;

  0005a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumCOLF@@3UStrEnumCOLF@@A, 0

; 169  : 	enumCOLF.TOMB_COLOR = COLF_TOMB_COLOR;

  00064	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCOLF@@3UStrEnumCOLF@@A+4, 1

; 170  : 
; 171  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFIL----------------------
; 172  : 	enumFIL.FROM_SAVEGAME = FIL_FROM_SAVEGAME;

  0006e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFIL@@3UStrEnumFIL@@A, 1

; 173  : 	enumFIL.FROM_NEW_LEVEL = FIL_FROM_NEW_LEVEL;

  00078	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFIL@@3UStrEnumFIL@@A+4, 2

; 174  : 	enumFIL.FROM_LEVEL_JUMP = FIL_FROM_LEVEL_JUMP;

  00082	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFIL@@3UStrEnumFIL@@A+8, 4

; 175  : 	enumFIL.PRESERVE_LARA = FIL_PRESERVE_LARA;

  0008c	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFIL@@3UStrEnumFIL@@A+12, 8

; 176  : 	enumFIL.PRESERVE_LEVEL = FIL_PRESERVE_LEVEL;

  00096	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFIL@@3UStrEnumFIL@@A+16, 16 ; 00000010H

; 177  : 	enumFIL.FROM_LIKE_SAVEGAME = FIL_FROM_LIKE_SAVEGAME;

  000a0	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFIL@@3UStrEnumFIL@@A+20, 32 ; 00000020H

; 178  : 
; 179  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSAVT----------------------
; 180  : 	enumSAVT.LOCAL_DATA = SAVT_LOCAL_DATA;

  000aa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSAVT@@3UStrEnumSAVT@@A, 1

; 181  : 	enumSAVT.GLOBAL_DATA = SAVT_GLOBAL_DATA;

  000b4	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSAVT@@3UStrEnumSAVT@@A+4, 2

; 182  : 	enumSAVT.COMPLETED = SAVT_COMPLETED;

  000be	c7 05 08 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumSAVT@@3UStrEnumSAVT@@A+8, 2048 ; 00000800H

; 183  : 
; 184  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCONV----------------------
; 185  : 	enumCONV.ItemIndexFromNgleToTomb = CONV_ItemIndexFromNgleToTomb;

  000c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A, 1

; 186  : 	enumCONV.ItemIndexFromTombToNgle = CONV_ItemIndexFromTombToNgle;

  000d2	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+4, 2

; 187  : 	enumCONV.StaticIndexFromNgleToTomb = CONV_StaticIndexFromNgleToTomb;

  000dc	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+8, 3

; 188  : 	enumCONV.StaticIndexFromTombToNgle = CONV_StaticIndexFromTombToNgle;

  000e6	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+12, 4

; 189  : 	enumCONV.RectFromMicroUnitsToPixels = CONV_RectFromMicroUnitsToPixels;

  000f0	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+16, 5

; 190  : 	enumCONV.AnimIndexFromRelativeToAbs = CONV_AnimIndexFromRelativeToAbs;

  000fa	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+20, 6

; 191  : 	enumCONV.AnimIndexFromAbsToRelative = CONV_AnimIndexFromAbsToRelative;

  00104	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+24, 7

; 192  : 	enumCONV.ItemFromStrItemTr4ToIndex = CONV_ItemFromStrItemTr4ToIndex;

  0010e	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+28, 8

; 193  : 	enumCONV.RoomIndexFromNgleToTomb = CONV_RoomIndexFromNgleToTomb;

  00118	c7 05 20 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+32, 9

; 194  : 	enumCONV.RoomIndexFromTombToNgle = CONV_RoomIndexFromTombToNgle;

  00122	c7 05 24 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+36, 10 ; 0000000aH

; 195  : 	enumCONV.FrameIndexFromAbsToRelative = CONV_FrameIndexFromAbsToRelative;

  0012c	c7 05 28 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+40, 11 ; 0000000bH

; 196  : 	enumCONV.FrameIndexFromRelativeToAbs = CONV_FrameIndexFromRelativeToAbs;

  00136	c7 05 2c 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumCONV@@3UStrEnumCONV@@A+44, 12 ; 0000000cH

; 197  : 
; 198  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFL----------------------
; 199  : 	enumFL.HOLDS_FLARE_OR_TORCH = FL_HOLDS_FLARE_OR_TORCH;

  00140	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A, 1

; 200  : 	enumFL.UNKNOWN_02 = FL_UNKNOWN_02;

  0014a	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A+4, 2

; 201  : 	enumFL.SPECIAL_STATE = FL_SPECIAL_STATE;

  00154	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A+8, 4

; 202  : 	enumFL.IS_BURNING = FL_IS_BURNING;

  0015e	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A+12, 8

; 203  : 	enumFL.ON_ALL_FOUR = FL_ON_ALL_FOUR;

  00168	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A+16, 16 ; 00000010H

; 204  : 	enumFL.SELF_ALIGNMENT = FL_SELF_ALIGNMENT;

  00172	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A+20, 32 ; 00000020H

; 205  : 	enumFL.UNDER_MONKEY_SECTOR = FL_UNDER_MONKEY_SECTOR;

  0017c	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFL@@3UStrEnumFL@@A+24, 64 ; 00000040H

; 206  : 
; 207  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumRIB----------------------
; 208  : 	enumRIB.ONLY_DIGITS = RIB_ONLY_DIGITS;

  00186	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A, 1

; 209  : 	enumRIB.ONLY_LETTERS = RIB_ONLY_LETTERS;

  00190	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+4, 2

; 210  : 	enumRIB.HIDE_CARET = RIB_HIDE_CARET;

  0019a	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+8, 4

; 211  : 	enumRIB.BLINK_CARET = RIB_BLINK_CARET;

  001a4	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+12, 8

; 212  : 	enumRIB.SOUND_ON_KEY = RIB_SOUND_ON_KEY;

  001ae	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+16, 16 ; 00000010H

; 213  : 	enumRIB.PRINT_ONLY = RIB_PRINT_ONLY;

  001b8	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+20, 32 ; 00000020H

; 214  : 	enumRIB.ALIGN_CENTER = RIB_ALIGN_CENTER;

  001c2	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+24, 64 ; 00000040H

; 215  : 	enumRIB.ONLY_CAPS = RIB_ONLY_CAPS;

  001cc	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+28, 128 ; 00000080H

; 216  : 	enumRIB.PRINT_BIG_TEXT = RIB_PRINT_BIG_TEXT;

  001d6	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+32, 256 ; 00000100H

; 217  : 	enumRIB.INPUT_BELOW_BIG_TEXT = RIB_INPUT_BELOW_BIG_TEXT;

  001e0	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+36, 512 ; 00000200H

; 218  : 	enumRIB.ADD_SCANCODE_LIST = RIB_ADD_SCANCODE_LIST;

  001ea	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+40, 1024 ; 00000400H

; 219  : 	enumRIB.SHORTCUT_KEY = RIB_SHORTCUT_KEY;

  001f4	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+44, 2048 ; 00000800H

; 220  : 	enumRIB.HIDE_TEXT = RIB_HIDE_TEXT;

  001fe	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumRIB@@3UStrEnumRIB@@A+48, 4096 ; 00001000H

; 221  : 
; 222  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumWTF----------------------
; 223  : 	enumWTF.FLYING_TEXT = WTF_FLYING_TEXT;

  00208	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A, 1

; 224  : 	enumWTF.PULSING_TEXT = WTF_PULSING_TEXT;

  00212	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+4, 2

; 225  : 	enumWTF.CHANGE_COLOR = WTF_CHANGE_COLOR;

  0021c	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+8, 4

; 226  : 	enumWTF.OVER_INVENTORY = WTF_OVER_INVENTORY;

  00226	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+12, 8

; 227  : 	enumWTF.OVER_IMAGE = WTF_OVER_IMAGE;

  00230	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+16, 16 ; 00000010H

; 228  : 	enumWTF.OVER_FLYCAMERA = WTF_OVER_FLYCAMERA;

  0023a	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+20, 32 ; 00000020H

; 229  : 	enumWTF.OVER_FIXCAMERA = WTF_OVER_FIXCAMERA;

  00244	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+24, 64 ; 00000040H

; 230  : 	enumWTF.OVER_BINOCULAR = WTF_OVER_BINOCULAR;

  0024e	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+28, 128 ; 00000080H

; 231  : 	enumWTF.OVER_LASER_SIGHT = WTF_OVER_LASER_SIGHT;

  00258	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumWTF@@3UStrEnumWTF@@A+32, 256 ; 00000100H

; 232  : 
; 233  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFT----------------------
; 234  : 	enumFT.HALF_SIZEX = FT_HALF_SIZEX;

  00262	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A, 1

; 235  : 	enumFT.HALF_SIZEY = FT_HALF_SIZEY;

  0026c	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+4, 2

; 236  : 	enumFT.DOUBLE_SIZEX = FT_DOUBLE_SIZEX;

  00276	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+8, 4

; 237  : 	enumFT.DOUBLE_SIZEY = FT_DOUBLE_SIZEY;

  00280	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+12, 8

; 238  : 	enumFT.LITTLE_ALWAYS = FT_LITTLE_ALWAYS;

  0028a	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+16, 16 ; 00000010H

; 239  : 	enumFT.USE_FLOAT = FT_USE_FLOAT;

  00294	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+20, 32 ; 00000020H

; 240  : 	enumFT.NO_BORDERS = FT_NO_BORDERS;

  0029e	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+24, 64 ; 00000040H

; 241  : 	enumFT.SIZE_ATOMIC_CHAR = FT_SIZE_ATOMIC_CHAR;

  002a8	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumFT@@3UStrEnumFT@@A+28, 128 ; 00000080H

; 242  : 
; 243  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFTS----------------------
; 244  : 	enumFTS.ALIGN_LEFT = FTS_ALIGN_LEFT;

  002b2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumFTS@@3UStrEnumFTS@@A, 0

; 245  : 	enumFTS.STRETCH_TEXT = FTS_STRETCH_TEXT;

  002bc	c7 05 04 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumFTS@@3UStrEnumFTS@@A+4, 4096 ; 00001000H

; 246  : 	enumFTS.BLINK = FTS_BLINK;

  002c6	c7 05 08 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumFTS@@3UStrEnumFTS@@A+8, 8192 ; 00002000H

; 247  : 	enumFTS.ALIGN_RIGHT = FTS_ALIGN_RIGHT;

  002d0	c7 05 0c 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumFTS@@3UStrEnumFTS@@A+12, 16384 ; 00004000H

; 248  : 	enumFTS.ALIGN_CENTER = FTS_ALIGN_CENTER;

  002da	c7 05 10 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumFTS@@3UStrEnumFTS@@A+16, 32768 ; 00008000H

; 249  : 
; 250  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFC----------------------
; 251  : 	enumFC.WHITE_PULSE = FC_WHITE_PULSE;

  002e4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A, 1

; 252  : 	enumFC.WHITE = FC_WHITE;

  002ee	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+4, 2

; 253  : 	enumFC.RED = FC_RED;

  002f8	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+8, 3

; 254  : 	enumFC.BLUE = FC_BLUE;

  00302	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+12, 4

; 255  : 	enumFC.LIGHT_GRAY = FC_LIGHT_GRAY;

  0030c	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+16, 5

; 256  : 	enumFC.GOLD = FC_GOLD;

  00316	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+20, 6

; 257  : 	enumFC.DARK_GRAY = FC_DARK_GRAY;

  00320	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+24, 7

; 258  : 	enumFC.YELLOW = FC_YELLOW;

  0032a	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFC@@3UStrEnumFC@@A+28, 8

; 259  : 
; 260  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumPRET----------------------
; 261  : 	enumPRET.OK = PRET_OK;

  00334	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumPRET@@3UStrEnumPRET@@A, 0

; 262  : 	enumPRET.GO_TO_TITLE = PRET_GO_TO_TITLE;

  0033e	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumPRET@@3UStrEnumPRET@@A+4, 1

; 263  : 	enumPRET.EXECUTE_ORIGINAL = PRET_EXECUTE_ORIGINAL;

  00348	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumPRET@@3UStrEnumPRET@@A+8, 2

; 264  : 
; 265  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumPHASE----------------------
; 266  : 	enumPHASE.INVENTORY_MAIN = PHASE_INVENTORY_MAIN;

  00352	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A, 1

; 267  : 	enumPHASE.PAUSE_SCREEN = PHASE_PAUSE_SCREEN;

  0035c	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+4, 2

; 268  : 	enumPHASE.LOAD_GAME_PANEL = PHASE_LOAD_GAME_PANEL;

  00366	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+8, 3

; 269  : 	enumPHASE.SAVE_GAME_PANEL = PHASE_SAVE_GAME_PANEL;

  00370	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+12, 4

; 270  : 	enumPHASE.OPTIONS = PHASE_OPTIONS;

  0037a	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+16, 5

; 271  : 	enumPHASE.OPTION_COMMANDS = PHASE_OPTION_COMMANDS;

  00384	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+20, 6

; 272  : 	enumPHASE.STATISTICS = PHASE_STATISTICS;

  0038e	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+24, 7

; 273  : 	enumPHASE.NEW_LEVEL = PHASE_NEW_LEVEL;

  00398	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+28, 8

; 274  : 	enumPHASE.TITLE_MENU = PHASE_TITLE_MENU;

  003a2	c7 05 20 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+32, 9

; 275  : 	enumPHASE.INVENTORY_EXAMINE = PHASE_INVENTORY_EXAMINE;

  003ac	c7 05 24 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumPHASE@@3UStrEnumPHASE@@A+36, 10 ; 0000000aH

; 276  : 
; 277  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumIRET----------------------
; 278  : 	enumIRET.OK = IRET_OK;

  003b6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumIRET@@3UStrEnumIRET@@A, 0

; 279  : 	enumIRET.SKIP_ORIGINAL = IRET_SKIP_ORIGINAL;

  003c0	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumIRET@@3UStrEnumIRET@@A+4, 1

; 280  : 	enumIRET.LOADED_GAME = IRET_LOADED_GAME;

  003ca	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumIRET@@3UStrEnumIRET@@A+8, 2

; 281  : 
; 282  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCPU----------------------
; 283  : 	enumCPU.CARRY = CPU_CARRY;

  003d4	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCPU@@3UStrEnumCPU@@A, 1

; 284  : 	enumCPU.PARITY = CPU_PARITY;

  003de	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCPU@@3UStrEnumCPU@@A+4, 4

; 285  : 	enumCPU.ZERO = CPU_ZERO;

  003e8	c7 05 08 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumCPU@@3UStrEnumCPU@@A+8, 64 ; 00000040H

; 286  : 	enumCPU.SIGN = CPU_SIGN;

  003f2	c7 05 0c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumCPU@@3UStrEnumCPU@@A+12, 128 ; 00000080H

; 287  : 
; 288  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumAPPC----------------------
; 289  : 	enumAPPC.OK = APPC_OK;

  003fc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A, 0

; 290  : 	enumAPPC.WARN_PATCH_ALREADY_PERFORMED = APPC_WARN_PATCH_ALREADY_PERFORMED;

  00406	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+4, 1

; 291  : 	enumAPPC.WARN_PLUGIN_REMOVED_RELOCATION_OF_PROCEDURE = APPC_WARN_PLUGIN_REMOVED_RELOCATION_OF_PROCEDURE;

  00410	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+8, 2

; 292  : 	enumAPPC.WARN_PATCH_IN_A_RILOC_RESTORED_PROCEDURE = APPC_WARN_PATCH_IN_A_RILOC_RESTORED_PROCEDURE;

  0041a	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+12, 3

; 293  : 	enumAPPC.WARN_PATCH_OVER_OLD_PATCH = APPC_WARN_PATCH_OVER_OLD_PATCH;

  00424	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+16, 4

; 294  : 	enumAPPC.WARN_PATCH_OVER_CHANGED_ARGUMENTS = APPC_WARN_PATCH_OVER_CHANGED_ARGUMENTS;

  0042e	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+20, 5

; 295  : 	enumAPPC.ERROR_PLUGIN_ID_UNREGISTERED = APPC_ERROR_PLUGIN_ID_UNREGISTERED;

  00438	c7 05 18 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+24, -1

; 296  : 	enumAPPC.ERROR_PATCH_OVERLAPPED_TO_RUNTIME_PATCH = APPC_ERROR_PATCH_OVERLAPPED_TO_RUNTIME_PATCH;

  00442	c7 05 1c 00 00
	00 fe ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+28, -2 ; fffffffeH

; 297  : 	enumAPPC.ERROR_PATCH_IN_RILOCATED_PROCEDURE = APPC_ERROR_PATCH_IN_RILOCATED_PROCEDURE;

  0044c	c7 05 20 00 00
	00 fd ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+32, -3 ; fffffffdH

; 298  : 	enumAPPC.ERROR_NOT_FOUND_TOMB4_IMAGE = APPC_ERROR_NOT_FOUND_TOMB4_IMAGE;

  00456	c7 05 24 00 00
	00 fc ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+36, -4 ; fffffffcH

; 299  : 	enumAPPC.ERROR_RESTORE_ZONE_OUTSIDE_CODE_RANGE = APPC_ERROR_RESTORE_ZONE_OUTSIDE_CODE_RANGE;

  00460	c7 05 28 00 00
	00 fb ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+40, -5 ; fffffffbH

; 300  : 	enumAPPC.ERROR_WRONG_PATCH_FOR_RUN_TIME = APPC_ERROR_WRONG_PATCH_FOR_RUN_TIME;

  0046a	c7 05 2c 00 00
	00 fa ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+44, -6 ; fffffffaH

; 301  : 	enumAPPC.ERROR_PATCH_OUTSIDE_CODE_SEGMENT = APPC_ERROR_PATCH_OUTSIDE_CODE_SEGMENT;

  00474	c7 05 30 00 00
	00 f9 ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+48, -7 ; fffffff9H

; 302  : 	enumAPPC.ERROR_PATCH_OVERLAPPED_TO_RESERVED_ZONE = APPC_ERROR_PATCH_OVERLAPPED_TO_RESERVED_ZONE;

  0047e	c7 05 34 00 00
	00 f8 ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+52, -8 ; fffffff8H

; 303  : 	enumAPPC.ERROR_RESERVED_ZONE_ALREADY_USED = APPC_ERROR_RESERVED_ZONE_ALREADY_USED;

  00488	c7 05 38 00 00
	00 f7 ff ff ff	 mov	 DWORD PTR ?enumAPPC@@3UStrEnumAPPC@@A+56, -9 ; fffffff7H

; 304  : 
; 305  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCB----------------------
; 306  : 	enumCB.INIT_PROGRAM = CB_INIT_PROGRAM;

  00492	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A, 0

; 307  : 	enumCB.SAVING_GAME = CB_SAVING_GAME;

  0049c	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+4, 1

; 308  : 	enumCB.LOADING_GAME = CB_LOADING_GAME;

  004a6	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+8, 2

; 309  : 	enumCB.INIT_GAME = CB_INIT_GAME;

  004b0	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+12, 3

; 310  : 	enumCB.INIT_LOAD_NEW_LEVEL = CB_INIT_LOAD_NEW_LEVEL;

  004ba	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+16, 4

; 311  : 	enumCB.FLIPEFFECT_MINE = CB_FLIPEFFECT_MINE;

  004c4	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+20, 5

; 312  : 	enumCB.ACTION_MINE = CB_ACTION_MINE;

  004ce	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+24, 6

; 313  : 	enumCB.CONDITION_MINE = CB_CONDITION_MINE;

  004d8	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+28, 7

; 314  : 	enumCB.CUSTOMIZE_MINE = CB_CUSTOMIZE_MINE;

  004e2	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+32, 8

; 315  : 	enumCB.PARAMETER_MINE = CB_PARAMETER_MINE;

  004ec	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+36, 9

; 316  : 	enumCB.CYCLE_BEGIN = CB_CYCLE_BEGIN;

  004f6	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+40, 10 ; 0000000aH

; 317  : 	enumCB.CYCLE_END = CB_CYCLE_END;

  00500	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+44, 11 ; 0000000bH

; 318  : 	enumCB.GLOBAL_TRIGGER = CB_GLOBAL_TRIGGER;

  0050a	c7 05 30 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+48, 12 ; 0000000cH

; 319  : 	enumCB.INIT_OBJECTS = CB_INIT_OBJECTS;

  00514	c7 05 34 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+52, 13 ; 0000000dH

; 320  : 	enumCB.PROGR_ACTION_MINE = CB_PROGR_ACTION_MINE;

  0051e	c7 05 38 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+56, 14 ; 0000000eH

; 321  : 	enumCB.PROGR_ACTION_DRAW_MINE = CB_PROGR_ACTION_DRAW_MINE;

  00528	c7 05 3c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+60, 15 ; 0000000fH

; 322  : 	enumCB.INIT_LEVEL = CB_INIT_LEVEL;

  00532	c7 05 40 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+64, 16 ; 00000010H

; 323  : 	enumCB.COMPLETED_PROGR_ACTION = CB_COMPLETED_PROGR_ACTION;

  0053c	c7 05 44 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+68, 17 ; 00000011H

; 324  : 	enumCB.VEHICLE = CB_VEHICLE;

  00546	c7 05 48 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+72, 18 ; 00000012H

; 325  : 	enumCB.ASSIGN_SLOT_MINE = CB_ASSIGN_SLOT_MINE;

  00550	c7 05 4c 00 00
	00 13 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+76, 19 ; 00000013H

; 326  : 	enumCB.FMV_MANAGER = CB_FMV_MANAGER;

  0055a	c7 05 50 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+80, 20 ; 00000014H

; 327  : 	enumCB.INPUT_MANAGER = CB_INPUT_MANAGER;

  00564	c7 05 54 00 00
	00 15 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+84, 21 ; 00000015H

; 328  : 	enumCB.SAVEGAME_MANAGER = CB_SAVEGAME_MANAGER;

  0056e	c7 05 58 00 00
	00 16 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+88, 22 ; 00000016H

; 329  : 	enumCB.PAUSE_MANAGER = CB_PAUSE_MANAGER;

  00578	c7 05 5c 00 00
	00 17 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+92, 23 ; 00000017H

; 330  : 	enumCB.STATISTICS_MANAGER = CB_STATISTICS_MANAGER;

  00582	c7 05 60 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+96, 24 ; 00000018H

; 331  : 	enumCB.TITLE_MENU_MANAGER = CB_TITLE_MENU_MANAGER;

  0058c	c7 05 64 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+100, 25 ; 00000019H

; 332  : 	enumCB.WINDOWS_FONT_CREATE = CB_WINDOWS_FONT_CREATE;

  00596	c7 05 68 00 00
	00 1a 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+104, 26 ; 0000001aH

; 333  : 	enumCB.WINDOWS_UNICODE_CONVERT = CB_WINDOWS_UNICODE_CONVERT;

  005a0	c7 05 6c 00 00
	00 1b 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+108, 27 ; 0000001bH

; 334  : 	enumCB.WINDOWS_TEXT_PRINT = CB_WINDOWS_TEXT_PRINT;

  005aa	c7 05 70 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+112, 28 ; 0000001cH

; 335  : 	enumCB.DIAGNOSTIC = CB_DIAGNOSTIC;

  005b4	c7 05 74 00 00
	00 1d 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+116, 29 ; 0000001dH

; 336  : 	enumCB.LARA_CONTROL = CB_LARA_CONTROL;

  005be	c7 05 78 00 00
	00 21 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+120, 33 ; 00000021H

; 337  : 	enumCB.LARA_DRAW = CB_LARA_DRAW;

  005c8	c7 05 7c 00 00
	00 22 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+124, 34 ; 00000022H

; 338  : 	enumCB.LARA_HAIR_DRAW = CB_LARA_HAIR_DRAW;

  005d2	c7 05 80 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+128, 35 ; 00000023H

; 339  : 	enumCB.LARA_HAIR_CONTROL = CB_LARA_HAIR_CONTROL;

  005dc	c7 05 84 00 00
	00 24 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+132, 36 ; 00000024H

; 340  : 	enumCB.INVENTORY_MAIN = CB_INVENTORY_MAIN;

  005e6	c7 05 88 00 00
	00 25 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+136, 37 ; 00000025H

; 341  : 	enumCB.INVENT_BACKGROUND_CREATE = CB_INVENT_BACKGROUND_CREATE;

  005f0	c7 05 8c 00 00
	00 26 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+140, 38 ; 00000026H

; 342  : 	enumCB.INVENT_BACKGROUND_DRAW = CB_INVENT_BACKGROUND_DRAW;

  005fa	c7 05 90 00 00
	00 27 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+144, 39 ; 00000027H

; 343  : 	enumCB.INVENT_BACKGROUND_QUIT = CB_INVENT_BACKGROUND_QUIT;

  00604	c7 05 94 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+148, 40 ; 00000028H

; 344  : 	enumCB.ANIMATE_LARA = CB_ANIMATE_LARA;

  0060e	c7 05 98 00 00
	00 29 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+152, 41 ; 00000029H

; 345  : 	enumCB.OPTIONS_MANAGER = CB_OPTIONS_MANAGER;

  00618	c7 05 9c 00 00
	00 2a 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+156, 42 ; 0000002aH

; 346  : 	enumCB.FLIPEFFECT = CB_FLIPEFFECT;

  00622	c7 05 a0 00 00
	00 64 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+160, 100 ; 00000064H

; 347  : 	enumCB.ACTION = CB_ACTION;

  0062c	c7 05 a4 00 00
	00 65 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+164, 101 ; 00000065H

; 348  : 	enumCB.CONDITION = CB_CONDITION;

  00636	c7 05 a8 00 00
	00 66 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+168, 102 ; 00000066H

; 349  : 	enumCB.VEHICLE_CONTROL = CB_VEHICLE_CONTROL;

  00640	c7 05 ac 00 00
	00 67 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+172, 103 ; 00000067H

; 350  : 	enumCB.PROGR_ACTION = CB_PROGR_ACTION;

  0064a	c7 05 b0 00 00
	00 69 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+176, 105 ; 00000069H

; 351  : 	enumCB.NUMERIC_TRNG_PATCH = CB_NUMERIC_TRNG_PATCH;

  00654	c7 05 b4 00 00
	00 6a 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+180, 106 ; 0000006aH

; 352  : 	enumCB.SLOT_INITIALISE = CB_SLOT_INITIALISE;

  0065e	c7 05 b8 00 00
	00 6b 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+184, 107 ; 0000006bH

; 353  : 	enumCB.SLOT_CONTROL = CB_SLOT_CONTROL;

  00668	c7 05 bc 00 00
	00 6c 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+188, 108 ; 0000006cH

; 354  : 	enumCB.SLOT_COLLISION = CB_SLOT_COLLISION;

  00672	c7 05 c0 00 00
	00 6d 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+192, 109 ; 0000006dH

; 355  : 	enumCB.SLOT_DRAW = CB_SLOT_DRAW;

  0067c	c7 05 c4 00 00
	00 6e 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+196, 110 ; 0000006eH

; 356  : 	enumCB.SLOT_FLOOR = CB_SLOT_FLOOR;

  00686	c7 05 c8 00 00
	00 6f 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+200, 111 ; 0000006fH

; 357  : 	enumCB.SLOT_CEILING = CB_SLOT_CEILING;

  00690	c7 05 cc 00 00
	00 70 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+204, 112 ; 00000070H

; 358  : 	enumCB.SLOT_DRAW_EXTRA = CB_SLOT_DRAW_EXTRA;

  0069a	c7 05 d0 00 00
	00 71 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+208, 113 ; 00000071H

; 359  : 	enumCB.STATE_ID_LARA_CTRL = CB_STATE_ID_LARA_CTRL;

  006a4	c7 05 d4 00 00
	00 72 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+212, 114 ; 00000072H

; 360  : 	enumCB.STATE_ID_LARA_COLLISION = CB_STATE_ID_LARA_COLLISION;

  006ae	c7 05 d8 00 00
	00 73 00 00 00	 mov	 DWORD PTR ?enumCB@@3UStrEnumCB@@A+216, 115 ; 00000073H

; 361  : 
; 362  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSLOT----------------------
; 363  : 	enumSLOT.LARA = SLOT_LARA;

  006b8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A, 0

; 364  : 	enumSLOT.PISTOLS_ANIM = SLOT_PISTOLS_ANIM;

  006c2	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+4, 1

; 365  : 	enumSLOT.UZI_ANIM = SLOT_UZI_ANIM;

  006cc	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+8, 2

; 366  : 	enumSLOT.SHOTGUN_ANIM = SLOT_SHOTGUN_ANIM;

  006d6	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+12, 3

; 367  : 	enumSLOT.CROSSBOW_ANIM = SLOT_CROSSBOW_ANIM;

  006e0	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+16, 4

; 368  : 	enumSLOT.GRENADE_GUN_ANIM = SLOT_GRENADE_GUN_ANIM;

  006ea	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+20, 5

; 369  : 	enumSLOT.SIXSHOOTER_ANIM = SLOT_SIXSHOOTER_ANIM;

  006f4	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+24, 6

; 370  : 	enumSLOT.FLARE_ANIM = SLOT_FLARE_ANIM;

  006fe	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+28, 7

; 371  : 	enumSLOT.LARA_SKIN = SLOT_LARA_SKIN;

  00708	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+32, 8

; 372  : 	enumSLOT.LARA_SKIN_JOINTS = SLOT_LARA_SKIN_JOINTS;

  00712	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+36, 9

; 373  : 	enumSLOT.LARA_SCREAM = SLOT_LARA_SCREAM;

  0071c	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+40, 10 ; 0000000aH

; 374  : 	enumSLOT.LARA_CROSSBOW_LASER = SLOT_LARA_CROSSBOW_LASER;

  00726	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+44, 11 ; 0000000bH

; 375  : 	enumSLOT.LARA_REVOLVER_LASER = SLOT_LARA_REVOLVER_LASER;

  00730	c7 05 30 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+48, 12 ; 0000000cH

; 376  : 	enumSLOT.LARA_HOLSTERS = SLOT_LARA_HOLSTERS;

  0073a	c7 05 34 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+52, 13 ; 0000000dH

; 377  : 	enumSLOT.LARA_HOLSTERS_PISTOLS = SLOT_LARA_HOLSTERS_PISTOLS;

  00744	c7 05 38 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+56, 14 ; 0000000eH

; 378  : 	enumSLOT.LARA_HOLSTERS_UZIS = SLOT_LARA_HOLSTERS_UZIS;

  0074e	c7 05 3c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+60, 15 ; 0000000fH

; 379  : 	enumSLOT.LARA_HOLSTERS_SIXSHOOTER = SLOT_LARA_HOLSTERS_SIXSHOOTER;

  00758	c7 05 40 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+64, 16 ; 00000010H

; 380  : 	enumSLOT.LARA_SPEECH_HEAD1 = SLOT_LARA_SPEECH_HEAD1;

  00762	c7 05 44 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+68, 17 ; 00000011H

; 381  : 	enumSLOT.LARA_SPEECH_HEAD2 = SLOT_LARA_SPEECH_HEAD2;

  0076c	c7 05 48 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+72, 18 ; 00000012H

; 382  : 	enumSLOT.LARA_SPEECH_HEAD3 = SLOT_LARA_SPEECH_HEAD3;

  00776	c7 05 4c 00 00
	00 13 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+76, 19 ; 00000013H

; 383  : 	enumSLOT.LARA_SPEECH_HEAD4 = SLOT_LARA_SPEECH_HEAD4;

  00780	c7 05 50 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+80, 20 ; 00000014H

; 384  : 	enumSLOT.ACTOR1_SPEECH_HEAD1 = SLOT_ACTOR1_SPEECH_HEAD1;

  0078a	c7 05 54 00 00
	00 15 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+84, 21 ; 00000015H

; 385  : 	enumSLOT.ACTOR1_SPEECH_HEAD2 = SLOT_ACTOR1_SPEECH_HEAD2;

  00794	c7 05 58 00 00
	00 16 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+88, 22 ; 00000016H

; 386  : 	enumSLOT.ACTOR2_SPEECH_HEAD1 = SLOT_ACTOR2_SPEECH_HEAD1;

  0079e	c7 05 5c 00 00
	00 17 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+92, 23 ; 00000017H

; 387  : 	enumSLOT.ACTOR2_SPEECH_HEAD2 = SLOT_ACTOR2_SPEECH_HEAD2;

  007a8	c7 05 60 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+96, 24 ; 00000018H

; 388  : 	enumSLOT.LARA_WATER_MESH = SLOT_LARA_WATER_MESH;

  007b2	c7 05 64 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+100, 25 ; 00000019H

; 389  : 	enumSLOT.LARA_PETROL_MESH = SLOT_LARA_PETROL_MESH;

  007bc	c7 05 68 00 00
	00 1a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+104, 26 ; 0000001aH

; 390  : 	enumSLOT.LARA_DIRT_MESH = SLOT_LARA_DIRT_MESH;

  007c6	c7 05 6c 00 00
	00 1b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+108, 27 ; 0000001bH

; 391  : 	enumSLOT.CROWBAR_ANIM = SLOT_CROWBAR_ANIM;

  007d0	c7 05 70 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+112, 28 ; 0000001cH

; 392  : 	enumSLOT.TORCH_ANIM = SLOT_TORCH_ANIM;

  007da	c7 05 74 00 00
	00 1d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+116, 29 ; 0000001dH

; 393  : 	enumSLOT.HAIR = SLOT_HAIR;

  007e4	c7 05 78 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+120, 30 ; 0000001eH

; 394  : 	enumSLOT.MOTORBIKE = SLOT_MOTORBIKE;

  007ee	c7 05 7c 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+124, 31 ; 0000001fH

; 395  : 	enumSLOT.JEEP = SLOT_JEEP;

  007f8	c7 05 80 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+128, 32 ; 00000020H

; 396  : 	enumSLOT.VEHICLE_EXTRA = SLOT_VEHICLE_EXTRA;

  00802	c7 05 84 00 00
	00 21 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+132, 33 ; 00000021H

; 397  : 	enumSLOT.ENEMY_JEEP = SLOT_ENEMY_JEEP;

  0080c	c7 05 88 00 00
	00 22 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+136, 34 ; 00000022H

; 398  : 	enumSLOT.SKELETON = SLOT_SKELETON;

  00816	c7 05 8c 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+140, 35 ; 00000023H

; 399  : 	enumSLOT.SKELETON_MIP = SLOT_SKELETON_MIP;

  00820	c7 05 90 00 00
	00 24 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+144, 36 ; 00000024H

; 400  : 	enumSLOT.GUIDE = SLOT_GUIDE;

  0082a	c7 05 94 00 00
	00 25 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+148, 37 ; 00000025H

; 401  : 	enumSLOT.GUIDE_MIP = SLOT_GUIDE_MIP;

  00834	c7 05 98 00 00
	00 26 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+152, 38 ; 00000026H

; 402  : 	enumSLOT.VON_CROY = SLOT_VON_CROY;

  0083e	c7 05 9c 00 00
	00 27 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+156, 39 ; 00000027H

; 403  : 	enumSLOT.VON_CROY_MIP = SLOT_VON_CROY_MIP;

  00848	c7 05 a0 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+160, 40 ; 00000028H

; 404  : 	enumSLOT.BADDY_1 = SLOT_BADDY_1;

  00852	c7 05 a4 00 00
	00 29 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+164, 41 ; 00000029H

; 405  : 	enumSLOT.BADDY_1_MIP = SLOT_BADDY_1_MIP;

  0085c	c7 05 a8 00 00
	00 2a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+168, 42 ; 0000002aH

; 406  : 	enumSLOT.BADDY_2 = SLOT_BADDY_2;

  00866	c7 05 ac 00 00
	00 2b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+172, 43 ; 0000002bH

; 407  : 	enumSLOT.BADDY_2_MIP = SLOT_BADDY_2_MIP;

  00870	c7 05 b0 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+176, 44 ; 0000002cH

; 408  : 	enumSLOT.SETHA = SLOT_SETHA;

  0087a	c7 05 b4 00 00
	00 2d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+180, 45 ; 0000002dH

; 409  : 	enumSLOT.SETHA_MIP = SLOT_SETHA_MIP;

  00884	c7 05 b8 00 00
	00 2e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+184, 46 ; 0000002eH

; 410  : 	enumSLOT.MUMMY = SLOT_MUMMY;

  0088e	c7 05 bc 00 00
	00 2f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+188, 47 ; 0000002fH

; 411  : 	enumSLOT.MUMMY_MIP = SLOT_MUMMY_MIP;

  00898	c7 05 c0 00 00
	00 30 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+192, 48 ; 00000030H

; 412  : 	enumSLOT.SPHINX = SLOT_SPHINX;

  008a2	c7 05 c4 00 00
	00 31 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+196, 49 ; 00000031H

; 413  : 	enumSLOT.SPHINX_MIP = SLOT_SPHINX_MIP;

  008ac	c7 05 c8 00 00
	00 32 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+200, 50 ; 00000032H

; 414  : 	enumSLOT.CROCODILE = SLOT_CROCODILE;

  008b6	c7 05 cc 00 00
	00 33 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+204, 51 ; 00000033H

; 415  : 	enumSLOT.CROCODILE_MIP = SLOT_CROCODILE_MIP;

  008c0	c7 05 d0 00 00
	00 34 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+208, 52 ; 00000034H

; 416  : 	enumSLOT.HORSEMAN = SLOT_HORSEMAN;

  008ca	c7 05 d4 00 00
	00 35 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+212, 53 ; 00000035H

; 417  : 	enumSLOT.HORSEMAN_MIP = SLOT_HORSEMAN_MIP;

  008d4	c7 05 d8 00 00
	00 36 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+216, 54 ; 00000036H

; 418  : 	enumSLOT.SCORPION = SLOT_SCORPION;

  008de	c7 05 dc 00 00
	00 37 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+220, 55 ; 00000037H

; 419  : 	enumSLOT.SCORPION_MIP = SLOT_SCORPION_MIP;

  008e8	c7 05 e0 00 00
	00 38 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+224, 56 ; 00000038H

; 420  : 	enumSLOT.JEAN_YVES = SLOT_JEAN_YVES;

  008f2	c7 05 e4 00 00
	00 39 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+228, 57 ; 00000039H

; 421  : 	enumSLOT.JEAN_YVES_MIP = SLOT_JEAN_YVES_MIP;

  008fc	c7 05 e8 00 00
	00 3a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+232, 58 ; 0000003aH

; 422  : 	enumSLOT.TROOPS = SLOT_TROOPS;

  00906	c7 05 ec 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+236, 59 ; 0000003bH

; 423  : 	enumSLOT.TROOPS_MIP = SLOT_TROOPS_MIP;

  00910	c7 05 f0 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+240, 60 ; 0000003cH

; 424  : 	enumSLOT.KNIGHTS_TEMPLAR = SLOT_KNIGHTS_TEMPLAR;

  0091a	c7 05 f4 00 00
	00 3d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+244, 61 ; 0000003dH

; 425  : 	enumSLOT.KNIGHTS_TEMPLAR_MIP = SLOT_KNIGHTS_TEMPLAR_MIP;

  00924	c7 05 f8 00 00
	00 3e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+248, 62 ; 0000003eH

; 426  : 	enumSLOT.MUTANT = SLOT_MUTANT;

  0092e	c7 05 fc 00 00
	00 3f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+252, 63 ; 0000003fH

; 427  : 	enumSLOT.MUTANT_MIP = SLOT_MUTANT_MIP;

  00938	c7 05 00 01 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+256, 64 ; 00000040H

; 428  : 	enumSLOT.HORSE = SLOT_HORSE;

  00942	c7 05 04 01 00
	00 41 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+260, 65 ; 00000041H

; 429  : 	enumSLOT.HORSE_MIP = SLOT_HORSE_MIP;

  0094c	c7 05 08 01 00
	00 42 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+264, 66 ; 00000042H

; 430  : 	enumSLOT.BABOON_NORMAL = SLOT_BABOON_NORMAL;

  00956	c7 05 0c 01 00
	00 43 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+268, 67 ; 00000043H

; 431  : 	enumSLOT.BABOON_NORMAL_MIP = SLOT_BABOON_NORMAL_MIP;

  00960	c7 05 10 01 00
	00 44 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+272, 68 ; 00000044H

; 432  : 	enumSLOT.BABOON_INV = SLOT_BABOON_INV;

  0096a	c7 05 14 01 00
	00 45 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+276, 69 ; 00000045H

; 433  : 	enumSLOT.BABOON_INV_MIP = SLOT_BABOON_INV_MIP;

  00974	c7 05 18 01 00
	00 46 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+280, 70 ; 00000046H

; 434  : 	enumSLOT.BABOON_SILENT = SLOT_BABOON_SILENT;

  0097e	c7 05 1c 01 00
	00 47 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+284, 71 ; 00000047H

; 435  : 	enumSLOT.BABOON_SILENT_MIP = SLOT_BABOON_SILENT_MIP;

  00988	c7 05 20 01 00
	00 48 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+288, 72 ; 00000048H

; 436  : 	enumSLOT.WILD_BOAR = SLOT_WILD_BOAR;

  00992	c7 05 24 01 00
	00 49 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+292, 73 ; 00000049H

; 437  : 	enumSLOT.WILD_BOAR_MIP = SLOT_WILD_BOAR_MIP;

  0099c	c7 05 28 01 00
	00 4a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+296, 74 ; 0000004aH

; 438  : 	enumSLOT.HARPY = SLOT_HARPY;

  009a6	c7 05 2c 01 00
	00 4b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+300, 75 ; 0000004bH

; 439  : 	enumSLOT.HARPY_MIP = SLOT_HARPY_MIP;

  009b0	c7 05 30 01 00
	00 4c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+304, 76 ; 0000004cH

; 440  : 	enumSLOT.DEMIGOD1 = SLOT_DEMIGOD1;

  009ba	c7 05 34 01 00
	00 4d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+308, 77 ; 0000004dH

; 441  : 	enumSLOT.DEMIGOD1_MIP = SLOT_DEMIGOD1_MIP;

  009c4	c7 05 38 01 00
	00 4e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+312, 78 ; 0000004eH

; 442  : 	enumSLOT.DEMIGOD2 = SLOT_DEMIGOD2;

  009ce	c7 05 3c 01 00
	00 4f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+316, 79 ; 0000004fH

; 443  : 	enumSLOT.DEMIGOD2_MIP = SLOT_DEMIGOD2_MIP;

  009d8	c7 05 40 01 00
	00 50 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+320, 80 ; 00000050H

; 444  : 	enumSLOT.DEMIGOD3 = SLOT_DEMIGOD3;

  009e2	c7 05 44 01 00
	00 51 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+324, 81 ; 00000051H

; 445  : 	enumSLOT.DEMIGOD3_MIP = SLOT_DEMIGOD3_MIP;

  009ec	c7 05 48 01 00
	00 52 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+328, 82 ; 00000052H

; 446  : 	enumSLOT.LITTLE_BEETLE = SLOT_LITTLE_BEETLE;

  009f6	c7 05 4c 01 00
	00 53 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+332, 83 ; 00000053H

; 447  : 	enumSLOT.BIG_BEETLE = SLOT_BIG_BEETLE;

  00a00	c7 05 50 01 00
	00 54 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+336, 84 ; 00000054H

; 448  : 	enumSLOT.BIG_BEETLE_MIP = SLOT_BIG_BEETLE_MIP;

  00a0a	c7 05 54 01 00
	00 55 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+340, 85 ; 00000055H

; 449  : 	enumSLOT.WRAITH1 = SLOT_WRAITH1;

  00a14	c7 05 58 01 00
	00 56 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+344, 86 ; 00000056H

; 450  : 	enumSLOT.WRAITH2 = SLOT_WRAITH2;

  00a1e	c7 05 5c 01 00
	00 57 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+348, 87 ; 00000057H

; 451  : 	enumSLOT.WRAITH3 = SLOT_WRAITH3;

  00a28	c7 05 60 01 00
	00 58 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+352, 88 ; 00000058H

; 452  : 	enumSLOT.WRAITH4 = SLOT_WRAITH4;

  00a32	c7 05 64 01 00
	00 59 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+356, 89 ; 00000059H

; 453  : 	enumSLOT.BAT = SLOT_BAT;

  00a3c	c7 05 68 01 00
	00 5a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+360, 90 ; 0000005aH

; 454  : 	enumSLOT.DOG = SLOT_DOG;

  00a46	c7 05 6c 01 00
	00 5b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+364, 91 ; 0000005bH

; 455  : 	enumSLOT.DOG_MIP = SLOT_DOG_MIP;

  00a50	c7 05 70 01 00
	00 5c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+368, 92 ; 0000005cH

; 456  : 	enumSLOT.HAMMERHEAD = SLOT_HAMMERHEAD;

  00a5a	c7 05 74 01 00
	00 5d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+372, 93 ; 0000005dH

; 457  : 	enumSLOT.HAMMERHEAD_MIP = SLOT_HAMMERHEAD_MIP;

  00a64	c7 05 78 01 00
	00 5e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+376, 94 ; 0000005eH

; 458  : 	enumSLOT.SAS = SLOT_SAS;

  00a6e	c7 05 7c 01 00
	00 5f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+380, 95 ; 0000005fH

; 459  : 	enumSLOT.SAS_MIP = SLOT_SAS_MIP;

  00a78	c7 05 80 01 00
	00 60 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+384, 96 ; 00000060H

; 460  : 	enumSLOT.SAS_DYING = SLOT_SAS_DYING;

  00a82	c7 05 84 01 00
	00 61 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+388, 97 ; 00000061H

; 461  : 	enumSLOT.SAS_DYING_MIP = SLOT_SAS_DYING_MIP;

  00a8c	c7 05 88 01 00
	00 62 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+392, 98 ; 00000062H

; 462  : 	enumSLOT.SAS_CAPTAIN = SLOT_SAS_CAPTAIN;

  00a96	c7 05 8c 01 00
	00 63 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+396, 99 ; 00000063H

; 463  : 	enumSLOT.SAS_CAPTAIN_MIP = SLOT_SAS_CAPTAIN_MIP;

  00aa0	c7 05 90 01 00
	00 64 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+400, 100 ; 00000064H

; 464  : 	enumSLOT.SAS_DRAG_BLOKE = SLOT_SAS_DRAG_BLOKE;

  00aaa	c7 05 94 01 00
	00 65 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+404, 101 ; 00000065H

; 465  : 	enumSLOT.AHMET = SLOT_AHMET;

  00ab4	c7 05 98 01 00
	00 66 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+408, 102 ; 00000066H

; 466  : 	enumSLOT.AHMET_MIP = SLOT_AHMET_MIP;

  00abe	c7 05 9c 01 00
	00 67 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+412, 103 ; 00000067H

; 467  : 	enumSLOT.LARA_DOUBLE = SLOT_LARA_DOUBLE;

  00ac8	c7 05 a0 01 00
	00 68 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+416, 104 ; 00000068H

; 468  : 	enumSLOT.LARA_DOUBLE_MIP = SLOT_LARA_DOUBLE_MIP;

  00ad2	c7 05 a4 01 00
	00 69 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+420, 105 ; 00000069H

; 469  : 	enumSLOT.SMALL_SCORPION = SLOT_SMALL_SCORPION;

  00adc	c7 05 a8 01 00
	00 6a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+424, 106 ; 0000006aH

; 470  : 	enumSLOT.LOCUST_EMITTER = SLOT_LOCUST_EMITTER;

  00ae6	c7 05 ac 01 00
	00 6b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+428, 107 ; 0000006bH

; 471  : 	enumSLOT.GAME_PIECE1 = SLOT_GAME_PIECE1;

  00af0	c7 05 b0 01 00
	00 6c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+432, 108 ; 0000006cH

; 472  : 	enumSLOT.GAME_PIECE2 = SLOT_GAME_PIECE2;

  00afa	c7 05 b4 01 00
	00 6d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+436, 109 ; 0000006dH

; 473  : 	enumSLOT.GAME_PIECE3 = SLOT_GAME_PIECE3;

  00b04	c7 05 b8 01 00
	00 6e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+440, 110 ; 0000006eH

; 474  : 	enumSLOT.ENEMY_PIECE = SLOT_ENEMY_PIECE;

  00b0e	c7 05 bc 01 00
	00 6f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+444, 111 ; 0000006fH

; 475  : 	enumSLOT.WHEEL_OF_FORTUNE = SLOT_WHEEL_OF_FORTUNE;

  00b18	c7 05 c0 01 00
	00 70 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+448, 112 ; 00000070H

; 476  : 	enumSLOT.SCALES = SLOT_SCALES;

  00b22	c7 05 c4 01 00
	00 71 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+452, 113 ; 00000071H

; 477  : 	enumSLOT.DARTS = SLOT_DARTS;

  00b2c	c7 05 c8 01 00
	00 72 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+456, 114 ; 00000072H

; 478  : 	enumSLOT.DART_EMITTER = SLOT_DART_EMITTER;

  00b36	c7 05 cc 01 00
	00 73 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+460, 115 ; 00000073H

; 479  : 	enumSLOT.HOMING_DART_EMITTER = SLOT_HOMING_DART_EMITTER;

  00b40	c7 05 d0 01 00
	00 74 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+464, 116 ; 00000074H

; 480  : 	enumSLOT.FALLING_CEILING = SLOT_FALLING_CEILING;

  00b4a	c7 05 d4 01 00
	00 75 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+468, 117 ; 00000075H

; 481  : 	enumSLOT.FALLING_BLOCK = SLOT_FALLING_BLOCK;

  00b54	c7 05 d8 01 00
	00 76 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+472, 118 ; 00000076H

; 482  : 	enumSLOT.FALLING_BLOCK2 = SLOT_FALLING_BLOCK2;

  00b5e	c7 05 dc 01 00
	00 77 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+476, 119 ; 00000077H

; 483  : 	enumSLOT.SMASHABLE_BIKE_WALL = SLOT_SMASHABLE_BIKE_WALL;

  00b68	c7 05 e0 01 00
	00 78 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+480, 120 ; 00000078H

; 484  : 	enumSLOT.SMASHABLE_BIKE_FLOOR = SLOT_SMASHABLE_BIKE_FLOOR;

  00b72	c7 05 e4 01 00
	00 79 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+484, 121 ; 00000079H

; 485  : 	enumSLOT.TRAPDOOR1 = SLOT_TRAPDOOR1;

  00b7c	c7 05 e8 01 00
	00 7a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+488, 122 ; 0000007aH

; 486  : 	enumSLOT.TRAPDOOR2 = SLOT_TRAPDOOR2;

  00b86	c7 05 ec 01 00
	00 7b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+492, 123 ; 0000007bH

; 487  : 	enumSLOT.TRAPDOOR3 = SLOT_TRAPDOOR3;

  00b90	c7 05 f0 01 00
	00 7c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+496, 124 ; 0000007cH

; 488  : 	enumSLOT.FLOOR_TRAPDOOR1 = SLOT_FLOOR_TRAPDOOR1;

  00b9a	c7 05 f4 01 00
	00 7d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+500, 125 ; 0000007dH

; 489  : 	enumSLOT.FLOOR_TRAPDOOR2 = SLOT_FLOOR_TRAPDOOR2;

  00ba4	c7 05 f8 01 00
	00 7e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+504, 126 ; 0000007eH

; 490  : 	enumSLOT.CEILING_TRAPDOOR1 = SLOT_CEILING_TRAPDOOR1;

  00bae	c7 05 fc 01 00
	00 7f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+508, 127 ; 0000007fH

; 491  : 	enumSLOT.CEILING_TRAPDOOR2 = SLOT_CEILING_TRAPDOOR2;

  00bb8	c7 05 00 02 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+512, 128 ; 00000080H

; 492  : 	enumSLOT.SCALING_TRAPDOOR = SLOT_SCALING_TRAPDOOR;

  00bc2	c7 05 04 02 00
	00 81 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+516, 129 ; 00000081H

; 493  : 	enumSLOT.ROLLINGBALL = SLOT_ROLLINGBALL;

  00bcc	c7 05 08 02 00
	00 82 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+520, 130 ; 00000082H

; 494  : 	enumSLOT.SPIKEY_FLOOR = SLOT_SPIKEY_FLOOR;

  00bd6	c7 05 0c 02 00
	00 83 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+524, 131 ; 00000083H

; 495  : 	enumSLOT.TEETH_SPIKES = SLOT_TEETH_SPIKES;

  00be0	c7 05 10 02 00
	00 84 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+528, 132 ; 00000084H

; 496  : 	enumSLOT.JOBY_SPIKES = SLOT_JOBY_SPIKES;

  00bea	c7 05 14 02 00
	00 85 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+532, 133 ; 00000085H

; 497  : 	enumSLOT.SLICER_DICER = SLOT_SLICER_DICER;

  00bf4	c7 05 18 02 00
	00 86 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+536, 134 ; 00000086H

; 498  : 	enumSLOT.CHAIN = SLOT_CHAIN;

  00bfe	c7 05 1c 02 00
	00 87 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+540, 135 ; 00000087H

; 499  : 	enumSLOT.PLOUGH = SLOT_PLOUGH;

  00c08	c7 05 20 02 00
	00 88 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+544, 136 ; 00000088H

; 500  : 	enumSLOT.STARGATE = SLOT_STARGATE;

  00c12	c7 05 24 02 00
	00 89 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+548, 137 ; 00000089H

; 501  : 	enumSLOT.HAMMER = SLOT_HAMMER;

  00c1c	c7 05 28 02 00
	00 8a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+552, 138 ; 0000008aH

; 502  : 	enumSLOT.BURNING_FLOOR = SLOT_BURNING_FLOOR;

  00c26	c7 05 2c 02 00
	00 8b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+556, 139 ; 0000008bH

; 503  : 	enumSLOT.COG = SLOT_COG;

  00c30	c7 05 30 02 00
	00 8c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+560, 140 ; 0000008cH

; 504  : 	enumSLOT.SPIKEBALL = SLOT_SPIKEBALL;

  00c3a	c7 05 34 02 00
	00 8d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+564, 141 ; 0000008dH

; 505  : 	enumSLOT.FLAME = SLOT_FLAME;

  00c44	c7 05 38 02 00
	00 8e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+568, 142 ; 0000008eH

; 506  : 	enumSLOT.FLAME_EMITTER = SLOT_FLAME_EMITTER;

  00c4e	c7 05 3c 02 00
	00 8f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+572, 143 ; 0000008fH

; 507  : 	enumSLOT.FLAME_EMITTER2 = SLOT_FLAME_EMITTER2;

  00c58	c7 05 40 02 00
	00 90 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+576, 144 ; 00000090H

; 508  : 	enumSLOT.FLAME_EMITTER3 = SLOT_FLAME_EMITTER3;

  00c62	c7 05 44 02 00
	00 91 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+580, 145 ; 00000091H

; 509  : 	enumSLOT.ROPE = SLOT_ROPE;

  00c6c	c7 05 48 02 00
	00 92 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+584, 146 ; 00000092H

; 510  : 	enumSLOT.FIREROPE = SLOT_FIREROPE;

  00c76	c7 05 4c 02 00
	00 93 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+588, 147 ; 00000093H

; 511  : 	enumSLOT.POLEROPE = SLOT_POLEROPE;

  00c80	c7 05 50 02 00
	00 94 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+592, 148 ; 00000094H

; 512  : 	enumSLOT.ONEBLOCK_PLATFORM = SLOT_ONEBLOCK_PLATFORM;

  00c8a	c7 05 54 02 00
	00 95 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+596, 149 ; 00000095H

; 513  : 	enumSLOT.TWOBLOCK_PLATFORM = SLOT_TWOBLOCK_PLATFORM;

  00c94	c7 05 58 02 00
	00 96 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+600, 150 ; 00000096H

; 514  : 	enumSLOT.RAISING_BLOCK1 = SLOT_RAISING_BLOCK1;

  00c9e	c7 05 5c 02 00
	00 97 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+604, 151 ; 00000097H

; 515  : 	enumSLOT.RAISING_BLOCK2 = SLOT_RAISING_BLOCK2;

  00ca8	c7 05 60 02 00
	00 98 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+608, 152 ; 00000098H

; 516  : 	enumSLOT.EXPANDING_PLATFORM = SLOT_EXPANDING_PLATFORM;

  00cb2	c7 05 64 02 00
	00 99 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+612, 153 ; 00000099H

; 517  : 	enumSLOT.SQUISHY_BLOCK1 = SLOT_SQUISHY_BLOCK1;

  00cbc	c7 05 68 02 00
	00 9a 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+616, 154 ; 0000009aH

; 518  : 	enumSLOT.SQUISHY_BLOCK2 = SLOT_SQUISHY_BLOCK2;

  00cc6	c7 05 6c 02 00
	00 9b 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+620, 155 ; 0000009bH

; 519  : 	enumSLOT.PUSHABLE_OBJECT1 = SLOT_PUSHABLE_OBJECT1;

  00cd0	c7 05 70 02 00
	00 9c 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+624, 156 ; 0000009cH

; 520  : 	enumSLOT.PUSHABLE_OBJECT2 = SLOT_PUSHABLE_OBJECT2;

  00cda	c7 05 74 02 00
	00 9d 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+628, 157 ; 0000009dH

; 521  : 	enumSLOT.PUSHABLE_OBJECT3 = SLOT_PUSHABLE_OBJECT3;

  00ce4	c7 05 78 02 00
	00 9e 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+632, 158 ; 0000009eH

; 522  : 	enumSLOT.PUSHABLE_OBJECT4 = SLOT_PUSHABLE_OBJECT4;

  00cee	c7 05 7c 02 00
	00 9f 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+636, 159 ; 0000009fH

; 523  : 	enumSLOT.PUSHABLE_OBJECT5 = SLOT_PUSHABLE_OBJECT5;

  00cf8	c7 05 80 02 00
	00 a0 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+640, 160 ; 000000a0H

; 524  : 	enumSLOT.TRIPWIRE = SLOT_TRIPWIRE;

  00d02	c7 05 84 02 00
	00 a1 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+644, 161 ; 000000a1H

; 525  : 	enumSLOT.SENTRY_GUN = SLOT_SENTRY_GUN;

  00d0c	c7 05 88 02 00
	00 a2 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+648, 162 ; 000000a2H

; 526  : 	enumSLOT.MINE = SLOT_MINE;

  00d16	c7 05 8c 02 00
	00 a3 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+652, 163 ; 000000a3H

; 527  : 	enumSLOT.MAPPER = SLOT_MAPPER;

  00d20	c7 05 90 02 00
	00 a4 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+656, 164 ; 000000a4H

; 528  : 	enumSLOT.OBELISK = SLOT_OBELISK;

  00d2a	c7 05 94 02 00
	00 a5 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+660, 165 ; 000000a5H

; 529  : 	enumSLOT.FLOOR_4BLADE = SLOT_FLOOR_4BLADE;

  00d34	c7 05 98 02 00
	00 a6 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+664, 166 ; 000000a6H

; 530  : 	enumSLOT.ROOF_4BLADE = SLOT_ROOF_4BLADE;

  00d3e	c7 05 9c 02 00
	00 a7 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+668, 167 ; 000000a7H

; 531  : 	enumSLOT.BIRD_BLADE = SLOT_BIRD_BLADE;

  00d48	c7 05 a0 02 00
	00 a8 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+672, 168 ; 000000a8H

; 532  : 	enumSLOT.CATWALK_BLADE = SLOT_CATWALK_BLADE;

  00d52	c7 05 a4 02 00
	00 a9 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+676, 169 ; 000000a9H

; 533  : 	enumSLOT.MOVING_BLADE = SLOT_MOVING_BLADE;

  00d5c	c7 05 a8 02 00
	00 aa 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+680, 170 ; 000000aaH

; 534  : 	enumSLOT.PLINTH_BLADE = SLOT_PLINTH_BLADE;

  00d66	c7 05 ac 02 00
	00 ab 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+684, 171 ; 000000abH

; 535  : 	enumSLOT.SETH_BLADE = SLOT_SETH_BLADE;

  00d70	c7 05 b0 02 00
	00 ac 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+688, 172 ; 000000acH

; 536  : 	enumSLOT.LIGHTNING_CONDUCTOR = SLOT_LIGHTNING_CONDUCTOR;

  00d7a	c7 05 b4 02 00
	00 ad 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+692, 173 ; 000000adH

; 537  : 	enumSLOT.ELEMENT_PUZZLE = SLOT_ELEMENT_PUZZLE;

  00d84	c7 05 b8 02 00
	00 ae 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+696, 174 ; 000000aeH

; 538  : 	enumSLOT.PUZZLE_ITEM1 = SLOT_PUZZLE_ITEM1;

  00d8e	c7 05 bc 02 00
	00 af 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+700, 175 ; 000000afH

; 539  : 	enumSLOT.PUZZLE_ITEM2 = SLOT_PUZZLE_ITEM2;

  00d98	c7 05 c0 02 00
	00 b0 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+704, 176 ; 000000b0H

; 540  : 	enumSLOT.PUZZLE_ITEM3 = SLOT_PUZZLE_ITEM3;

  00da2	c7 05 c4 02 00
	00 b1 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+708, 177 ; 000000b1H

; 541  : 	enumSLOT.PUZZLE_ITEM4 = SLOT_PUZZLE_ITEM4;

  00dac	c7 05 c8 02 00
	00 b2 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+712, 178 ; 000000b2H

; 542  : 	enumSLOT.PUZZLE_ITEM5 = SLOT_PUZZLE_ITEM5;

  00db6	c7 05 cc 02 00
	00 b3 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+716, 179 ; 000000b3H

; 543  : 	enumSLOT.PUZZLE_ITEM6 = SLOT_PUZZLE_ITEM6;

  00dc0	c7 05 d0 02 00
	00 b4 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+720, 180 ; 000000b4H

; 544  : 	enumSLOT.PUZZLE_ITEM7 = SLOT_PUZZLE_ITEM7;

  00dca	c7 05 d4 02 00
	00 b5 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+724, 181 ; 000000b5H

; 545  : 	enumSLOT.PUZZLE_ITEM8 = SLOT_PUZZLE_ITEM8;

  00dd4	c7 05 d8 02 00
	00 b6 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+728, 182 ; 000000b6H

; 546  : 	enumSLOT.PUZZLE_ITEM9 = SLOT_PUZZLE_ITEM9;

  00dde	c7 05 dc 02 00
	00 b7 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+732, 183 ; 000000b7H

; 547  : 	enumSLOT.PUZZLE_ITEM10 = SLOT_PUZZLE_ITEM10;

  00de8	c7 05 e0 02 00
	00 b8 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+736, 184 ; 000000b8H

; 548  : 	enumSLOT.PUZZLE_ITEM11 = SLOT_PUZZLE_ITEM11;

  00df2	c7 05 e4 02 00
	00 b9 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+740, 185 ; 000000b9H

; 549  : 	enumSLOT.PUZZLE_ITEM12 = SLOT_PUZZLE_ITEM12;

  00dfc	c7 05 e8 02 00
	00 ba 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+744, 186 ; 000000baH

; 550  : 	enumSLOT.PUZZLE_ITEM1_COMBO1 = SLOT_PUZZLE_ITEM1_COMBO1;

  00e06	c7 05 ec 02 00
	00 bb 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+748, 187 ; 000000bbH

; 551  : 	enumSLOT.PUZZLE_ITEM1_COMBO2 = SLOT_PUZZLE_ITEM1_COMBO2;

  00e10	c7 05 f0 02 00
	00 bc 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+752, 188 ; 000000bcH

; 552  : 	enumSLOT.PUZZLE_ITEM2_COMBO1 = SLOT_PUZZLE_ITEM2_COMBO1;

  00e1a	c7 05 f4 02 00
	00 bd 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+756, 189 ; 000000bdH

; 553  : 	enumSLOT.PUZZLE_ITEM2_COMBO2 = SLOT_PUZZLE_ITEM2_COMBO2;

  00e24	c7 05 f8 02 00
	00 be 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+760, 190 ; 000000beH

; 554  : 	enumSLOT.PUZZLE_ITEM3_COMBO1 = SLOT_PUZZLE_ITEM3_COMBO1;

  00e2e	c7 05 fc 02 00
	00 bf 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+764, 191 ; 000000bfH

; 555  : 	enumSLOT.PUZZLE_ITEM3_COMBO2 = SLOT_PUZZLE_ITEM3_COMBO2;

  00e38	c7 05 00 03 00
	00 c0 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+768, 192 ; 000000c0H

; 556  : 	enumSLOT.PUZZLE_ITEM4_COMBO1 = SLOT_PUZZLE_ITEM4_COMBO1;

  00e42	c7 05 04 03 00
	00 c1 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+772, 193 ; 000000c1H

; 557  : 	enumSLOT.PUZZLE_ITEM4_COMBO2 = SLOT_PUZZLE_ITEM4_COMBO2;

  00e4c	c7 05 08 03 00
	00 c2 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+776, 194 ; 000000c2H

; 558  : 	enumSLOT.PUZZLE_ITEM5_COMBO1 = SLOT_PUZZLE_ITEM5_COMBO1;

  00e56	c7 05 0c 03 00
	00 c3 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+780, 195 ; 000000c3H

; 559  : 	enumSLOT.PUZZLE_ITEM5_COMBO2 = SLOT_PUZZLE_ITEM5_COMBO2;

  00e60	c7 05 10 03 00
	00 c4 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+784, 196 ; 000000c4H

; 560  : 	enumSLOT.PUZZLE_ITEM6_COMBO1 = SLOT_PUZZLE_ITEM6_COMBO1;

  00e6a	c7 05 14 03 00
	00 c5 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+788, 197 ; 000000c5H

; 561  : 	enumSLOT.PUZZLE_ITEM6_COMBO2 = SLOT_PUZZLE_ITEM6_COMBO2;

  00e74	c7 05 18 03 00
	00 c6 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+792, 198 ; 000000c6H

; 562  : 	enumSLOT.PUZZLE_ITEM7_COMBO1 = SLOT_PUZZLE_ITEM7_COMBO1;

  00e7e	c7 05 1c 03 00
	00 c7 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+796, 199 ; 000000c7H

; 563  : 	enumSLOT.PUZZLE_ITEM7_COMBO2 = SLOT_PUZZLE_ITEM7_COMBO2;

  00e88	c7 05 20 03 00
	00 c8 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+800, 200 ; 000000c8H

; 564  : 	enumSLOT.PUZZLE_ITEM8_COMBO1 = SLOT_PUZZLE_ITEM8_COMBO1;

  00e92	c7 05 24 03 00
	00 c9 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+804, 201 ; 000000c9H

; 565  : 	enumSLOT.PUZZLE_ITEM8_COMBO2 = SLOT_PUZZLE_ITEM8_COMBO2;

  00e9c	c7 05 28 03 00
	00 ca 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+808, 202 ; 000000caH

; 566  : 	enumSLOT.KEY_ITEM1 = SLOT_KEY_ITEM1;

  00ea6	c7 05 2c 03 00
	00 cb 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+812, 203 ; 000000cbH

; 567  : 	enumSLOT.KEY_ITEM2 = SLOT_KEY_ITEM2;

  00eb0	c7 05 30 03 00
	00 cc 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+816, 204 ; 000000ccH

; 568  : 	enumSLOT.KEY_ITEM3 = SLOT_KEY_ITEM3;

  00eba	c7 05 34 03 00
	00 cd 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+820, 205 ; 000000cdH

; 569  : 	enumSLOT.KEY_ITEM4 = SLOT_KEY_ITEM4;

  00ec4	c7 05 38 03 00
	00 ce 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+824, 206 ; 000000ceH

; 570  : 	enumSLOT.KEY_ITEM5 = SLOT_KEY_ITEM5;

  00ece	c7 05 3c 03 00
	00 cf 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+828, 207 ; 000000cfH

; 571  : 	enumSLOT.KEY_ITEM6 = SLOT_KEY_ITEM6;

  00ed8	c7 05 40 03 00
	00 d0 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+832, 208 ; 000000d0H

; 572  : 	enumSLOT.KEY_ITEM7 = SLOT_KEY_ITEM7;

  00ee2	c7 05 44 03 00
	00 d1 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+836, 209 ; 000000d1H

; 573  : 	enumSLOT.KEY_ITEM8 = SLOT_KEY_ITEM8;

  00eec	c7 05 48 03 00
	00 d2 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+840, 210 ; 000000d2H

; 574  : 	enumSLOT.KEY_ITEM9 = SLOT_KEY_ITEM9;

  00ef6	c7 05 4c 03 00
	00 d3 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+844, 211 ; 000000d3H

; 575  : 	enumSLOT.KEY_ITEM10 = SLOT_KEY_ITEM10;

  00f00	c7 05 50 03 00
	00 d4 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+848, 212 ; 000000d4H

; 576  : 	enumSLOT.KEY_ITEM11 = SLOT_KEY_ITEM11;

  00f0a	c7 05 54 03 00
	00 d5 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+852, 213 ; 000000d5H

; 577  : 	enumSLOT.KEY_ITEM12 = SLOT_KEY_ITEM12;

  00f14	c7 05 58 03 00
	00 d6 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+856, 214 ; 000000d6H

; 578  : 	enumSLOT.KEY_ITEM1_COMBO1 = SLOT_KEY_ITEM1_COMBO1;

  00f1e	c7 05 5c 03 00
	00 d7 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+860, 215 ; 000000d7H

; 579  : 	enumSLOT.KEY_ITEM1_COMBO2 = SLOT_KEY_ITEM1_COMBO2;

  00f28	c7 05 60 03 00
	00 d8 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+864, 216 ; 000000d8H

; 580  : 	enumSLOT.KEY_ITEM2_COMBO1 = SLOT_KEY_ITEM2_COMBO1;

  00f32	c7 05 64 03 00
	00 d9 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+868, 217 ; 000000d9H

; 581  : 	enumSLOT.KEY_ITEM2_COMBO2 = SLOT_KEY_ITEM2_COMBO2;

  00f3c	c7 05 68 03 00
	00 da 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+872, 218 ; 000000daH

; 582  : 	enumSLOT.KEY_ITEM3_COMBO1 = SLOT_KEY_ITEM3_COMBO1;

  00f46	c7 05 6c 03 00
	00 db 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+876, 219 ; 000000dbH

; 583  : 	enumSLOT.KEY_ITEM3_COMBO2 = SLOT_KEY_ITEM3_COMBO2;

  00f50	c7 05 70 03 00
	00 dc 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+880, 220 ; 000000dcH

; 584  : 	enumSLOT.KEY_ITEM4_COMBO1 = SLOT_KEY_ITEM4_COMBO1;

  00f5a	c7 05 74 03 00
	00 dd 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+884, 221 ; 000000ddH

; 585  : 	enumSLOT.KEY_ITEM4_COMBO2 = SLOT_KEY_ITEM4_COMBO2;

  00f64	c7 05 78 03 00
	00 de 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+888, 222 ; 000000deH

; 586  : 	enumSLOT.KEY_ITEM5_COMBO1 = SLOT_KEY_ITEM5_COMBO1;

  00f6e	c7 05 7c 03 00
	00 df 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+892, 223 ; 000000dfH

; 587  : 	enumSLOT.KEY_ITEM5_COMBO2 = SLOT_KEY_ITEM5_COMBO2;

  00f78	c7 05 80 03 00
	00 e0 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+896, 224 ; 000000e0H

; 588  : 	enumSLOT.KEY_ITEM6_COMBO1 = SLOT_KEY_ITEM6_COMBO1;

  00f82	c7 05 84 03 00
	00 e1 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+900, 225 ; 000000e1H

; 589  : 	enumSLOT.KEY_ITEM6_COMBO2 = SLOT_KEY_ITEM6_COMBO2;

  00f8c	c7 05 88 03 00
	00 e2 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+904, 226 ; 000000e2H

; 590  : 	enumSLOT.KEY_ITEM7_COMBO1 = SLOT_KEY_ITEM7_COMBO1;

  00f96	c7 05 8c 03 00
	00 e3 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+908, 227 ; 000000e3H

; 591  : 	enumSLOT.KEY_ITEM7_COMBO2 = SLOT_KEY_ITEM7_COMBO2;

  00fa0	c7 05 90 03 00
	00 e4 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+912, 228 ; 000000e4H

; 592  : 	enumSLOT.KEY_ITEM8_COMBO1 = SLOT_KEY_ITEM8_COMBO1;

  00faa	c7 05 94 03 00
	00 e5 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+916, 229 ; 000000e5H

; 593  : 	enumSLOT.KEY_ITEM8_COMBO2 = SLOT_KEY_ITEM8_COMBO2;

  00fb4	c7 05 98 03 00
	00 e6 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+920, 230 ; 000000e6H

; 594  : 	enumSLOT.PICKUP_ITEM1 = SLOT_PICKUP_ITEM1;

  00fbe	c7 05 9c 03 00
	00 e7 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+924, 231 ; 000000e7H

; 595  : 	enumSLOT.PICKUP_ITEM2 = SLOT_PICKUP_ITEM2;

  00fc8	c7 05 a0 03 00
	00 e8 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+928, 232 ; 000000e8H

; 596  : 	enumSLOT.PICKUP_ITEM3 = SLOT_PICKUP_ITEM3;

  00fd2	c7 05 a4 03 00
	00 e9 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+932, 233 ; 000000e9H

; 597  : 	enumSLOT.PICKUP_ITEM4 = SLOT_PICKUP_ITEM4;

  00fdc	c7 05 a8 03 00
	00 ea 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+936, 234 ; 000000eaH

; 598  : 	enumSLOT.PICKUP_ITEM1_COMBO1 = SLOT_PICKUP_ITEM1_COMBO1;

  00fe6	c7 05 ac 03 00
	00 eb 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+940, 235 ; 000000ebH

; 599  : 	enumSLOT.PICKUP_ITEM1_COMBO2 = SLOT_PICKUP_ITEM1_COMBO2;

  00ff0	c7 05 b0 03 00
	00 ec 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+944, 236 ; 000000ecH

; 600  : 	enumSLOT.PICKUP_ITEM2_COMBO1 = SLOT_PICKUP_ITEM2_COMBO1;

  00ffa	c7 05 b4 03 00
	00 ed 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+948, 237 ; 000000edH

; 601  : 	enumSLOT.PICKUP_ITEM2_COMBO2 = SLOT_PICKUP_ITEM2_COMBO2;

  01004	c7 05 b8 03 00
	00 ee 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+952, 238 ; 000000eeH

; 602  : 	enumSLOT.PICKUP_ITEM3_COMBO1 = SLOT_PICKUP_ITEM3_COMBO1;

  0100e	c7 05 bc 03 00
	00 ef 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+956, 239 ; 000000efH

; 603  : 	enumSLOT.PICKUP_ITEM3_COMBO2 = SLOT_PICKUP_ITEM3_COMBO2;

  01018	c7 05 c0 03 00
	00 f0 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+960, 240 ; 000000f0H

; 604  : 	enumSLOT.PICKUP_ITEM4_COMBO1 = SLOT_PICKUP_ITEM4_COMBO1;

  01022	c7 05 c4 03 00
	00 f1 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+964, 241 ; 000000f1H

; 605  : 	enumSLOT.PICKUP_ITEM4_COMBO2 = SLOT_PICKUP_ITEM4_COMBO2;

  0102c	c7 05 c8 03 00
	00 f2 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+968, 242 ; 000000f2H

; 606  : 	enumSLOT.EXAMINE1 = SLOT_EXAMINE1;

  01036	c7 05 cc 03 00
	00 f3 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+972, 243 ; 000000f3H

; 607  : 	enumSLOT.EXAMINE2 = SLOT_EXAMINE2;

  01040	c7 05 d0 03 00
	00 f4 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+976, 244 ; 000000f4H

; 608  : 	enumSLOT.EXAMINE3 = SLOT_EXAMINE3;

  0104a	c7 05 d4 03 00
	00 f5 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+980, 245 ; 000000f5H

; 609  : 	enumSLOT.CROWBAR_ITEM = SLOT_CROWBAR_ITEM;

  01054	c7 05 d8 03 00
	00 f6 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+984, 246 ; 000000f6H

; 610  : 	enumSLOT.BURNING_TORCH_ITEM = SLOT_BURNING_TORCH_ITEM;

  0105e	c7 05 dc 03 00
	00 f7 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+988, 247 ; 000000f7H

; 611  : 	enumSLOT.CLOCKWORK_BEETLE = SLOT_CLOCKWORK_BEETLE;

  01068	c7 05 e0 03 00
	00 f8 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+992, 248 ; 000000f8H

; 612  : 	enumSLOT.CLOCKWORK_BEETLE_COMBO1 = SLOT_CLOCKWORK_BEETLE_COMBO1;

  01072	c7 05 e4 03 00
	00 f9 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+996, 249 ; 000000f9H

; 613  : 	enumSLOT.CLOCKWORK_BEETLE_COMBO2 = SLOT_CLOCKWORK_BEETLE_COMBO2;

  0107c	c7 05 e8 03 00
	00 fa 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1000, 250 ; 000000faH

; 614  : 	enumSLOT.MINE_DETECTOR = SLOT_MINE_DETECTOR;

  01086	c7 05 ec 03 00
	00 fb 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1004, 251 ; 000000fbH

; 615  : 	enumSLOT.QUEST_ITEM1 = SLOT_QUEST_ITEM1;

  01090	c7 05 f0 03 00
	00 fc 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1008, 252 ; 000000fcH

; 616  : 	enumSLOT.QUEST_ITEM2 = SLOT_QUEST_ITEM2;

  0109a	c7 05 f4 03 00
	00 fd 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1012, 253 ; 000000fdH

; 617  : 	enumSLOT.QUEST_ITEM3 = SLOT_QUEST_ITEM3;

  010a4	c7 05 f8 03 00
	00 fe 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1016, 254 ; 000000feH

; 618  : 	enumSLOT.QUEST_ITEM4 = SLOT_QUEST_ITEM4;

  010ae	c7 05 fc 03 00
	00 ff 00 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1020, 255 ; 000000ffH

; 619  : 	enumSLOT.QUEST_ITEM5 = SLOT_QUEST_ITEM5;

  010b8	c7 05 00 04 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1024, 256 ; 00000100H

; 620  : 	enumSLOT.QUEST_ITEM6 = SLOT_QUEST_ITEM6;

  010c2	c7 05 04 04 00
	00 01 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1028, 257 ; 00000101H

; 621  : 	enumSLOT.MAP = SLOT_MAP;

  010cc	c7 05 08 04 00
	00 02 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1032, 258 ; 00000102H

; 622  : 	enumSLOT.SECRET_MAP = SLOT_SECRET_MAP;

  010d6	c7 05 0c 04 00
	00 03 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1036, 259 ; 00000103H

; 623  : 	enumSLOT.PUZZLE_HOLE1 = SLOT_PUZZLE_HOLE1;

  010e0	c7 05 10 04 00
	00 04 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1040, 260 ; 00000104H

; 624  : 	enumSLOT.PUZZLE_HOLE2 = SLOT_PUZZLE_HOLE2;

  010ea	c7 05 14 04 00
	00 05 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1044, 261 ; 00000105H

; 625  : 	enumSLOT.PUZZLE_HOLE3 = SLOT_PUZZLE_HOLE3;

  010f4	c7 05 18 04 00
	00 06 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1048, 262 ; 00000106H

; 626  : 	enumSLOT.PUZZLE_HOLE4 = SLOT_PUZZLE_HOLE4;

  010fe	c7 05 1c 04 00
	00 07 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1052, 263 ; 00000107H

; 627  : 	enumSLOT.PUZZLE_HOLE5 = SLOT_PUZZLE_HOLE5;

  01108	c7 05 20 04 00
	00 08 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1056, 264 ; 00000108H

; 628  : 	enumSLOT.PUZZLE_HOLE6 = SLOT_PUZZLE_HOLE6;

  01112	c7 05 24 04 00
	00 09 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1060, 265 ; 00000109H

; 629  : 	enumSLOT.PUZZLE_HOLE7 = SLOT_PUZZLE_HOLE7;

  0111c	c7 05 28 04 00
	00 0a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1064, 266 ; 0000010aH

; 630  : 	enumSLOT.PUZZLE_HOLE8 = SLOT_PUZZLE_HOLE8;

  01126	c7 05 2c 04 00
	00 0b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1068, 267 ; 0000010bH

; 631  : 	enumSLOT.PUZZLE_HOLE9 = SLOT_PUZZLE_HOLE9;

  01130	c7 05 30 04 00
	00 0c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1072, 268 ; 0000010cH

; 632  : 	enumSLOT.PUZZLE_HOLE10 = SLOT_PUZZLE_HOLE10;

  0113a	c7 05 34 04 00
	00 0d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1076, 269 ; 0000010dH

; 633  : 	enumSLOT.PUZZLE_HOLE11 = SLOT_PUZZLE_HOLE11;

  01144	c7 05 38 04 00
	00 0e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1080, 270 ; 0000010eH

; 634  : 	enumSLOT.PUZZLE_HOLE12 = SLOT_PUZZLE_HOLE12;

  0114e	c7 05 3c 04 00
	00 0f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1084, 271 ; 0000010fH

; 635  : 	enumSLOT.PUZZLE_DONE1 = SLOT_PUZZLE_DONE1;

  01158	c7 05 40 04 00
	00 10 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1088, 272 ; 00000110H

; 636  : 	enumSLOT.PUZZLE_DONE2 = SLOT_PUZZLE_DONE2;

  01162	c7 05 44 04 00
	00 11 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1092, 273 ; 00000111H

; 637  : 	enumSLOT.PUZZLE_DONE3 = SLOT_PUZZLE_DONE3;

  0116c	c7 05 48 04 00
	00 12 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1096, 274 ; 00000112H

; 638  : 	enumSLOT.PUZZLE_DONE4 = SLOT_PUZZLE_DONE4;

  01176	c7 05 4c 04 00
	00 13 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1100, 275 ; 00000113H

; 639  : 	enumSLOT.PUZZLE_DONE5 = SLOT_PUZZLE_DONE5;

  01180	c7 05 50 04 00
	00 14 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1104, 276 ; 00000114H

; 640  : 	enumSLOT.PUZZLE_DONE6 = SLOT_PUZZLE_DONE6;

  0118a	c7 05 54 04 00
	00 15 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1108, 277 ; 00000115H

; 641  : 	enumSLOT.PUZZLE_DONE7 = SLOT_PUZZLE_DONE7;

  01194	c7 05 58 04 00
	00 16 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1112, 278 ; 00000116H

; 642  : 	enumSLOT.PUZZLE_DONE8 = SLOT_PUZZLE_DONE8;

  0119e	c7 05 5c 04 00
	00 17 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1116, 279 ; 00000117H

; 643  : 	enumSLOT.PUZZLE_DONE9 = SLOT_PUZZLE_DONE9;

  011a8	c7 05 60 04 00
	00 18 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1120, 280 ; 00000118H

; 644  : 	enumSLOT.PUZZLE_DONE10 = SLOT_PUZZLE_DONE10;

  011b2	c7 05 64 04 00
	00 19 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1124, 281 ; 00000119H

; 645  : 	enumSLOT.PUZZLE_DONE11 = SLOT_PUZZLE_DONE11;

  011bc	c7 05 68 04 00
	00 1a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1128, 282 ; 0000011aH

; 646  : 	enumSLOT.PUZZLE_DONE12 = SLOT_PUZZLE_DONE12;

  011c6	c7 05 6c 04 00
	00 1b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1132, 283 ; 0000011bH

; 647  : 	enumSLOT.KEY_HOLE1 = SLOT_KEY_HOLE1;

  011d0	c7 05 70 04 00
	00 1c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1136, 284 ; 0000011cH

; 648  : 	enumSLOT.KEY_HOLE2 = SLOT_KEY_HOLE2;

  011da	c7 05 74 04 00
	00 1d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1140, 285 ; 0000011dH

; 649  : 	enumSLOT.KEY_HOLE3 = SLOT_KEY_HOLE3;

  011e4	c7 05 78 04 00
	00 1e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1144, 286 ; 0000011eH

; 650  : 	enumSLOT.KEY_HOLE4 = SLOT_KEY_HOLE4;

  011ee	c7 05 7c 04 00
	00 1f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1148, 287 ; 0000011fH

; 651  : 	enumSLOT.KEY_HOLE5 = SLOT_KEY_HOLE5;

  011f8	c7 05 80 04 00
	00 20 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1152, 288 ; 00000120H

; 652  : 	enumSLOT.KEY_HOLE6 = SLOT_KEY_HOLE6;

  01202	c7 05 84 04 00
	00 21 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1156, 289 ; 00000121H

; 653  : 	enumSLOT.KEY_HOLE7 = SLOT_KEY_HOLE7;

  0120c	c7 05 88 04 00
	00 22 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1160, 290 ; 00000122H

; 654  : 	enumSLOT.KEY_HOLE8 = SLOT_KEY_HOLE8;

  01216	c7 05 8c 04 00
	00 23 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1164, 291 ; 00000123H

; 655  : 	enumSLOT.KEY_HOLE9 = SLOT_KEY_HOLE9;

  01220	c7 05 90 04 00
	00 24 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1168, 292 ; 00000124H

; 656  : 	enumSLOT.KEY_HOLE10 = SLOT_KEY_HOLE10;

  0122a	c7 05 94 04 00
	00 25 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1172, 293 ; 00000125H

; 657  : 	enumSLOT.KEY_HOLE11 = SLOT_KEY_HOLE11;

  01234	c7 05 98 04 00
	00 26 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1176, 294 ; 00000126H

; 658  : 	enumSLOT.KEY_HOLE12 = SLOT_KEY_HOLE12;

  0123e	c7 05 9c 04 00
	00 27 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1180, 295 ; 00000127H

; 659  : 	enumSLOT.WATERSKIN1_EMPTY = SLOT_WATERSKIN1_EMPTY;

  01248	c7 05 a0 04 00
	00 28 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1184, 296 ; 00000128H

; 660  : 	enumSLOT.WATERSKIN1_1 = SLOT_WATERSKIN1_1;

  01252	c7 05 a4 04 00
	00 29 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1188, 297 ; 00000129H

; 661  : 	enumSLOT.WATERSKIN1_2 = SLOT_WATERSKIN1_2;

  0125c	c7 05 a8 04 00
	00 2a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1192, 298 ; 0000012aH

; 662  : 	enumSLOT.WATERSKIN1_3 = SLOT_WATERSKIN1_3;

  01266	c7 05 ac 04 00
	00 2b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1196, 299 ; 0000012bH

; 663  : 	enumSLOT.WATERSKIN2_EMPTY = SLOT_WATERSKIN2_EMPTY;

  01270	c7 05 b0 04 00
	00 2c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1200, 300 ; 0000012cH

; 664  : 	enumSLOT.WATERSKIN2_1 = SLOT_WATERSKIN2_1;

  0127a	c7 05 b4 04 00
	00 2d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1204, 301 ; 0000012dH

; 665  : 	enumSLOT.WATERSKIN2_2 = SLOT_WATERSKIN2_2;

  01284	c7 05 b8 04 00
	00 2e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1208, 302 ; 0000012eH

; 666  : 	enumSLOT.WATERSKIN2_3 = SLOT_WATERSKIN2_3;

  0128e	c7 05 bc 04 00
	00 2f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1212, 303 ; 0000012fH

; 667  : 	enumSLOT.WATERSKIN2_4 = SLOT_WATERSKIN2_4;

  01298	c7 05 c0 04 00
	00 30 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1216, 304 ; 00000130H

; 668  : 	enumSLOT.WATERSKIN2_5 = SLOT_WATERSKIN2_5;

  012a2	c7 05 c4 04 00
	00 31 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1220, 305 ; 00000131H

; 669  : 	enumSLOT.SWITCH_TYPE1 = SLOT_SWITCH_TYPE1;

  012ac	c7 05 c8 04 00
	00 32 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1224, 306 ; 00000132H

; 670  : 	enumSLOT.SWITCH_TYPE2 = SLOT_SWITCH_TYPE2;

  012b6	c7 05 cc 04 00
	00 33 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1228, 307 ; 00000133H

; 671  : 	enumSLOT.SWITCH_TYPE3 = SLOT_SWITCH_TYPE3;

  012c0	c7 05 d0 04 00
	00 34 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1232, 308 ; 00000134H

; 672  : 	enumSLOT.SWITCH_TYPE4 = SLOT_SWITCH_TYPE4;

  012ca	c7 05 d4 04 00
	00 35 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1236, 309 ; 00000135H

; 673  : 	enumSLOT.SWITCH_TYPE5 = SLOT_SWITCH_TYPE5;

  012d4	c7 05 d8 04 00
	00 36 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1240, 310 ; 00000136H

; 674  : 	enumSLOT.SWITCH_TYPE6 = SLOT_SWITCH_TYPE6;

  012de	c7 05 dc 04 00
	00 37 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1244, 311 ; 00000137H

; 675  : 	enumSLOT.SWITCH_TYPE7 = SLOT_SWITCH_TYPE7;

  012e8	c7 05 e0 04 00
	00 38 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1248, 312 ; 00000138H

; 676  : 	enumSLOT.SWITCH_TYPE8 = SLOT_SWITCH_TYPE8;

  012f2	c7 05 e4 04 00
	00 39 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1252, 313 ; 00000139H

; 677  : 	enumSLOT.UNDERWATER_SWITCH1 = SLOT_UNDERWATER_SWITCH1;

  012fc	c7 05 e8 04 00
	00 3a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1256, 314 ; 0000013aH

; 678  : 	enumSLOT.UNDERWATER_SWITCH2 = SLOT_UNDERWATER_SWITCH2;

  01306	c7 05 ec 04 00
	00 3b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1260, 315 ; 0000013bH

; 679  : 	enumSLOT.TURN_SWITCH = SLOT_TURN_SWITCH;

  01310	c7 05 f0 04 00
	00 3c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1264, 316 ; 0000013cH

; 680  : 	enumSLOT.COG_SWITCH = SLOT_COG_SWITCH;

  0131a	c7 05 f4 04 00
	00 3d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1268, 317 ; 0000013dH

; 681  : 	enumSLOT.LEVER_SWITCH = SLOT_LEVER_SWITCH;

  01324	c7 05 f8 04 00
	00 3e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1272, 318 ; 0000013eH

; 682  : 	enumSLOT.JUMP_SWITCH = SLOT_JUMP_SWITCH;

  0132e	c7 05 fc 04 00
	00 3f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1276, 319 ; 0000013fH

; 683  : 	enumSLOT.CROWBAR_SWITCH = SLOT_CROWBAR_SWITCH;

  01338	c7 05 00 05 00
	00 40 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1280, 320 ; 00000140H

; 684  : 	enumSLOT.PULLEY = SLOT_PULLEY;

  01342	c7 05 04 05 00
	00 41 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1284, 321 ; 00000141H

; 685  : 	enumSLOT.DOOR_TYPE1 = SLOT_DOOR_TYPE1;

  0134c	c7 05 08 05 00
	00 42 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1288, 322 ; 00000142H

; 686  : 	enumSLOT.DOOR_TYPE2 = SLOT_DOOR_TYPE2;

  01356	c7 05 0c 05 00
	00 43 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1292, 323 ; 00000143H

; 687  : 	enumSLOT.DOOR_TYPE3 = SLOT_DOOR_TYPE3;

  01360	c7 05 10 05 00
	00 44 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1296, 324 ; 00000144H

; 688  : 	enumSLOT.DOOR_TYPE4 = SLOT_DOOR_TYPE4;

  0136a	c7 05 14 05 00
	00 45 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1300, 325 ; 00000145H

; 689  : 	enumSLOT.DOOR_TYPE5 = SLOT_DOOR_TYPE5;

  01374	c7 05 18 05 00
	00 46 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1304, 326 ; 00000146H

; 690  : 	enumSLOT.DOOR_TYPE6 = SLOT_DOOR_TYPE6;

  0137e	c7 05 1c 05 00
	00 47 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1308, 327 ; 00000147H

; 691  : 	enumSLOT.DOOR_TYPE7 = SLOT_DOOR_TYPE7;

  01388	c7 05 20 05 00
	00 48 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1312, 328 ; 00000148H

; 692  : 	enumSLOT.DOOR_TYPE8 = SLOT_DOOR_TYPE8;

  01392	c7 05 24 05 00
	00 49 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1316, 329 ; 00000149H

; 693  : 	enumSLOT.PUSHPULL_DOOR1 = SLOT_PUSHPULL_DOOR1;

  0139c	c7 05 28 05 00
	00 4a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1320, 330 ; 0000014aH

; 694  : 	enumSLOT.PUSHPULL_DOOR2 = SLOT_PUSHPULL_DOOR2;

  013a6	c7 05 2c 05 00
	00 4b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1324, 331 ; 0000014bH

; 695  : 	enumSLOT.KICK_DOOR1 = SLOT_KICK_DOOR1;

  013b0	c7 05 30 05 00
	00 4c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1328, 332 ; 0000014cH

; 696  : 	enumSLOT.KICK_DOOR2 = SLOT_KICK_DOOR2;

  013ba	c7 05 34 05 00
	00 4d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1332, 333 ; 0000014dH

; 697  : 	enumSLOT.UNDERWATER_DOOR = SLOT_UNDERWATER_DOOR;

  013c4	c7 05 38 05 00
	00 4e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1336, 334 ; 0000014eH

; 698  : 	enumSLOT.DOUBLE_DOORS = SLOT_DOUBLE_DOORS;

  013ce	c7 05 3c 05 00
	00 4f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1340, 335 ; 0000014fH

; 699  : 	enumSLOT.BRIDGE_FLAT = SLOT_BRIDGE_FLAT;

  013d8	c7 05 40 05 00
	00 50 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1344, 336 ; 00000150H

; 700  : 	enumSLOT.BRIDGE_TILT1 = SLOT_BRIDGE_TILT1;

  013e2	c7 05 44 05 00
	00 51 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1348, 337 ; 00000151H

; 701  : 	enumSLOT.BRIDGE_TILT2 = SLOT_BRIDGE_TILT2;

  013ec	c7 05 48 05 00
	00 52 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1352, 338 ; 00000152H

; 702  : 	enumSLOT.SARCOPHAGUS = SLOT_SARCOPHAGUS;

  013f6	c7 05 4c 05 00
	00 53 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1356, 339 ; 00000153H

; 703  : 	enumSLOT.SEQUENCE_DOOR1 = SLOT_SEQUENCE_DOOR1;

  01400	c7 05 50 05 00
	00 54 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1360, 340 ; 00000154H

; 704  : 	enumSLOT.SEQUENCE_SWITCH1 = SLOT_SEQUENCE_SWITCH1;

  0140a	c7 05 54 05 00
	00 55 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1364, 341 ; 00000155H

; 705  : 	enumSLOT.SEQUENCE_SWITCH2 = SLOT_SEQUENCE_SWITCH2;

  01414	c7 05 58 05 00
	00 56 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1368, 342 ; 00000156H

; 706  : 	enumSLOT.SEQUENCE_SWITCH3 = SLOT_SEQUENCE_SWITCH3;

  0141e	c7 05 5c 05 00
	00 57 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1372, 343 ; 00000157H

; 707  : 	enumSLOT.SARCOPHAGUS_CUT = SLOT_SARCOPHAGUS_CUT;

  01428	c7 05 60 05 00
	00 58 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1376, 344 ; 00000158H

; 708  : 	enumSLOT.HORUS_STATUE = SLOT_HORUS_STATUE;

  01432	c7 05 64 05 00
	00 59 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1380, 345 ; 00000159H

; 709  : 	enumSLOT.GOD_HEAD = SLOT_GOD_HEAD;

  0143c	c7 05 68 05 00
	00 5a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1384, 346 ; 0000015aH

; 710  : 	enumSLOT.SETH_DOOR = SLOT_SETH_DOOR;

  01446	c7 05 6c 05 00
	00 5b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1388, 347 ; 0000015bH

; 711  : 	enumSLOT.STATUE_PLINTH = SLOT_STATUE_PLINTH;

  01450	c7 05 70 05 00
	00 5c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1392, 348 ; 0000015cH

; 712  : 	enumSLOT.PISTOLS_ITEM = SLOT_PISTOLS_ITEM;

  0145a	c7 05 74 05 00
	00 5d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1396, 349 ; 0000015dH

; 713  : 	enumSLOT.PISTOLS_AMMO_ITEM = SLOT_PISTOLS_AMMO_ITEM;

  01464	c7 05 78 05 00
	00 5e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1400, 350 ; 0000015eH

; 714  : 	enumSLOT.UZI_ITEM = SLOT_UZI_ITEM;

  0146e	c7 05 7c 05 00
	00 5f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1404, 351 ; 0000015fH

; 715  : 	enumSLOT.UZI_AMMO_ITEM = SLOT_UZI_AMMO_ITEM;

  01478	c7 05 80 05 00
	00 60 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1408, 352 ; 00000160H

; 716  : 	enumSLOT.SHOTGUN_ITEM = SLOT_SHOTGUN_ITEM;

  01482	c7 05 84 05 00
	00 61 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1412, 353 ; 00000161H

; 717  : 	enumSLOT.SHOTGUN_AMMO1_ITEM = SLOT_SHOTGUN_AMMO1_ITEM;

  0148c	c7 05 88 05 00
	00 62 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1416, 354 ; 00000162H

; 718  : 	enumSLOT.SHOTGUN_AMMO2_ITEM = SLOT_SHOTGUN_AMMO2_ITEM;

  01496	c7 05 8c 05 00
	00 63 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1420, 355 ; 00000163H

; 719  : 	enumSLOT.CROSSBOW_ITEM = SLOT_CROSSBOW_ITEM;

  014a0	c7 05 90 05 00
	00 64 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1424, 356 ; 00000164H

; 720  : 	enumSLOT.CROSSBOW_AMMO1_ITEM = SLOT_CROSSBOW_AMMO1_ITEM;

  014aa	c7 05 94 05 00
	00 65 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1428, 357 ; 00000165H

; 721  : 	enumSLOT.CROSSBOW_AMMO2_ITEM = SLOT_CROSSBOW_AMMO2_ITEM;

  014b4	c7 05 98 05 00
	00 66 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1432, 358 ; 00000166H

; 722  : 	enumSLOT.CROSSBOW_AMMO3_ITEM = SLOT_CROSSBOW_AMMO3_ITEM;

  014be	c7 05 9c 05 00
	00 67 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1436, 359 ; 00000167H

; 723  : 	enumSLOT.CROSSBOW_BOLT = SLOT_CROSSBOW_BOLT;

  014c8	c7 05 a0 05 00
	00 68 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1440, 360 ; 00000168H

; 724  : 	enumSLOT.GRENADE_GUN_ITEM = SLOT_GRENADE_GUN_ITEM;

  014d2	c7 05 a4 05 00
	00 69 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1444, 361 ; 00000169H

; 725  : 	enumSLOT.GRENADE_GUN_AMMO1_ITEM = SLOT_GRENADE_GUN_AMMO1_ITEM;

  014dc	c7 05 a8 05 00
	00 6a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1448, 362 ; 0000016aH

; 726  : 	enumSLOT.GRENADE_GUN_AMMO2_ITEM = SLOT_GRENADE_GUN_AMMO2_ITEM;

  014e6	c7 05 ac 05 00
	00 6b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1452, 363 ; 0000016bH

; 727  : 	enumSLOT.GRENADE_GUN_AMMO3_ITEM = SLOT_GRENADE_GUN_AMMO3_ITEM;

  014f0	c7 05 b0 05 00
	00 6c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1456, 364 ; 0000016cH

; 728  : 	enumSLOT.GRENADE = SLOT_GRENADE;

  014fa	c7 05 b4 05 00
	00 6d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1460, 365 ; 0000016dH

; 729  : 	enumSLOT.SIXSHOOTER_ITEM = SLOT_SIXSHOOTER_ITEM;

  01504	c7 05 b8 05 00
	00 6e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1464, 366 ; 0000016eH

; 730  : 	enumSLOT.SIXSHOOTER_AMMO_ITEM = SLOT_SIXSHOOTER_AMMO_ITEM;

  0150e	c7 05 bc 05 00
	00 6f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1468, 367 ; 0000016fH

; 731  : 	enumSLOT.BIGMEDI_ITEM = SLOT_BIGMEDI_ITEM;

  01518	c7 05 c0 05 00
	00 70 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1472, 368 ; 00000170H

; 732  : 	enumSLOT.SMALLMEDI_ITEM = SLOT_SMALLMEDI_ITEM;

  01522	c7 05 c4 05 00
	00 71 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1476, 369 ; 00000171H

; 733  : 	enumSLOT.LASERSIGHT_ITEM = SLOT_LASERSIGHT_ITEM;

  0152c	c7 05 c8 05 00
	00 72 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1480, 370 ; 00000172H

; 734  : 	enumSLOT.BINOCULARS_ITEM = SLOT_BINOCULARS_ITEM;

  01536	c7 05 cc 05 00
	00 73 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1484, 371 ; 00000173H

; 735  : 	enumSLOT.FLARE_ITEM = SLOT_FLARE_ITEM;

  01540	c7 05 d0 05 00
	00 74 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1488, 372 ; 00000174H

; 736  : 	enumSLOT.FLARE_INV_ITEM = SLOT_FLARE_INV_ITEM;

  0154a	c7 05 d4 05 00
	00 75 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1492, 373 ; 00000175H

; 737  : 	enumSLOT.DIARY_ITEM = SLOT_DIARY_ITEM;

  01554	c7 05 d8 05 00
	00 76 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1496, 374 ; 00000176H

; 738  : 	enumSLOT.COMPASS_ITEM = SLOT_COMPASS_ITEM;

  0155e	c7 05 dc 05 00
	00 77 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1500, 375 ; 00000177H

; 739  : 	enumSLOT.MEMCARD_LOAD_INV_ITEM = SLOT_MEMCARD_LOAD_INV_ITEM;

  01568	c7 05 e0 05 00
	00 78 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1504, 376 ; 00000178H

; 740  : 	enumSLOT.MEMCARD_SAVE_INV_ITEM = SLOT_MEMCARD_SAVE_INV_ITEM;

  01572	c7 05 e4 05 00
	00 79 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1508, 377 ; 00000179H

; 741  : 	enumSLOT.PC_LOAD_INV_ITEM = SLOT_PC_LOAD_INV_ITEM;

  0157c	c7 05 e8 05 00
	00 7a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1512, 378 ; 0000017aH

; 742  : 	enumSLOT.PC_SAVE_INV_ITEM = SLOT_PC_SAVE_INV_ITEM;

  01586	c7 05 ec 05 00
	00 7b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1516, 379 ; 0000017bH

; 743  : 	enumSLOT.SMOKE_EMITTER_WHITE = SLOT_SMOKE_EMITTER_WHITE;

  01590	c7 05 f0 05 00
	00 7c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1520, 380 ; 0000017cH

; 744  : 	enumSLOT.SMOKE_EMITTER_BLACK = SLOT_SMOKE_EMITTER_BLACK;

  0159a	c7 05 f4 05 00
	00 7d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1524, 381 ; 0000017dH

; 745  : 	enumSLOT.STEAM_EMITTER = SLOT_STEAM_EMITTER;

  015a4	c7 05 f8 05 00
	00 7e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1528, 382 ; 0000017eH

; 746  : 	enumSLOT.EARTHQUAKE = SLOT_EARTHQUAKE;

  015ae	c7 05 fc 05 00
	00 7f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1532, 383 ; 0000017fH

; 747  : 	enumSLOT.BUBBLES = SLOT_BUBBLES;

  015b8	c7 05 00 06 00
	00 80 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1536, 384 ; 00000180H

; 748  : 	enumSLOT.WATERFALLMIST = SLOT_WATERFALLMIST;

  015c2	c7 05 04 06 00
	00 81 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1540, 385 ; 00000181H

; 749  : 	enumSLOT.GUNSHELL = SLOT_GUNSHELL;

  015cc	c7 05 08 06 00
	00 82 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1544, 386 ; 00000182H

; 750  : 	enumSLOT.SHOTGUNSHELL = SLOT_SHOTGUNSHELL;

  015d6	c7 05 0c 06 00
	00 83 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1548, 387 ; 00000183H

; 751  : 	enumSLOT.GUN_FLASH = SLOT_GUN_FLASH;

  015e0	c7 05 10 06 00
	00 84 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1552, 388 ; 00000184H

; 752  : 	enumSLOT.BUTTERFLY = SLOT_BUTTERFLY;

  015ea	c7 05 14 06 00
	00 85 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1556, 389 ; 00000185H

; 753  : 	enumSLOT.SPRINKLER = SLOT_SPRINKLER;

  015f4	c7 05 18 06 00
	00 86 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1560, 390 ; 00000186H

; 754  : 	enumSLOT.RED_LIGHT = SLOT_RED_LIGHT;

  015fe	c7 05 1c 06 00
	00 87 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1564, 391 ; 00000187H

; 755  : 	enumSLOT.GREEN_LIGHT = SLOT_GREEN_LIGHT;

  01608	c7 05 20 06 00
	00 88 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1568, 392 ; 00000188H

; 756  : 	enumSLOT.BLUE_LIGHT = SLOT_BLUE_LIGHT;

  01612	c7 05 24 06 00
	00 89 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1572, 393 ; 00000189H

; 757  : 	enumSLOT.AMBER_LIGHT = SLOT_AMBER_LIGHT;

  0161c	c7 05 28 06 00
	00 8a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1576, 394 ; 0000018aH

; 758  : 	enumSLOT.WHITE_LIGHT = SLOT_WHITE_LIGHT;

  01626	c7 05 2c 06 00
	00 8b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1580, 395 ; 0000018bH

; 759  : 	enumSLOT.BLINKING_LIGHT = SLOT_BLINKING_LIGHT;

  01630	c7 05 30 06 00
	00 8c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1584, 396 ; 0000018cH

; 760  : 	enumSLOT.LENS_FLARE = SLOT_LENS_FLARE;

  0163a	c7 05 34 06 00
	00 8d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1588, 397 ; 0000018dH

; 761  : 	enumSLOT.AI_GUARD = SLOT_AI_GUARD;

  01644	c7 05 38 06 00
	00 8e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1592, 398 ; 0000018eH

; 762  : 	enumSLOT.AI_AMBUSH = SLOT_AI_AMBUSH;

  0164e	c7 05 3c 06 00
	00 8f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1596, 399 ; 0000018fH

; 763  : 	enumSLOT.AI_PATROL1 = SLOT_AI_PATROL1;

  01658	c7 05 40 06 00
	00 90 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1600, 400 ; 00000190H

; 764  : 	enumSLOT.AI_MODIFY = SLOT_AI_MODIFY;

  01662	c7 05 44 06 00
	00 91 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1604, 401 ; 00000191H

; 765  : 	enumSLOT.AI_FOLLOW = SLOT_AI_FOLLOW;

  0166c	c7 05 48 06 00
	00 92 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1608, 402 ; 00000192H

; 766  : 	enumSLOT.AI_PATROL2 = SLOT_AI_PATROL2;

  01676	c7 05 4c 06 00
	00 93 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1612, 403 ; 00000193H

; 767  : 	enumSLOT.AI_X1 = SLOT_AI_X1;

  01680	c7 05 50 06 00
	00 94 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1616, 404 ; 00000194H

; 768  : 	enumSLOT.AI_X2 = SLOT_AI_X2;

  0168a	c7 05 54 06 00
	00 95 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1620, 405 ; 00000195H

; 769  : 	enumSLOT.LARA_START_POS = SLOT_LARA_START_POS;

  01694	c7 05 58 06 00
	00 96 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1624, 406 ; 00000196H

; 770  : 	enumSLOT.KILL_ALL_TRIGGERS = SLOT_KILL_ALL_TRIGGERS;

  0169e	c7 05 5c 06 00
	00 97 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1628, 407 ; 00000197H

; 771  : 	enumSLOT.TRIGGER_TRIGGERER = SLOT_TRIGGER_TRIGGERER;

  016a8	c7 05 60 06 00
	00 98 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1632, 408 ; 00000198H

; 772  : 	enumSLOT.SMASH_OBJECT1 = SLOT_SMASH_OBJECT1;

  016b2	c7 05 64 06 00
	00 99 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1636, 409 ; 00000199H

; 773  : 	enumSLOT.SMASH_OBJECT2 = SLOT_SMASH_OBJECT2;

  016bc	c7 05 68 06 00
	00 9a 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1640, 410 ; 0000019aH

; 774  : 	enumSLOT.SMASH_OBJECT3 = SLOT_SMASH_OBJECT3;

  016c6	c7 05 6c 06 00
	00 9b 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1644, 411 ; 0000019bH

; 775  : 	enumSLOT.SMASH_OBJECT4 = SLOT_SMASH_OBJECT4;

  016d0	c7 05 70 06 00
	00 9c 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1648, 412 ; 0000019cH

; 776  : 	enumSLOT.SMASH_OBJECT5 = SLOT_SMASH_OBJECT5;

  016da	c7 05 74 06 00
	00 9d 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1652, 413 ; 0000019dH

; 777  : 	enumSLOT.SMASH_OBJECT6 = SLOT_SMASH_OBJECT6;

  016e4	c7 05 78 06 00
	00 9e 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1656, 414 ; 0000019eH

; 778  : 	enumSLOT.SMASH_OBJECT7 = SLOT_SMASH_OBJECT7;

  016ee	c7 05 7c 06 00
	00 9f 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1660, 415 ; 0000019fH

; 779  : 	enumSLOT.SMASH_OBJECT8 = SLOT_SMASH_OBJECT8;

  016f8	c7 05 80 06 00
	00 a0 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1664, 416 ; 000001a0H

; 780  : 	enumSLOT.MESHSWAP1 = SLOT_MESHSWAP1;

  01702	c7 05 84 06 00
	00 a1 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1668, 417 ; 000001a1H

; 781  : 	enumSLOT.MESHSWAP2 = SLOT_MESHSWAP2;

  0170c	c7 05 88 06 00
	00 a2 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1672, 418 ; 000001a2H

; 782  : 	enumSLOT.MESHSWAP3 = SLOT_MESHSWAP3;

  01716	c7 05 8c 06 00
	00 a3 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1676, 419 ; 000001a3H

; 783  : 	enumSLOT.DEATH_SLIDE = SLOT_DEATH_SLIDE;

  01720	c7 05 90 06 00
	00 a4 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1680, 420 ; 000001a4H

; 784  : 	enumSLOT.BODY_PART = SLOT_BODY_PART;

  0172a	c7 05 94 06 00
	00 a5 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1684, 421 ; 000001a5H

; 785  : 	enumSLOT.CAMERA_TARGET = SLOT_CAMERA_TARGET;

  01734	c7 05 98 06 00
	00 a6 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1688, 422 ; 000001a6H

; 786  : 	enumSLOT.WATERFALL1 = SLOT_WATERFALL1;

  0173e	c7 05 9c 06 00
	00 a7 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1692, 423 ; 000001a7H

; 787  : 	enumSLOT.WATERFALL2 = SLOT_WATERFALL2;

  01748	c7 05 a0 06 00
	00 a8 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1696, 424 ; 000001a8H

; 788  : 	enumSLOT.WATERFALL3 = SLOT_WATERFALL3;

  01752	c7 05 a4 06 00
	00 a9 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1700, 425 ; 000001a9H

; 789  : 	enumSLOT.PLANET_EFFECT = SLOT_PLANET_EFFECT;

  0175c	c7 05 a8 06 00
	00 aa 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1704, 426 ; 000001aaH

; 790  : 	enumSLOT.ANIMATING1 = SLOT_ANIMATING1;

  01766	c7 05 ac 06 00
	00 ab 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1708, 427 ; 000001abH

; 791  : 	enumSLOT.ANIMATING1_MIP = SLOT_ANIMATING1_MIP;

  01770	c7 05 b0 06 00
	00 ac 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1712, 428 ; 000001acH

; 792  : 	enumSLOT.ANIMATING2 = SLOT_ANIMATING2;

  0177a	c7 05 b4 06 00
	00 ad 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1716, 429 ; 000001adH

; 793  : 	enumSLOT.ANIMATING2_MIP = SLOT_ANIMATING2_MIP;

  01784	c7 05 b8 06 00
	00 ae 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1720, 430 ; 000001aeH

; 794  : 	enumSLOT.ANIMATING3 = SLOT_ANIMATING3;

  0178e	c7 05 bc 06 00
	00 af 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1724, 431 ; 000001afH

; 795  : 	enumSLOT.ANIMATING3_MIP = SLOT_ANIMATING3_MIP;

  01798	c7 05 c0 06 00
	00 b0 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1728, 432 ; 000001b0H

; 796  : 	enumSLOT.ANIMATING4 = SLOT_ANIMATING4;

  017a2	c7 05 c4 06 00
	00 b1 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1732, 433 ; 000001b1H

; 797  : 	enumSLOT.ANIMATING4_MIP = SLOT_ANIMATING4_MIP;

  017ac	c7 05 c8 06 00
	00 b2 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1736, 434 ; 000001b2H

; 798  : 	enumSLOT.ANIMATING5 = SLOT_ANIMATING5;

  017b6	c7 05 cc 06 00
	00 b3 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1740, 435 ; 000001b3H

; 799  : 	enumSLOT.ANIMATING5_MIP = SLOT_ANIMATING5_MIP;

  017c0	c7 05 d0 06 00
	00 b4 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1744, 436 ; 000001b4H

; 800  : 	enumSLOT.ANIMATING6 = SLOT_ANIMATING6;

  017ca	c7 05 d4 06 00
	00 b5 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1748, 437 ; 000001b5H

; 801  : 	enumSLOT.ANIMATING6_MIP = SLOT_ANIMATING6_MIP;

  017d4	c7 05 d8 06 00
	00 b6 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1752, 438 ; 000001b6H

; 802  : 	enumSLOT.ANIMATING7 = SLOT_ANIMATING7;

  017de	c7 05 dc 06 00
	00 b7 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1756, 439 ; 000001b7H

; 803  : 	enumSLOT.ANIMATING7_MIP = SLOT_ANIMATING7_MIP;

  017e8	c7 05 e0 06 00
	00 b8 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1760, 440 ; 000001b8H

; 804  : 	enumSLOT.ANIMATING8 = SLOT_ANIMATING8;

  017f2	c7 05 e4 06 00
	00 b9 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1764, 441 ; 000001b9H

; 805  : 	enumSLOT.ANIMATING8_MIP = SLOT_ANIMATING8_MIP;

  017fc	c7 05 e8 06 00
	00 ba 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1768, 442 ; 000001baH

; 806  : 	enumSLOT.ANIMATING9 = SLOT_ANIMATING9;

  01806	c7 05 ec 06 00
	00 bb 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1772, 443 ; 000001bbH

; 807  : 	enumSLOT.ANIMATING9_MIP = SLOT_ANIMATING9_MIP;

  01810	c7 05 f0 06 00
	00 bc 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1776, 444 ; 000001bcH

; 808  : 	enumSLOT.ANIMATING10 = SLOT_ANIMATING10;

  0181a	c7 05 f4 06 00
	00 bd 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1780, 445 ; 000001bdH

; 809  : 	enumSLOT.ANIMATING10_MIP = SLOT_ANIMATING10_MIP;

  01824	c7 05 f8 06 00
	00 be 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1784, 446 ; 000001beH

; 810  : 	enumSLOT.ANIMATING11 = SLOT_ANIMATING11;

  0182e	c7 05 fc 06 00
	00 bf 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1788, 447 ; 000001bfH

; 811  : 	enumSLOT.ANIMATING11_MIP = SLOT_ANIMATING11_MIP;

  01838	c7 05 00 07 00
	00 c0 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1792, 448 ; 000001c0H

; 812  : 	enumSLOT.ANIMATING12 = SLOT_ANIMATING12;

  01842	c7 05 04 07 00
	00 c1 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1796, 449 ; 000001c1H

; 813  : 	enumSLOT.ANIMATING12_MIP = SLOT_ANIMATING12_MIP;

  0184c	c7 05 08 07 00
	00 c2 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1800, 450 ; 000001c2H

; 814  : 	enumSLOT.ANIMATING13 = SLOT_ANIMATING13;

  01856	c7 05 0c 07 00
	00 c3 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1804, 451 ; 000001c3H

; 815  : 	enumSLOT.ANIMATING13_MIP = SLOT_ANIMATING13_MIP;

  01860	c7 05 10 07 00
	00 c4 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1808, 452 ; 000001c4H

; 816  : 	enumSLOT.ANIMATING14 = SLOT_ANIMATING14;

  0186a	c7 05 14 07 00
	00 c5 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1812, 453 ; 000001c5H

; 817  : 	enumSLOT.ANIMATING14_MIP = SLOT_ANIMATING14_MIP;

  01874	c7 05 18 07 00
	00 c6 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1816, 454 ; 000001c6H

; 818  : 	enumSLOT.ANIMATING15 = SLOT_ANIMATING15;

  0187e	c7 05 1c 07 00
	00 c7 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1820, 455 ; 000001c7H

; 819  : 	enumSLOT.ANIMATING15_MIP = SLOT_ANIMATING15_MIP;

  01888	c7 05 20 07 00
	00 c8 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1824, 456 ; 000001c8H

; 820  : 	enumSLOT.ANIMATING16 = SLOT_ANIMATING16;

  01892	c7 05 24 07 00
	00 c9 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1828, 457 ; 000001c9H

; 821  : 	enumSLOT.ANIMATING16_MIP = SLOT_ANIMATING16_MIP;

  0189c	c7 05 28 07 00
	00 ca 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1832, 458 ; 000001caH

; 822  : 	enumSLOT.HORIZON = SLOT_HORIZON;

  018a6	c7 05 2c 07 00
	00 cb 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1836, 459 ; 000001cbH

; 823  : 	enumSLOT.SKY_GRAPHICS = SLOT_SKY_GRAPHICS;

  018b0	c7 05 30 07 00
	00 cc 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1840, 460 ; 000001ccH

; 824  : 	enumSLOT.BINOCULAR_GRAPHICS = SLOT_BINOCULAR_GRAPHICS;

  018ba	c7 05 34 07 00
	00 cd 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1844, 461 ; 000001cdH

; 825  : 	enumSLOT.TARGET_GRAPHICS = SLOT_TARGET_GRAPHICS;

  018c4	c7 05 38 07 00
	00 ce 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1848, 462 ; 000001ceH

; 826  : 	enumSLOT.DEFAULT_SPRITES = SLOT_DEFAULT_SPRITES;

  018ce	c7 05 3c 07 00
	00 cf 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1852, 463 ; 000001cfH

; 827  : 	enumSLOT.MISC_SPRITES = SLOT_MISC_SPRITES;

  018d8	c7 05 40 07 00
	00 d0 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1856, 464 ; 000001d0H

; 828  : 	enumSLOT.MOTOR_BOAT = SLOT_MOTOR_BOAT;

  018e2	c7 05 44 07 00
	00 d1 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1860, 465 ; 000001d1H

; 829  : 	enumSLOT.MOTOR_BOAT_LARA = SLOT_MOTOR_BOAT_LARA;

  018ec	c7 05 48 07 00
	00 d2 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1864, 466 ; 000001d2H

; 830  : 	enumSLOT.RUBBER_BOAT = SLOT_RUBBER_BOAT;

  018f6	c7 05 4c 07 00
	00 d3 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1868, 467 ; 000001d3H

; 831  : 	enumSLOT.RUBBER_BOAT_LARA = SLOT_RUBBER_BOAT_LARA;

  01900	c7 05 50 07 00
	00 d4 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1872, 468 ; 000001d4H

; 832  : 	enumSLOT.MOTORBIKE_LARA = SLOT_MOTORBIKE_LARA;

  0190a	c7 05 54 07 00
	00 d5 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1876, 469 ; 000001d5H

; 833  : 	enumSLOT.FONT_GRAPHICS = SLOT_FONT_GRAPHICS;

  01914	c7 05 58 07 00
	00 d6 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1880, 470 ; 000001d6H

; 834  : 	enumSLOT.PARALLEL_BARS = SLOT_PARALLEL_BARS;

  0191e	c7 05 5c 07 00
	00 d7 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1884, 471 ; 000001d7H

; 835  : 	enumSLOT.PANEL_BORDER = SLOT_PANEL_BORDER;

  01928	c7 05 60 07 00
	00 d8 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1888, 472 ; 000001d8H

; 836  : 	enumSLOT.PANEL_MIDDLE = SLOT_PANEL_MIDDLE;

  01932	c7 05 64 07 00
	00 d9 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1892, 473 ; 000001d9H

; 837  : 	enumSLOT.PANEL_CORNER = SLOT_PANEL_CORNER;

  0193c	c7 05 68 07 00
	00 da 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1896, 474 ; 000001daH

; 838  : 	enumSLOT.PANEL_DIAGONAL = SLOT_PANEL_DIAGONAL;

  01946	c7 05 6c 07 00
	00 db 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1900, 475 ; 000001dbH

; 839  : 	enumSLOT.PANEL_STRIP = SLOT_PANEL_STRIP;

  01950	c7 05 70 07 00
	00 dc 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1904, 476 ; 000001dcH

; 840  : 	enumSLOT.PANEL_HALF_BORDER1 = SLOT_PANEL_HALF_BORDER1;

  0195a	c7 05 74 07 00
	00 dd 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1908, 477 ; 000001ddH

; 841  : 	enumSLOT.PANEL_HALF_BORDER2 = SLOT_PANEL_HALF_BORDER2;

  01964	c7 05 78 07 00
	00 de 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1912, 478 ; 000001deH

; 842  : 	enumSLOT.PANEL_MIDDLE_CORNER = SLOT_PANEL_MIDDLE_CORNER;

  0196e	c7 05 7c 07 00
	00 df 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1916, 479 ; 000001dfH

; 843  : 	enumSLOT.TIGHT_ROPE = SLOT_TIGHT_ROPE;

  01978	c7 05 80 07 00
	00 e0 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1920, 480 ; 000001e0H

; 844  : 	enumSLOT.LASER_HEAD = SLOT_LASER_HEAD;

  01982	c7 05 84 07 00
	00 e1 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1924, 481 ; 000001e1H

; 845  : 	enumSLOT.LASER_HEAD_BASE = SLOT_LASER_HEAD_BASE;

  0198c	c7 05 88 07 00
	00 e2 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1928, 482 ; 000001e2H

; 846  : 	enumSLOT.LASER_HEAD_TENTACLE = SLOT_LASER_HEAD_TENTACLE;

  01996	c7 05 8c 07 00
	00 e3 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1932, 483 ; 000001e3H

; 847  : 	enumSLOT.HYDRA = SLOT_HYDRA;

  019a0	c7 05 90 07 00
	00 e4 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1936, 484 ; 000001e4H

; 848  : 	enumSLOT.HYDRA_MISSILE = SLOT_HYDRA_MISSILE;

  019aa	c7 05 94 07 00
	00 e5 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1940, 485 ; 000001e5H

; 849  : 	enumSLOT.ENEMY_SUB_MARINE = SLOT_ENEMY_SUB_MARINE;

  019b4	c7 05 98 07 00
	00 e6 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1944, 486 ; 000001e6H

; 850  : 	enumSLOT.ENEMY_SUB_MARINE_MIP = SLOT_ENEMY_SUB_MARINE_MIP;

  019be	c7 05 9c 07 00
	00 e7 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1948, 487 ; 000001e7H

; 851  : 	enumSLOT.SUB_MARINE_MISSILE = SLOT_SUB_MARINE_MISSILE;

  019c8	c7 05 a0 07 00
	00 e8 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1952, 488 ; 000001e8H

; 852  : 	enumSLOT.FROG_MAN = SLOT_FROG_MAN;

  019d2	c7 05 a4 07 00
	00 e9 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1956, 489 ; 000001e9H

; 853  : 	enumSLOT.FROG_MAN_HARPOON = SLOT_FROG_MAN_HARPOON;

  019dc	c7 05 a8 07 00
	00 ea 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1960, 490 ; 000001eaH

; 854  : 	enumSLOT.FISH_EMITTER = SLOT_FISH_EMITTER;

  019e6	c7 05 ac 07 00
	00 eb 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1964, 491 ; 000001ebH

; 855  : 	enumSLOT.KAYAK = SLOT_KAYAK;

  019f0	c7 05 b0 07 00
	00 ec 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1968, 492 ; 000001ecH

; 856  : 	enumSLOT.KAYAK_LARA = SLOT_KAYAK_LARA;

  019fa	c7 05 b4 07 00
	00 ed 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1972, 493 ; 000001edH

; 857  : 	enumSLOT.CUSTOM_SPRITES = SLOT_CUSTOM_SPRITES;

  01a04	c7 05 b8 07 00
	00 ee 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1976, 494 ; 000001eeH

; 858  : 	enumSLOT.BRIDGE_TILT3 = SLOT_BRIDGE_TILT3;

  01a0e	c7 05 bc 07 00
	00 ef 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1980, 495 ; 000001efH

; 859  : 	enumSLOT.BRIDGE_TILT4 = SLOT_BRIDGE_TILT4;

  01a18	c7 05 c0 07 00
	00 f0 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1984, 496 ; 000001f0H

; 860  : 	enumSLOT.BRIDGE_CUSTOM = SLOT_BRIDGE_CUSTOM;

  01a22	c7 05 c4 07 00
	00 f1 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1988, 497 ; 000001f1H

; 861  : 	enumSLOT.ROBOT_CLEANER = SLOT_ROBOT_CLEANER;

  01a2c	c7 05 c8 07 00
	00 f2 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1992, 498 ; 000001f2H

; 862  : 	enumSLOT.ROBOT_STAR_WARS = SLOT_ROBOT_STAR_WARS;

  01a36	c7 05 cc 07 00
	00 f3 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+1996, 499 ; 000001f3H

; 863  : 	enumSLOT.MECH_WARRIOR = SLOT_MECH_WARRIOR;

  01a40	c7 05 d0 07 00
	00 f4 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2000, 500 ; 000001f4H

; 864  : 	enumSLOT.MECH_WARRIOR_LARA = SLOT_MECH_WARRIOR_LARA;

  01a4a	c7 05 d4 07 00
	00 f5 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2004, 501 ; 000001f5H

; 865  : 	enumSLOT.UW_PROPULSOR = SLOT_UW_PROPULSOR;

  01a54	c7 05 d8 07 00
	00 f6 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2008, 502 ; 000001f6H

; 866  : 	enumSLOT.UW_PROPULSOR_LARA = SLOT_UW_PROPULSOR_LARA;

  01a5e	c7 05 dc 07 00
	00 f7 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2012, 503 ; 000001f7H

; 867  : 	enumSLOT.MINE_CART = SLOT_MINE_CART;

  01a68	c7 05 e0 07 00
	00 f8 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2016, 504 ; 000001f8H

; 868  : 	enumSLOT.MINE_CART_LARA = SLOT_MINE_CART_LARA;

  01a72	c7 05 e4 07 00
	00 f9 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2020, 505 ; 000001f9H

; 869  : 	enumSLOT.NEW_SLOT5 = SLOT_NEW_SLOT5;

  01a7c	c7 05 e8 07 00
	00 fa 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2024, 506 ; 000001faH

; 870  : 	enumSLOT.NEW_SLOT6 = SLOT_NEW_SLOT6;

  01a86	c7 05 ec 07 00
	00 fb 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2028, 507 ; 000001fbH

; 871  : 	enumSLOT.NEW_SLOT7 = SLOT_NEW_SLOT7;

  01a90	c7 05 f0 07 00
	00 fc 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2032, 508 ; 000001fcH

; 872  : 	enumSLOT.NEW_SLOT8 = SLOT_NEW_SLOT8;

  01a9a	c7 05 f4 07 00
	00 fd 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2036, 509 ; 000001fdH

; 873  : 	enumSLOT.NEW_SLOT9 = SLOT_NEW_SLOT9;

  01aa4	c7 05 f8 07 00
	00 fe 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2040, 510 ; 000001feH

; 874  : 	enumSLOT.NEW_SLOT10 = SLOT_NEW_SLOT10;

  01aae	c7 05 fc 07 00
	00 ff 01 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2044, 511 ; 000001ffH

; 875  : 	enumSLOT.NEW_SLOT11 = SLOT_NEW_SLOT11;

  01ab8	c7 05 00 08 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2048, 512 ; 00000200H

; 876  : 	enumSLOT.NEW_SLOT12 = SLOT_NEW_SLOT12;

  01ac2	c7 05 04 08 00
	00 01 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2052, 513 ; 00000201H

; 877  : 	enumSLOT.NEW_SLOT13 = SLOT_NEW_SLOT13;

  01acc	c7 05 08 08 00
	00 02 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2056, 514 ; 00000202H

; 878  : 	enumSLOT.NEW_SLOT14 = SLOT_NEW_SLOT14;

  01ad6	c7 05 0c 08 00
	00 03 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2060, 515 ; 00000203H

; 879  : 	enumSLOT.NEW_SLOT15 = SLOT_NEW_SLOT15;

  01ae0	c7 05 10 08 00
	00 04 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2064, 516 ; 00000204H

; 880  : 	enumSLOT.NEW_SLOT16 = SLOT_NEW_SLOT16;

  01aea	c7 05 14 08 00
	00 05 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2068, 517 ; 00000205H

; 881  : 	enumSLOT.NEW_SLOT17 = SLOT_NEW_SLOT17;

  01af4	c7 05 18 08 00
	00 06 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2072, 518 ; 00000206H

; 882  : 	enumSLOT.NEW_SLOT18 = SLOT_NEW_SLOT18;

  01afe	c7 05 1c 08 00
	00 07 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2076, 519 ; 00000207H

; 883  : 	enumSLOT.NUMBER_OBJECTS = SLOT_NUMBER_OBJECTS;

  01b08	c7 05 20 08 00
	00 08 02 00 00	 mov	 DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2080, 520 ; 00000208H

; 884  : 
; 885  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumGET----------------------
; 886  : 	enumGET.LARA = GET_LARA;

  01b12	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A, 0

; 887  : 	enumGET.ITEM = GET_ITEM;

  01b1c	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+4, 1

; 888  : 	enumGET.STATIC = GET_STATIC;

  01b26	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+8, 2

; 889  : 	enumGET.ROOM = GET_ROOM;

  01b30	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+12, 3

; 890  : 	enumGET.ITEM_COLL_BOX = GET_ITEM_COLL_BOX;

  01b3a	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+16, 4

; 891  : 	enumGET.STATIC_COLL_BOX = GET_STATIC_COLL_BOX;

  01b44	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+20, 5

; 892  : 	enumGET.STATIC_VIEW_BOX = GET_STATIC_VIEW_BOX;

  01b4e	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+24, 6

; 893  : 	enumGET.DOOR_OF_ROOM = GET_DOOR_OF_ROOM;

  01b58	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+28, 7

; 894  : 	enumGET.INFO_LARA = GET_INFO_LARA;

  01b62	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+32, 8

; 895  : 	enumGET.MY_PARAMETER_COMMAND = GET_MY_PARAMETER_COMMAND;

  01b6c	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+36, 9

; 896  : 	enumGET.MY_CUSTOMIZE_COMMAND = GET_MY_CUSTOMIZE_COMMAND;

  01b76	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+40, 10 ; 0000000aH

; 897  : 	enumGET.INPUT = GET_INPUT;

  01b80	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+44, 11 ; 0000000bH

; 898  : 	enumGET.STRINGNG = GET_STRINGNG;

  01b8a	c7 05 30 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+48, 12 ; 0000000cH

; 899  : 	enumGET.STRING = GET_STRING;

  01b94	c7 05 34 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+52, 13 ; 0000000dH

; 900  : 	enumGET.BIG_NUMBER = GET_BIG_NUMBER;

  01b9e	c7 05 38 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+56, 14 ; 0000000eH

; 901  : 	enumGET.SCRIPT_SETTINGS = GET_SCRIPT_SETTINGS;

  01ba8	c7 05 3c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+60, 15 ; 0000000fH

; 902  : 	enumGET.PROGRESSIVE_ACTION = GET_PROGRESSIVE_ACTION;

  01bb2	c7 05 40 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+64, 16 ; 00000010H

; 903  : 	enumGET.AI_ITEM = GET_AI_ITEM;

  01bbc	c7 05 44 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+68, 17 ; 00000011H

; 904  : 	enumGET.LIGHT = GET_LIGHT;

  01bc6	c7 05 48 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+72, 18 ; 00000012H

; 905  : 	enumGET.CAMERA = GET_CAMERA;

  01bd0	c7 05 4c 00 00
	00 13 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+76, 19 ; 00000013H

; 906  : 	enumGET.CAMERA_FLY = GET_CAMERA_FLY;

  01bda	c7 05 50 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+80, 20 ; 00000014H

; 907  : 	enumGET.COLOR_RGB = GET_COLOR_RGB;

  01be4	c7 05 54 00 00
	00 15 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+84, 21 ; 00000015H

; 908  : 	enumGET.GAME_INFO = GET_GAME_INFO;

  01bee	c7 05 58 00 00
	00 16 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+88, 22 ; 00000016H

; 909  : 	enumGET.SLOT = GET_SLOT;

  01bf8	c7 05 5c 00 00
	00 17 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+92, 23 ; 00000017H

; 910  : 	enumGET.INVENTORY = GET_INVENTORY;

  01c02	c7 05 60 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+96, 24 ; 00000018H

; 911  : 	enumGET.ANIMATION = GET_ANIMATION;

  01c0c	c7 05 64 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+100, 25 ; 00000019H

; 912  : 	enumGET.INFO_ITEM = GET_INFO_ITEM;

  01c16	c7 05 68 00 00
	00 1a 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+104, 26 ; 0000001aH

; 913  : 	enumGET.VARIABLES = GET_VARIABLES;

  01c20	c7 05 6c 00 00
	00 1b 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+108, 27 ; 0000001bH

; 914  : 	enumGET.FLIPMAPS = GET_FLIPMAPS;

  01c2a	c7 05 70 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?enumGET@@3UStrEnumGET@@A+112, 28 ; 0000001cH

; 915  : 
; 916  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSKIP----------------------
; 917  : 	enumSKIP.NONE = SKIP_NONE;

  01c34	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A, 0

; 918  : 	enumSKIP.FIXED_CAMERA = SKIP_FIXED_CAMERA;

  01c3e	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+4, 1

; 919  : 	enumSKIP.FLY_CAMERA = SKIP_FLY_CAMERA;

  01c48	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+8, 2

; 920  : 	enumSKIP.LOADING_LEVEL = SKIP_LOADING_LEVEL;

  01c52	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+12, 4

; 921  : 	enumSKIP.FADE = SKIP_FADE;

  01c5c	c7 05 10 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+16, 8

; 922  : 	enumSKIP.TITLE_LEVEL = SKIP_TITLE_LEVEL;

  01c66	c7 05 14 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+20, 16 ; 00000010H

; 923  : 	enumSKIP.GRAY_SCREEN = SKIP_GRAY_SCREEN;

  01c70	c7 05 18 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+24, 32 ; 00000020H

; 924  : 	enumSKIP.NO_VIEW_OGGETTI = SKIP_NO_VIEW_OGGETTI;

  01c7a	c7 05 1c 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+28, 64 ; 00000040H

; 925  : 	enumSKIP.BINOCULARS = SKIP_BINOCULARS;

  01c84	c7 05 20 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+32, 128 ; 00000080H

; 926  : 	enumSKIP.LASER_SIGHT = SKIP_LASER_SIGHT;

  01c8e	c7 05 24 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+36, 256 ; 00000100H

; 927  : 	enumSKIP.FULL_IMAGE = SKIP_FULL_IMAGE;

  01c98	c7 05 28 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+40, 512 ; 00000200H

; 928  : 
; 929  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFL2----------------------
; 930  : 	enumFL2.OVER_MINE_TRIGGER = FL2_OVER_MINE_TRIGGER;

  01ca2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A, 1

; 931  : 	enumFL2.IS_BURNING = FL2_IS_BURNING;

  01cac	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+4, 2

; 932  : 	enumFL2.IS_DUCK = FL2_IS_DUCK;

  01cb6	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+8, 4

; 933  : 	enumFL2.IS_INVULNERABLE = FL2_IS_INVULNERABLE;

  01cc0	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+12, 8

; 934  : 	enumFL2.IS_USING_LASER_SIGHT_OR_BINOCULARS = FL2_IS_USING_LASER_SIGHT_OR_BINOCULARS;

  01cca	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+16, 16 ; 00000010H

; 935  : 	enumFL2.TORCH_IS_BURNING = FL2_TORCH_IS_BURNING;

  01cd4	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+20, 32 ; 00000020H

; 936  : 	enumFL2.IS_CLIMBING = FL2_IS_CLIMBING;

  01cde	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+24, 64 ; 00000040H

; 937  : 
; 938  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumHOLD----------------------
; 939  : 	enumHOLD.PISTOLS = HOLD_PISTOLS;

  01ce8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A, 1

; 940  : 	enumHOLD.REVOLVER = HOLD_REVOLVER;

  01cf2	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+4, 2

; 941  : 	enumHOLD.UZI = HOLD_UZI;

  01cfc	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+8, 3

; 942  : 	enumHOLD.SHOTGUN = HOLD_SHOTGUN;

  01d06	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+12, 4

; 943  : 	enumHOLD.GRENADEGUN = HOLD_GRENADEGUN;

  01d10	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+16, 5

; 944  : 	enumHOLD.CROSSBOW = HOLD_CROSSBOW;

  01d1a	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+20, 6

; 945  : 	enumHOLD.FLARE = HOLD_FLARE;

  01d24	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+24, 7

; 946  : 	enumHOLD.OUT_TORCH = HOLD_OUT_TORCH;

  01d2e	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+28, 8

; 947  : 	enumHOLD.FIRED_TORCH = HOLD_FIRED_TORCH;

  01d38	c7 05 20 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+32, 9

; 948  : 	enumHOLD.JEEP = HOLD_JEEP;

  01d42	c7 05 24 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+36, 10 ; 0000000aH

; 949  : 	enumHOLD.SIDECAR = HOLD_SIDECAR;

  01d4c	c7 05 28 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+40, 11 ; 0000000bH

; 950  : 	enumHOLD.RUBBER_BOAT = HOLD_RUBBER_BOAT;

  01d56	c7 05 2c 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+44, 12 ; 0000000cH

; 951  : 	enumHOLD.MOTOR_BOAT = HOLD_MOTOR_BOAT;

  01d60	c7 05 30 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+48, 13 ; 0000000dH

; 952  : 	enumHOLD.ROPE = HOLD_ROPE;

  01d6a	c7 05 34 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+52, 14 ; 0000000eH

; 953  : 	enumHOLD.POLE = HOLD_POLE;

  01d74	c7 05 38 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+56, 15 ; 0000000fH

; 954  : 	enumHOLD.ANY_TORCH = HOLD_ANY_TORCH;

  01d7e	c7 05 3c 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+60, 16 ; 00000010H

; 955  : 	enumHOLD.KAYAK = HOLD_KAYAK;

  01d88	c7 05 40 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+64, 17 ; 00000011H

; 956  : 
; 957  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumLLF----------------------
; 958  : 	enumLLF.GROUND = LLF_GROUND;

  01d92	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumLLF@@3UStrEnumLLF@@A, 0

; 959  : 	enumLLF.UNDERWATER = LLF_UNDERWATER;

  01d9c	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+4, 1

; 960  : 	enumLLF.FLOATING = LLF_FLOATING;

  01da6	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+8, 2

; 961  : 	enumLLF.DOZY = LLF_DOZY;

  01db0	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+12, 3

; 962  : 	enumLLF.LOW_WATER = LLF_LOW_WATER;

  01dba	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+16, 4

; 963  : 
; 964  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSCANF----------------------
; 965  : 	enumSCANF.HEAVY = SCANF_HEAVY;

  01dc4	c7 05 00 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A, 256 ; 00000100H

; 966  : 	enumSCANF.TEMP_ONE_SHOT = SCANF_TEMP_ONE_SHOT;

  01dce	c7 05 04 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+4, 512 ; 00000200H

; 967  : 	enumSCANF.BUTTON_ONE_SHOT = SCANF_BUTTON_ONE_SHOT;

  01dd8	c7 05 08 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+8, 1024 ; 00000400H

; 968  : 	enumSCANF.YET_TO_PERFORM = SCANF_YET_TO_PERFORM;

  01de2	c7 05 0c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+12, 2048 ; 00000800H

; 969  : 	enumSCANF.SCRIPT_TRIGGER = SCANF_SCRIPT_TRIGGER;

  01dec	c7 05 10 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+16, 4096 ; 00001000H

; 970  : 	enumSCANF.DIRECT_CALL = SCANF_DIRECT_CALL;

  01df6	c7 05 14 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+20, 8192 ; 00002000H

; 971  : 	enumSCANF.FLOOR_DATA = SCANF_FLOOR_DATA;

  01e00	c7 05 18 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+24, 16384 ; 00004000H

; 972  : 	enumSCANF.ANIM_COMMAND = SCANF_ANIM_COMMAND;

  01e0a	c7 05 1c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+28, 32768 ; 00008000H

; 973  : 
; 974  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumMESH----------------------
; 975  : 	enumMESH.BUTT = MESH_BUTT;

  01e14	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A, 0

; 976  : 	enumMESH.RIGHT_THIGH = MESH_RIGHT_THIGH;

  01e1e	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+4, 1

; 977  : 	enumMESH.RIGHT_CALF = MESH_RIGHT_CALF;

  01e28	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+8, 2

; 978  : 	enumMESH.RIGHT_FOOT = MESH_RIGHT_FOOT;

  01e32	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+12, 3

; 979  : 	enumMESH.LEFT_THIGH = MESH_LEFT_THIGH;

  01e3c	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+16, 4

; 980  : 	enumMESH.LEFT_CALF = MESH_LEFT_CALF;

  01e46	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+20, 5

; 981  : 	enumMESH.LEFT_FOOT = MESH_LEFT_FOOT;

  01e50	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+24, 6

; 982  : 	enumMESH.CHEST = MESH_CHEST;

  01e5a	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+28, 7

; 983  : 	enumMESH.RIGHT_ARM = MESH_RIGHT_ARM;

  01e64	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+32, 8

; 984  : 	enumMESH.RIGHT_FOREARM = MESH_RIGHT_FOREARM;

  01e6e	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+36, 9

; 985  : 	enumMESH.RIGHT_HAND = MESH_RIGHT_HAND;

  01e78	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+40, 10 ; 0000000aH

; 986  : 	enumMESH.LEFT_ARM = MESH_LEFT_ARM;

  01e82	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+44, 11 ; 0000000bH

; 987  : 	enumMESH.LEFT_FOREARM = MESH_LEFT_FOREARM;

  01e8c	c7 05 30 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+48, 12 ; 0000000cH

; 988  : 	enumMESH.LEFT_HAND = MESH_LEFT_HAND;

  01e96	c7 05 34 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+52, 13 ; 0000000dH

; 989  : 	enumMESH.HEAD = MESH_HEAD;

  01ea0	c7 05 38 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumMESH@@3UStrEnumMESH@@A+56, 14 ; 0000000eH

; 990  : 
; 991  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumTRET----------------------
; 992  : 	enumTRET.PERFORM_ALWAYS = TRET_PERFORM_ALWAYS;

  01eaa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumTRET@@3UStrEnumTRET@@A, 0

; 993  : 	enumTRET.PERFORM_ONCE_AND_GO = TRET_PERFORM_ONCE_AND_GO;

  01eb4	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+4, 1

; 994  : 	enumTRET.PERFORM_NEVER_MORE = TRET_PERFORM_NEVER_MORE;

  01ebe	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+8, 2

; 995  : 	enumTRET.EXECUTE_ORIGINAL = TRET_EXECUTE_ORIGINAL;

  01ec8	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+12, 3

; 996  : 
; 997  : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCTRET----------------------
; 998  : 	enumCTRET.IS_TRUE = CTRET_IS_TRUE;

  01ed2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A, 1

; 999  : 	enumCTRET.EXTRA_PARAM = CTRET_EXTRA_PARAM;

  01edc	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+4, 2

; 1000 : 	enumCTRET.ON_MOVEABLE = CTRET_ON_MOVEABLE;

  01ee6	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+8, 4

; 1001 : 	enumCTRET.PERFORM_ALWAYS = CTRET_PERFORM_ALWAYS;

  01ef0	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+12, 8

; 1002 : 	enumCTRET.ONLY_ONCE_ON_TRUE = CTRET_ONLY_ONCE_ON_TRUE;

  01efa	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+16, 16 ; 00000010H

; 1003 : 	enumCTRET.NEVER_MORE_ON_TRUE = CTRET_NEVER_MORE_ON_TRUE;

  01f04	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+20, 32 ; 00000020H

; 1004 : 	enumCTRET.PERFORM_ONCE_AND_GO = CTRET_PERFORM_ONCE_AND_GO;

  01f0e	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+24, 64 ; 00000040H

; 1005 : 	enumCTRET.EXECUTE_ORIGINAL = CTRET_EXECUTE_ORIGINAL;

  01f18	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumCTRET@@3UStrEnumCTRET@@A+28, 128 ; 00000080H

; 1006 : 
; 1007 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSRET----------------------
; 1008 : 	enumSRET.OK = SRET_OK;

  01f22	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSRET@@3UStrEnumSRET@@A, 0

; 1009 : 	enumSRET.SKIP_ORIGINAL = SRET_SKIP_ORIGINAL;

  01f2c	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSRET@@3UStrEnumSRET@@A+4, 1

; 1010 : 	enumSRET.SKIP_TRNG_CODE = SRET_SKIP_TRNG_CODE;

  01f36	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSRET@@3UStrEnumSRET@@A+8, 2

; 1011 : 
; 1012 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumJOINT----------------------
; 1013 : 	enumJOINT.LEFT_THIGH = JOINT_LEFT_THIGH;

  01f40	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A, 1

; 1014 : 	enumJOINT.LEFT_KNEE = JOINT_LEFT_KNEE;

  01f4a	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+4, 2

; 1015 : 	enumJOINT.LEFT_ANCKLE = JOINT_LEFT_ANCKLE;

  01f54	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+8, 3

; 1016 : 	enumJOINT.RIGHT_THIGH = JOINT_RIGHT_THIGH;

  01f5e	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+12, 4

; 1017 : 	enumJOINT.RIGHT_KNEE = JOINT_RIGHT_KNEE;

  01f68	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+16, 5

; 1018 : 	enumJOINT.RIGHT_ANCKLE = JOINT_RIGHT_ANCKLE;

  01f72	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+20, 6

; 1019 : 	enumJOINT.ABDOMEN = JOINT_ABDOMEN;

  01f7c	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+24, 7

; 1020 : 	enumJOINT.NECK = JOINT_NECK;

  01f86	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+28, 8

; 1021 : 	enumJOINT.LEFT_SHOULDER = JOINT_LEFT_SHOULDER;

  01f90	c7 05 20 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+32, 9

; 1022 : 	enumJOINT.LEFT_ELBOW = JOINT_LEFT_ELBOW;

  01f9a	c7 05 24 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+36, 10 ; 0000000aH

; 1023 : 	enumJOINT.LEFT_WRIST = JOINT_LEFT_WRIST;

  01fa4	c7 05 28 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+40, 11 ; 0000000bH

; 1024 : 	enumJOINT.RIGHT_SHOULDER = JOINT_RIGHT_SHOULDER;

  01fae	c7 05 2c 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+44, 12 ; 0000000cH

; 1025 : 	enumJOINT.RIGHT_ELBOW = JOINT_RIGHT_ELBOW;

  01fb8	c7 05 30 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+48, 13 ; 0000000dH

; 1026 : 	enumJOINT.RIGHT_WRIST = JOINT_RIGHT_WRIST;

  01fc2	c7 05 34 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumJOINT@@3UStrEnumJOINT@@A+52, 14 ; 0000000eH

; 1027 : 
; 1028 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSC----------------------
; 1029 : 	enumSC.NORMAL = SC_NORMAL;

  01fcc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A, 0

; 1030 : 	enumSC.HALF_WIDTH = SC_HALF_WIDTH;

  01fd6	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A+4, 1

; 1031 : 	enumSC.HALF_HEIGHT = SC_HALF_HEIGHT;

  01fe0	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A+8, 2

; 1032 : 	enumSC.HALF_SIZE = SC_HALF_SIZE;

  01fea	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A+12, 3

; 1033 : 	enumSC.DOUBLE_WIDTH = SC_DOUBLE_WIDTH;

  01ff4	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A+16, 4

; 1034 : 	enumSC.DOUBLE_HEIGHT = SC_DOUBLE_HEIGHT;

  01ffe	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A+20, 5

; 1035 : 	enumSC.DOUBLE_SIZE = SC_DOUBLE_SIZE;

  02008	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumSC@@3UStrEnumSC@@A+24, 6

; 1036 : 
; 1037 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSTRING----------------------
; 1038 : 	enumSTRING.NG = STRING_NG;

  02012	c7 05 00 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A, 32768 ; 00008000H

; 1039 : 	enumSTRING.BOTTOM_CENTER = STRING_BOTTOM_CENTER;

  0201c	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+4, 1

; 1040 : 	enumSTRING.TOP_CENTER = STRING_TOP_CENTER;

  02026	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+8, 2

; 1041 : 	enumSTRING.CENTER_CENTER = STRING_CENTER_CENTER;

  02030	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+12, 3

; 1042 : 	enumSTRING.TOP_LEFT = STRING_TOP_LEFT;

  0203a	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+16, 4

; 1043 : 	enumSTRING.TOP_RIGHT = STRING_TOP_RIGHT;

  02044	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+20, 5

; 1044 : 	enumSTRING.BOTTOM_LEFT = STRING_BOTTOM_LEFT;

  0204e	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+24, 6

; 1045 : 	enumSTRING.BOTTOM_RIGHT = STRING_BOTTOM_RIGHT;

  02058	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+28, 7

; 1046 : 	enumSTRING.DOWN_DAMAGE_BAR = STRING_DOWN_DAMAGE_BAR;

  02062	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+32, 8

; 1047 : 	enumSTRING.DOWN_COLD_BAR = STRING_DOWN_COLD_BAR;

  0206c	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+36, 9

; 1048 : 	enumSTRING.DOWN_LEFT_BARS = STRING_DOWN_LEFT_BARS;

  02076	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+40, 10 ; 0000000aH

; 1049 : 	enumSTRING.DOWN_RIGHT_BARS = STRING_DOWN_RIGHT_BARS;

  02080	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumSTRING@@3UStrEnumSTRING@@A+44, 11 ; 0000000bH

; 1050 : 
; 1051 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumADD----------------------
; 1052 : 	enumADD.FLAME = ADD_FLAME;

  0208a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A, 1

; 1053 : 	enumADD.SMOKE = ADD_SMOKE;

  02094	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+4, 2

; 1054 : 	enumADD.BLOOD = ADD_BLOOD;

  0209e	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+8, 3

; 1055 : 	enumADD.MIST = ADD_MIST;

  020a8	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+12, 4

; 1056 : 	enumADD.LIGHT_FLAT = ADD_LIGHT_FLAT;

  020b2	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+16, 5

; 1057 : 	enumADD.LIGHT_BLINK = ADD_LIGHT_BLINK;

  020bc	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+20, 6

; 1058 : 	enumADD.LIGHT_SPOT = ADD_LIGHT_SPOT;

  020c6	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+24, 7

; 1059 : 	enumADD.LIGHT_GLOVE = ADD_LIGHT_GLOVE;

  020d0	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumADD@@3UStrEnumADD@@A+28, 8

; 1060 : 
; 1061 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumENV----------------------
; 1062 : 	enumENV.NO_BLOCK_IN_FRONT = ENV_NO_BLOCK_IN_FRONT;

  020da	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A, 1

; 1063 : 	enumENV.HANG_WITH_FEET = ENV_HANG_WITH_FEET;

  020e4	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+4, 2

; 1064 : 	enumENV.HOLE_FLOOR_IN_FRONT = ENV_HOLE_FLOOR_IN_FRONT;

  020ee	c7 05 08 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+8, 3

; 1065 : 	enumENV.MONKEY_CEILING = ENV_MONKEY_CEILING;

  020f8	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+12, 4

; 1066 : 	enumENV.CLIMB_WALL_IN_FRONT = ENV_CLIMB_WALL_IN_FRONT;

  02102	c7 05 10 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+16, 5

; 1067 : 	enumENV.CLIMB_WALL_AT_RIGHT = ENV_CLIMB_WALL_AT_RIGHT;

  0210c	c7 05 14 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+20, 6

; 1068 : 	enumENV.CLIMB_WALL_AT_LEFT = ENV_CLIMB_WALL_AT_LEFT;

  02116	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+24, 7

; 1069 : 	enumENV.HOLE_IN_FRONT_CEILING_CLIMB = ENV_HOLE_IN_FRONT_CEILING_CLIMB;

  02120	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+28, 8

; 1070 : 	enumENV.HOLE_BACK_CEILING_CLIMB = ENV_HOLE_BACK_CEILING_CLIMB;

  0212a	c7 05 20 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+32, 9

; 1071 : 	enumENV.NO_BLOCK_AT_RIGHT = ENV_NO_BLOCK_AT_RIGHT;

  02134	c7 05 24 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+36, 10 ; 0000000aH

; 1072 : 	enumENV.NO_BLOCK_AT_LEFT = ENV_NO_BLOCK_AT_LEFT;

  0213e	c7 05 28 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+40, 11 ; 0000000bH

; 1073 : 	enumENV.HOLE_FLOOR_AT_RIGHT = ENV_HOLE_FLOOR_AT_RIGHT;

  02148	c7 05 2c 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+44, 12 ; 0000000cH

; 1074 : 	enumENV.HOLE_FLOOR_AT_LEFT = ENV_HOLE_FLOOR_AT_LEFT;

  02152	c7 05 30 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+48, 13 ; 0000000dH

; 1075 : 	enumENV.HOLE_FLOOR_BACK = ENV_HOLE_FLOOR_BACK;

  0215c	c7 05 34 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+52, 14 ; 0000000eH

; 1076 : 	enumENV.NO_BLOCK_BACK = ENV_NO_BLOCK_BACK;

  02166	c7 05 38 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+56, 15 ; 0000000fH

; 1077 : 	enumENV.CLIMB_WALL_BACK = ENV_CLIMB_WALL_BACK;

  02170	c7 05 3c 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+60, 16 ; 00000010H

; 1078 : 	enumENV.SUPPORT_IN_FRONT_WALL = ENV_SUPPORT_IN_FRONT_WALL;

  0217a	c7 05 40 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+64, 17 ; 00000011H

; 1079 : 	enumENV.SUPPORT_IN_RIGHT_WALL = ENV_SUPPORT_IN_RIGHT_WALL;

  02184	c7 05 44 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+68, 18 ; 00000012H

; 1080 : 	enumENV.SUPPORT_IN_LEFT_WALL = ENV_SUPPORT_IN_LEFT_WALL;

  0218e	c7 05 48 00 00
	00 13 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+72, 19 ; 00000013H

; 1081 : 	enumENV.SUPPORT_IN_BACK_WALL = ENV_SUPPORT_IN_BACK_WALL;

  02198	c7 05 4c 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+76, 20 ; 00000014H

; 1082 : 	enumENV.ITEM_EXTRA_IN_FRONT = ENV_ITEM_EXTRA_IN_FRONT;

  021a2	c7 05 50 00 00
	00 15 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+80, 21 ; 00000015H

; 1083 : 	enumENV.ITEM_EXTRA_OVER = ENV_ITEM_EXTRA_OVER;

  021ac	c7 05 54 00 00
	00 16 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+84, 22 ; 00000016H

; 1084 : 	enumENV.ITEM_EXTRA_UNDER = ENV_ITEM_EXTRA_UNDER;

  021b6	c7 05 58 00 00
	00 17 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+88, 23 ; 00000017H

; 1085 : 	enumENV.MULT_CONDITION = ENV_MULT_CONDITION;

  021c0	c7 05 5c 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+92, 24 ; 00000018H

; 1086 : 	enumENV.HANG_LEFT_IN_CORNER = ENV_HANG_LEFT_IN_CORNER;

  021ca	c7 05 60 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+96, 25 ; 00000019H

; 1087 : 	enumENV.HANG_LEFT_OUT_CORNER = ENV_HANG_LEFT_OUT_CORNER;

  021d4	c7 05 64 00 00
	00 1a 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+100, 26 ; 0000001aH

; 1088 : 	enumENV.HANG_RIGHT_IN_CORNER = ENV_HANG_RIGHT_IN_CORNER;

  021de	c7 05 68 00 00
	00 1b 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+104, 27 ; 0000001bH

; 1089 : 	enumENV.HANG_RIGHT_OUT_CORNER = ENV_HANG_RIGHT_OUT_CORNER;

  021e8	c7 05 6c 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+108, 28 ; 0000001cH

; 1090 : 	enumENV.HANG_LEFT_SPACE = ENV_HANG_LEFT_SPACE;

  021f2	c7 05 70 00 00
	00 1d 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+112, 29 ; 0000001dH

; 1091 : 	enumENV.HANG_RIGHT_SPACE = ENV_HANG_RIGHT_SPACE;

  021fc	c7 05 74 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+116, 30 ; 0000001eH

; 1092 : 	enumENV.DISTANCE_CEILING = ENV_DISTANCE_CEILING;

  02206	c7 05 78 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+120, 31 ; 0000001fH

; 1093 : 	enumENV.CLIMB_LEFT_IN_CORNER = ENV_CLIMB_LEFT_IN_CORNER;

  02210	c7 05 7c 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+124, 32 ; 00000020H

; 1094 : 	enumENV.CLIMB_LEFT_OUT_CORNER = ENV_CLIMB_LEFT_OUT_CORNER;

  0221a	c7 05 80 00 00
	00 21 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+128, 33 ; 00000021H

; 1095 : 	enumENV.CLIMB_RIGHT_IN_CORNER = ENV_CLIMB_RIGHT_IN_CORNER;

  02224	c7 05 84 00 00
	00 22 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+132, 34 ; 00000022H

; 1096 : 	enumENV.CLIMB_RIGHT_OUT_CORNER = ENV_CLIMB_RIGHT_OUT_CORNER;

  0222e	c7 05 88 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+136, 35 ; 00000023H

; 1097 : 	enumENV.CLIMB_LEFT_SPACE = ENV_CLIMB_LEFT_SPACE;

  02238	c7 05 8c 00 00
	00 24 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+140, 36 ; 00000024H

; 1098 : 	enumENV.CLIMB_RIGHT_SPACE = ENV_CLIMB_RIGHT_SPACE;

  02242	c7 05 90 00 00
	00 25 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+144, 37 ; 00000025H

; 1099 : 	enumENV.MULT_OR_CONDITION = ENV_MULT_OR_CONDITION;

  0224c	c7 05 94 00 00
	00 26 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+148, 38 ; 00000026H

; 1100 : 	enumENV.DISTANCE_FLOOR = ENV_DISTANCE_FLOOR;

  02256	c7 05 98 00 00
	00 27 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+152, 39 ; 00000027H

; 1101 : 	enumENV.FRAME_NUMBER = ENV_FRAME_NUMBER;

  02260	c7 05 9c 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+156, 40 ; 00000028H

; 1102 : 	enumENV.VERTICAL_ORIENT = ENV_VERTICAL_ORIENT;

  0226a	c7 05 a0 00 00
	00 29 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+160, 41 ; 00000029H

; 1103 : 	enumENV.ON_VEHICLE = ENV_ON_VEHICLE;

  02274	c7 05 a4 00 00
	00 2a 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+164, 42 ; 0000002aH

; 1104 : 	enumENV.FREE_HANDS = ENV_FREE_HANDS;

  0227e	c7 05 a8 00 00
	00 2b 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+168, 43 ; 0000002bH

; 1105 : 	enumENV.UNDERWATER = ENV_UNDERWATER;

  02288	c7 05 ac 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+172, 44 ; 0000002cH

; 1106 : 	enumENV.FLOATING = ENV_FLOATING;

  02292	c7 05 b0 00 00
	00 2d 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+176, 45 ; 0000002dH

; 1107 : 	enumENV.ONLAND = ENV_ONLAND;

  0229c	c7 05 b4 00 00
	00 2e 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+180, 46 ; 0000002eH

; 1108 : 	enumENV.IS_STILL = ENV_IS_STILL;

  022a6	c7 05 b8 00 00
	00 2f 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+184, 47 ; 0000002fH

; 1109 : 	enumENV.ANIM_COMPLETE = ENV_ANIM_COMPLETE;

  022b0	c7 05 bc 00 00
	00 30 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+188, 48 ; 00000030H

; 1110 : 	enumENV.FLYING_UP = ENV_FLYING_UP;

  022ba	c7 05 c0 00 00
	00 31 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+192, 49 ; 00000031H

; 1111 : 	enumENV.FLYING_DOWN = ENV_FLYING_DOWN;

  022c4	c7 05 c4 00 00
	00 32 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+196, 50 ; 00000032H

; 1112 : 	enumENV.WALL_HOLE_IN_FRONT = ENV_WALL_HOLE_IN_FRONT;

  022ce	c7 05 c8 00 00
	00 33 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+200, 51 ; 00000033H

; 1113 : 	enumENV.IN_LEFT_SIDE_SECTOR = ENV_IN_LEFT_SIDE_SECTOR;

  022d8	c7 05 cc 00 00
	00 34 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+204, 52 ; 00000034H

; 1114 : 	enumENV.IN_RIGHT_SIDE_SECTOR = ENV_IN_RIGHT_SIDE_SECTOR;

  022e2	c7 05 d0 00 00
	00 35 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+208, 53 ; 00000035H

; 1115 : 	enumENV.ITEM_EXTRA_AT_LEFT = ENV_ITEM_EXTRA_AT_LEFT;

  022ec	c7 05 d4 00 00
	00 36 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+212, 54 ; 00000036H

; 1116 : 	enumENV.ITEM_EXTRA_AT_RIGHT = ENV_ITEM_EXTRA_AT_RIGHT;

  022f6	c7 05 d8 00 00
	00 37 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+216, 55 ; 00000037H

; 1117 : 	enumENV.ITEM_TEST_POSITION = ENV_ITEM_TEST_POSITION;

  02300	c7 05 dc 00 00
	00 38 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+220, 56 ; 00000038H

; 1118 : 	enumENV.HOLD_EXTRA_ITEM_IN_HANDS = ENV_HOLD_EXTRA_ITEM_IN_HANDS;

  0230a	c7 05 e0 00 00
	00 39 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+224, 57 ; 00000039H

; 1119 : 	enumENV.CONDITION_TRIGGER_GROUP = ENV_CONDITION_TRIGGER_GROUP;

  02314	c7 05 e4 00 00
	00 3a 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+228, 58 ; 0000003aH

; 1120 : 	enumENV.ROOM_IS = ENV_ROOM_IS;

  0231e	c7 05 e8 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+232, 59 ; 0000003bH

; 1121 : 	enumENV.PLAYER_IS_SLEEPING = ENV_PLAYER_IS_SLEEPING;

  02328	c7 05 ec 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+236, 60 ; 0000003cH

; 1122 : 	enumENV.PLAYER_WOKE_UP = ENV_PLAYER_WOKE_UP;

  02332	c7 05 f0 00 00
	00 3d 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+240, 61 ; 0000003dH

; 1123 : 	enumENV.DISTANCE_NORTH_WALL = ENV_DISTANCE_NORTH_WALL;

  0233c	c7 05 f4 00 00
	00 3e 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+244, 62 ; 0000003eH

; 1124 : 	enumENV.DISTANCE_SOUTH_WALL = ENV_DISTANCE_SOUTH_WALL;

  02346	c7 05 f8 00 00
	00 3f 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+248, 63 ; 0000003fH

; 1125 : 	enumENV.DISTANCE_EAST_WALL = ENV_DISTANCE_EAST_WALL;

  02350	c7 05 fc 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+252, 64 ; 00000040H

; 1126 : 	enumENV.DISTANCE_WEST_WALL = ENV_DISTANCE_WEST_WALL;

  0235a	c7 05 00 01 00
	00 41 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+256, 65 ; 00000041H

; 1127 : 	enumENV.LARA_IN_MICRO_STRIP = ENV_LARA_IN_MICRO_STRIP;

  02364	c7 05 04 01 00
	00 42 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+260, 66 ; 00000042H

; 1128 : 	enumENV.NO_BOX_IN_FRONT = ENV_NO_BOX_IN_FRONT;

  0236e	c7 05 08 01 00
	00 43 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+264, 67 ; 00000043H

; 1129 : 	enumENV.NO_BOX_AT_LEFT = ENV_NO_BOX_AT_LEFT;

  02378	c7 05 0c 01 00
	00 44 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+268, 68 ; 00000044H

; 1130 : 	enumENV.NO_BOX_AT_RIGHT = ENV_NO_BOX_AT_RIGHT;

  02382	c7 05 10 01 00
	00 45 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+272, 69 ; 00000045H

; 1131 : 	enumENV.NO_BOX_BACK = ENV_NO_BOX_BACK;

  0238c	c7 05 14 01 00
	00 46 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+276, 70 ; 00000046H

; 1132 : 	enumENV.ENEMY_SEE_LARA = ENV_ENEMY_SEE_LARA;

  02396	c7 05 18 01 00
	00 47 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+280, 71 ; 00000047H

; 1133 : 	enumENV.FRAME_RANGE = ENV_FRAME_RANGE;

  023a0	c7 05 1c 01 00
	00 48 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+284, 72 ; 00000048H

; 1134 : 	enumENV.NON_TRUE = ENV_NON_TRUE;

  023aa	c7 05 20 01 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+288, 128 ; 00000080H

; 1135 : 	enumENV.POS_LEFT_CORNER = ENV_POS_LEFT_CORNER;

  023b4	c7 05 24 01 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+292, 256 ; 00000100H

; 1136 : 	enumENV.POS_RIGHT_CORNER = ENV_POS_RIGHT_CORNER;

  023be	c7 05 28 01 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+296, 512 ; 00000200H

; 1137 : 	enumENV.POS_CENTRAL = ENV_POS_CENTRAL;

  023c8	c7 05 2c 01 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+300, 1024 ; 00000400H

; 1138 : 	enumENV.POS_HORTOGONAL = ENV_POS_HORTOGONAL;

  023d2	c7 05 30 01 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+304, 2048 ; 00000800H

; 1139 : 	enumENV.POS_IN_THE_MIDDLE = ENV_POS_IN_THE_MIDDLE;

  023dc	c7 05 34 01 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+308, 4096 ; 00001000H

; 1140 : 	enumENV.POS_STRIP_3 = ENV_POS_STRIP_3;

  023e6	c7 05 38 01 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+312, 8192 ; 00002000H

; 1141 : 	enumENV.POS_STRIP_2 = ENV_POS_STRIP_2;

  023f0	c7 05 3c 01 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+316, 16384 ; 00004000H

; 1142 : 	enumENV.POS_STRIP_1 = ENV_POS_STRIP_1;

  023fa	c7 05 40 01 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+320, 32768 ; 00008000H

; 1143 : 	enumENV.MASK_CONDITION = ENV_MASK_CONDITION;

  02404	c7 05 44 01 00
	00 7f 00 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+324, 127 ; 0000007fH

; 1144 : 	enumENV.MASK_FLAGS = ENV_MASK_FLAGS;

  0240e	c7 05 48 01 00
	00 80 ff 00 00	 mov	 DWORD PTR ?enumENV@@3UStrEnumENV@@A+328, 65408 ; 0000ff80H

; 1145 : 
; 1146 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCBT----------------------
; 1147 : 	enumCBT.FIRST = CBT_FIRST;

  02418	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A, 1

; 1148 : 	enumCBT.AFTER = CBT_AFTER;

  02422	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A+4, 2

; 1149 : 	enumCBT.REPLACE = CBT_REPLACE;

  0242c	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A+8, 4

; 1150 : 	enumCBT.ASM = CBT_ASM;

  02436	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A+12, 8

; 1151 : 	enumCBT.PRESENT = CBT_PRESENT;

  02440	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A+16, 16 ; 00000010H

; 1152 : 	enumCBT.LOOPED = CBT_LOOPED;

  0244a	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A+20, 32 ; 00000020H

; 1153 : 	enumCBT.ANY = CBT_ANY;

  02454	c7 05 18 00 00
	00 ff ff 00 00	 mov	 DWORD PTR ?enumCBT@@3UStrEnumCBT@@A+24, 65535 ; 0000ffffH

; 1154 : 
; 1155 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFAN----------------------
; 1156 : 	enumFAN.MASK_FPS_UV = FAN_MASK_FPS_UV;

  0245e	c7 05 00 00 00
	00 00 1f 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A, 7936 ; 00001f00H

; 1157 : 	enumFAN.MASK_UVROTATE = FAN_MASK_UVROTATE;

  02468	c7 05 04 00 00
	00 ff 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+4, 255 ; 000000ffH

; 1158 : 	enumFAN.MASK_DELAY = FAN_MASK_DELAY;

  02472	c7 05 08 00 00
	00 ff 1f 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+8, 8191 ; 00001fffH

; 1159 : 	enumFAN.MASK_ANIM = FAN_MASK_ANIM;

  0247c	c7 05 0c 00 00
	00 00 e0 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+12, 57344 ; 0000e000H

; 1160 : 	enumFAN.FRAMES = FAN_FRAMES;

  02486	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+16, 0

; 1161 : 	enumFAN.P_FRAMES = FAN_P_FRAMES;

  02490	c7 05 14 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+20, 16384 ; 00004000H

; 1162 : 	enumFAN.FULL_ROTATE = FAN_FULL_ROTATE;

  0249a	c7 05 18 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+24, 32768 ; 00008000H

; 1163 : 	enumFAN.RIVER_ROTATE = FAN_RIVER_ROTATE;

  024a4	c7 05 1c 00 00
	00 00 a0 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+28, 40960 ; 0000a000H

; 1164 : 	enumFAN.HALF_ROTATE = FAN_HALF_ROTATE;

  024ae	c7 05 20 00 00
	00 00 c0 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+32, 49152 ; 0000c000H

; 1165 : 	enumFAN.ANY_ROTATE = FAN_ANY_ROTATE;

  024b8	c7 05 24 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+36, 32768 ; 00008000H

; 1166 : 	enumFAN.SET_FREE_HANDS = FAN_SET_FREE_HANDS;

  024c2	c7 05 28 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+40, 1

; 1167 : 	enumFAN.START_FROM_EXTRA_FRAME = FAN_START_FROM_EXTRA_FRAME;

  024cc	c7 05 2c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+44, 2

; 1168 : 	enumFAN.SET_NEUTRAL_STATE_ID = FAN_SET_NEUTRAL_STATE_ID;

  024d6	c7 05 30 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+48, 4

; 1169 : 	enumFAN.KEYS_AS_SCANCODE = FAN_KEYS_AS_SCANCODE;

  024e0	c7 05 34 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+52, 8

; 1170 : 	enumFAN.DISABLE_PUSH_AWAY = FAN_DISABLE_PUSH_AWAY;

  024ea	c7 05 38 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+56, 16 ; 00000010H

; 1171 : 	enumFAN.KEEP_NEXT_STATEID = FAN_KEEP_NEXT_STATEID;

  024f4	c7 05 3c 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+60, 32 ; 00000020H

; 1172 : 	enumFAN.ENABLE_GRAVITY = FAN_ENABLE_GRAVITY;

  024fe	c7 05 40 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+64, 64 ; 00000040H

; 1173 : 	enumFAN.DISABLE_GRAVITY = FAN_DISABLE_GRAVITY;

  02508	c7 05 44 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+68, 128 ; 00000080H

; 1174 : 	enumFAN.PERFORM_TRIGGER_GROUP = FAN_PERFORM_TRIGGER_GROUP;

  02512	c7 05 48 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+72, 256 ; 00000100H

; 1175 : 	enumFAN.SET_FREE_HANDS_TEMP = FAN_SET_FREE_HANDS_TEMP;

  0251c	c7 05 4c 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+76, 512 ; 00000200H

; 1176 : 	enumFAN.SET_BUSY_HANDS = FAN_SET_BUSY_HANDS;

  02526	c7 05 50 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+80, 1024 ; 00000400H

; 1177 : 	enumFAN.ALIGN_TO_ENV_POS = FAN_ALIGN_TO_ENV_POS;

  02530	c7 05 54 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+84, 2048 ; 00000800H

; 1178 : 	enumFAN.SET_ADDEFFECT = FAN_SET_ADDEFFECT;

  0253a	c7 05 58 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+88, 4096 ; 00001000H

; 1179 : 	enumFAN.RANDOM = FAN_RANDOM;

  02544	c7 05 5c 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+92, 8192 ; 00002000H

; 1180 : 	enumFAN.SET_LARA_PLACE = FAN_SET_LARA_PLACE;

  0254e	c7 05 60 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumFAN@@3UStrEnumFAN@@A+96, 16384 ; 00004000H

; 1181 : 
; 1182 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFLH----------------------
; 1183 : 	enumFLH.ALMOST_FREE_HANDS = FLH_ALMOST_FREE_HANDS;

  02558	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumFLH@@3UStrEnumFLH@@A, 0

; 1184 : 	enumFLH.IS_GRABBING = FLH_IS_GRABBING;

  02562	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFLH@@3UStrEnumFLH@@A+4, 1

; 1185 : 	enumFLH.IS_EXTRACTING = FLH_IS_EXTRACTING;

  0256c	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFLH@@3UStrEnumFLH@@A+8, 2

; 1186 : 	enumFLH.IS_THROWING = FLH_IS_THROWING;

  02576	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumFLH@@3UStrEnumFLH@@A+12, 3

; 1187 : 	enumFLH.HOLDS_ITEM = FLH_HOLDS_ITEM;

  02580	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFLH@@3UStrEnumFLH@@A+16, 4

; 1188 : 
; 1189 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCMD----------------------
; 1190 : 	enumCMD.ALL = CMD_ALL;

  0258a	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A, -1

; 1191 : 	enumCMD.UP = CMD_UP;

  02594	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+4, 1

; 1192 : 	enumCMD.DOWN = CMD_DOWN;

  0259e	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+8, 2

; 1193 : 	enumCMD.LEFT = CMD_LEFT;

  025a8	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+12, 4

; 1194 : 	enumCMD.RIGHT = CMD_RIGHT;

  025b2	c7 05 10 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+16, 8

; 1195 : 	enumCMD.DUCK = CMD_DUCK;

  025bc	c7 05 14 00 00
	00 00 00 00 20	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+20, 536870912 ; 20000000H

; 1196 : 	enumCMD.DASH = CMD_DASH;

  025c6	c7 05 18 00 00
	00 00 00 00 40	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+24, 1073741824 ; 40000000H

; 1197 : 	enumCMD.WALK = CMD_WALK;

  025d0	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+28, 128 ; 00000080H

; 1198 : 	enumCMD.JUMP = CMD_JUMP;

  025da	c7 05 20 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+32, 16 ; 00000010H

; 1199 : 	enumCMD.ACTION = CMD_ACTION;

  025e4	c7 05 24 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+36, 64 ; 00000040H

; 1200 : 	enumCMD.DRAW_WEAPON = CMD_DRAW_WEAPON;

  025ee	c7 05 28 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+40, 32 ; 00000020H

; 1201 : 	enumCMD.USE_FLARE = CMD_USE_FLARE;

  025f8	c7 05 2c 00 00
	00 00 00 08 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+44, 524288 ; 00080000H

; 1202 : 	enumCMD.LOOK = CMD_LOOK;

  02602	c7 05 30 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+48, 512 ; 00000200H

; 1203 : 	enumCMD.ROLL = CMD_ROLL;

  0260c	c7 05 34 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+52, 4096 ; 00001000H

; 1204 : 	enumCMD.INVENTORY = CMD_INVENTORY;

  02616	c7 05 38 00 00
	00 00 01 20 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+56, 2097408 ; 00200100H

; 1205 : 	enumCMD.STEP_LEFT = CMD_STEP_LEFT;

  02620	c7 05 3c 00 00
	00 80 04 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+60, 1152 ; 00000480H

; 1206 : 	enumCMD.STEP_RIGHT = CMD_STEP_RIGHT;

  0262a	c7 05 40 00 00
	00 80 08 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+64, 2176 ; 00000880H

; 1207 : 	enumCMD.PAUSE = CMD_PAUSE;

  02634	c7 05 44 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+68, 8192 ; 00002000H

; 1208 : 	enumCMD.SAVE_GAME = CMD_SAVE_GAME;

  0263e	c7 05 48 00 00
	00 00 00 40 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+72, 4194304 ; 00400000H

; 1209 : 	enumCMD.LOAD_GAME = CMD_LOAD_GAME;

  02648	c7 05 4c 00 00
	00 00 00 80 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+76, 8388608 ; 00800000H

; 1210 : 	enumCMD.WEAPON_KEYS = CMD_WEAPON_KEYS;

  02652	c7 05 50 00 00
	00 00 00 00 10	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+80, 268435456 ; 10000000H

; 1211 : 	enumCMD.ENTER = CMD_ENTER;

  0265c	c7 05 54 00 00
	00 00 00 10 00	 mov	 DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+84, 1048576 ; 00100000H

; 1212 : 
; 1213 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSRV----------------------
; 1214 : 	enumSRV.PERFORM_FLIPEFFECT = SRV_PERFORM_FLIPEFFECT;

  02666	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A, 0

; 1215 : 	enumSRV.PERFORM_ACTION = SRV_PERFORM_ACTION;

  02670	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+4, 1

; 1216 : 	enumSRV.PERFORM_CONDITION = SRV_PERFORM_CONDITION;

  0267a	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+8, 2

; 1217 : 	enumSRV.PERFORM_TRIGGERGROUP_ID = SRV_PERFORM_TRIGGERGROUP_ID;

  02684	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+12, 3

; 1218 : 	enumSRV.PERFORM_EXPORTED_TRIGGER = SRV_PERFORM_EXPORTED_TRIGGER;

  0268e	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+16, 4

; 1219 : 	enumSRV.CREATE_TRIGGERGROUP = SRV_CREATE_TRIGGERGROUP;

  02698	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+20, 5

; 1220 : 	enumSRV.CREATE_ANIMATION = SRV_CREATE_ANIMATION;

  026a2	c7 05 18 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+24, 7

; 1221 : 	enumSRV.CREATE_ANIMATIONSLOT = SRV_CREATE_ANIMATIONSLOT;

  026ac	c7 05 1c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+28, 8

; 1222 : 	enumSRV.CREATE_MULTENVCONDITION = SRV_CREATE_MULTENVCONDITION;

  026b6	c7 05 20 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+32, 9

; 1223 : 	enumSRV.CREATE_TESTPOSITION = SRV_CREATE_TESTPOSITION;

  026c0	c7 05 24 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+36, 10 ; 0000000aH

; 1224 : 	enumSRV.CREATE_ADDEFFECT = SRV_CREATE_ADDEFFECT;

  026ca	c7 05 28 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+40, 12 ; 0000000cH

; 1225 : 	enumSRV.SetReservedDataZone = SRV_SetReservedDataZone;

  026d4	c7 05 2c 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+44, 13 ; 0000000dH

; 1226 : 	enumSRV.F_ProporzioneDistanza = SRV_F_ProporzioneDistanza;

  026de	c7 05 30 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+48, 14 ; 0000000eH

; 1227 : 	enumSRV.F_EseguiTriggerGroup = SRV_F_EseguiTriggerGroup;

  026e8	c7 05 34 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+52, 15 ; 0000000fH

; 1228 : 	enumSRV.F_DetectedGlobalTriggerEvent = SRV_F_DetectedGlobalTriggerEvent;

  026f2	c7 05 38 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+56, 16 ; 00000010H

; 1229 : 	enumSRV.F_InviaErroreLog = SRV_F_InviaErroreLog;

  026fc	c7 05 3c 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+60, 17 ; 00000011H

; 1230 : 	enumSRV.CREATE_PARAM_COMMAND = SRV_CREATE_PARAM_COMMAND;

  02706	c7 05 40 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+64, 18 ; 00000012H

; 1231 : 	enumSRV.F_TestEnvCondition = SRV_F_TestEnvCondition;

  02710	c7 05 44 00 00
	00 13 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+68, 19 ; 00000013H

; 1232 : 	enumSRV.F_IsBoxSettore = SRV_F_IsBoxSettore;

  0271a	c7 05 48 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+72, 20 ; 00000014H

; 1233 : 	enumSRV.F_VerificaTestPosition = SRV_F_VerificaTestPosition;

  02724	c7 05 4c 00 00
	00 15 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+76, 21 ; 00000015H

; 1234 : 	enumSRV.F_CollideItemConCustom = SRV_F_CollideItemConCustom;

  0272e	c7 05 50 00 00
	00 16 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+80, 22 ; 00000016H

; 1235 : 	enumSRV.F_IsCollisioneConItems = SRV_F_IsCollisioneConItems;

  02738	c7 05 54 00 00
	00 17 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+84, 23 ; 00000017H

; 1236 : 	enumSRV.F_InviaLog = SRV_F_InviaLog;

  02742	c7 05 58 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+88, 24 ; 00000018H

; 1237 : 	enumSRV.F_EseguiAnimNemico = SRV_F_EseguiAnimNemico;

  0274c	c7 05 5c 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+92, 25 ; 00000019H

; 1238 : 	enumSRV.F_CreateAIRecord = SRV_F_CreateAIRecord;

  02756	c7 05 60 00 00
	00 1a 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+96, 26 ; 0000001aH

; 1239 : 	enumSRV.F_DeleteAIRecord = SRV_F_DeleteAIRecord;

  02760	c7 05 64 00 00
	00 1b 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+100, 27 ; 0000001bH

; 1240 : 	enumSRV.F_CreateNewMoveable = SRV_F_CreateNewMoveable;

  0276a	c7 05 68 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+104, 28 ; 0000001cH

; 1241 : 	enumSRV.F_DeleteNewMoveable = SRV_F_DeleteNewMoveable;

  02774	c7 05 6c 00 00
	00 1d 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+108, 29 ; 0000001dH

; 1242 : 	enumSRV.CREATE_COLOR_RGB_COMMAND = SRV_CREATE_COLOR_RGB_COMMAND;

  0277e	c7 05 70 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+112, 30 ; 0000001eH

; 1243 : 	enumSRV.DeleteParamCommand = SRV_DeleteParamCommand;

  02788	c7 05 74 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+116, 31 ; 0000001fH

; 1244 : 	enumSRV.DeleteTriggerGroup = SRV_DeleteTriggerGroup;

  02792	c7 05 78 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+120, 32 ; 00000020H

; 1245 : 	enumSRV.DeleteColorRgb = SRV_DeleteColorRgb;

  0279c	c7 05 7c 00 00
	00 21 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+124, 33 ; 00000021H

; 1246 : 	enumSRV.DeleteMultEnvCondition = SRV_DeleteMultEnvCondition;

  027a6	c7 05 80 00 00
	00 22 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+128, 34 ; 00000022H

; 1247 : 	enumSRV.DeleteTestPosition = SRV_DeleteTestPosition;

  027b0	c7 05 84 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+132, 35 ; 00000023H

; 1248 : 	enumSRV.DeleteAddEffect = SRV_DeleteAddEffect;

  027ba	c7 05 88 00 00
	00 24 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+136, 36 ; 00000024H

; 1249 : 	enumSRV.F_DisableSaving = SRV_F_DisableSaving;

  027c4	c7 05 8c 00 00
	00 25 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+140, 37 ; 00000025H

; 1250 : 	enumSRV.F_AggiungiItemMosso = SRV_F_AggiungiItemMosso;

  027ce	c7 05 90 00 00
	00 26 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+144, 38 ; 00000026H

; 1251 : 	enumSRV.F_CheckForStartMovePushable = SRV_F_CheckForStartMovePushable;

  027d8	c7 05 94 00 00
	00 27 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+148, 39 ; 00000027H

; 1252 : 	enumSRV.F_CheckForEndMovePushable = SRV_F_CheckForEndMovePushable;

  027e2	c7 05 98 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+152, 40 ; 00000028H

; 1253 : 	enumSRV.F_ExplosionOnVehicle = SRV_F_ExplosionOnVehicle;

  027ec	c7 05 9c 00 00
	00 29 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+156, 41 ; 00000029H

; 1254 : 	enumSRV.F_ConvertMicroUnits = SRV_F_ConvertMicroUnits;

  027f6	c7 05 a0 00 00
	00 2a 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+160, 42 ; 0000002aH

; 1255 : 	enumSRV.F_AllocateImage = SRV_F_AllocateImage;

  02800	c7 05 a4 00 00
	00 2b 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+164, 43 ; 0000002bH

; 1256 : 	enumSRV.F_FreeImage = SRV_F_FreeImage;

  0280a	c7 05 a8 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+168, 44 ; 0000002cH

; 1257 : 	enumSRV.F_AllocateTombHdc = SRV_F_AllocateTombHdc;

  02814	c7 05 ac 00 00
	00 2d 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+172, 45 ; 0000002dH

; 1258 : 	enumSRV.F_FreeTombHdc = SRV_F_FreeTombHdc;

  0281e	c7 05 b0 00 00
	00 2e 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+176, 46 ; 0000002eH

; 1259 : 	enumSRV.F_DrawSprite2D = SRV_F_DrawSprite2D;

  02828	c7 05 b4 00 00
	00 2f 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+180, 47 ; 0000002fH

; 1260 : 	enumSRV.F_DrawMesh3D = SRV_F_DrawMesh3D;

  02832	c7 05 b8 00 00
	00 30 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+184, 48 ; 00000030H

; 1261 : 	enumSRV.F_DrawObject2D = SRV_F_DrawObject2D;

  0283c	c7 05 bc 00 00
	00 31 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+188, 49 ; 00000031H

; 1262 : 	enumSRV.F_PrintText = SRV_F_PrintText;

  02846	c7 05 c0 00 00
	00 32 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+192, 50 ; 00000032H

; 1263 : 	enumSRV.F_ReadDxInput = SRV_F_ReadDxInput;

  02850	c7 05 c4 00 00
	00 33 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+196, 51 ; 00000033H

; 1264 : 	enumSRV.F_SuspendAudioTrack = SRV_F_SuspendAudioTrack;

  0285a	c7 05 c8 00 00
	00 34 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+200, 52 ; 00000034H

; 1265 : 	enumSRV.F_ResumeAudioTrack = SRV_F_ResumeAudioTrack;

  02864	c7 05 cc 00 00
	00 35 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+204, 53 ; 00000035H

; 1266 : 	enumSRV.F_CreateWindowsFont = SRV_F_CreateWindowsFont;

  0286e	c7 05 d0 00 00
	00 36 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+208, 54 ; 00000036H

; 1267 : 	enumSRV.F_FreeWindowsFont = SRV_F_FreeWindowsFont;

  02878	c7 05 d4 00 00
	00 37 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+212, 55 ; 00000037H

; 1268 : 	enumSRV.F_ReadInputBox = SRV_F_ReadInputBox;

  02882	c7 05 d8 00 00
	00 38 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+216, 56 ; 00000038H

; 1269 : 	enumSRV.F_ReadNumVariable = SRV_F_ReadNumVariable;

  0288c	c7 05 dc 00 00
	00 39 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+220, 57 ; 00000039H

; 1270 : 	enumSRV.F_WriteNumVariable = SRV_F_WriteNumVariable;

  02896	c7 05 e0 00 00
	00 3a 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+224, 58 ; 0000003aH

; 1271 : 	enumSRV.F_ReadTextVariable = SRV_F_ReadTextVariable;

  028a0	c7 05 e4 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+228, 59 ; 0000003bH

; 1272 : 	enumSRV.F_WriteTextVariable = SRV_F_WriteTextVariable;

  028aa	c7 05 e8 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+232, 60 ; 0000003cH

; 1273 : 	enumSRV.F_ReadMemVariable = SRV_F_ReadMemVariable;

  028b4	c7 05 ec 00 00
	00 3d 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+236, 61 ; 0000003dH

; 1274 : 	enumSRV.F_WriteMemVariable = SRV_F_WriteMemVariable;

  028be	c7 05 f0 00 00
	00 3e 00 00 00	 mov	 DWORD PTR ?enumSRV@@3UStrEnumSRV@@A+240, 62 ; 0000003eH

; 1275 : 
; 1276 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSLEV----------------------
; 1277 : 	enumSLEV.YOUNG_LARA = SLEV_YOUNG_LARA;

  028c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A, 1

; 1278 : 	enumSLEV.WEATHER = SLEV_WEATHER;

  028d2	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+4, 2

; 1279 : 	enumSLEV.HORIZON = SLEV_HORIZON;

  028dc	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+8, 4

; 1280 : 	enumSLEV.LAYER1 = SLEV_LAYER1;

  028e6	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+12, 8

; 1281 : 	enumSLEV.LAYER2 = SLEV_LAYER2;

  028f0	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+16, 16 ; 00000010H

; 1282 : 	enumSLEV.STAR_FIELD = SLEV_STAR_FIELD;

  028fa	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+20, 32 ; 00000020H

; 1283 : 	enumSLEV.LIGHTNING = SLEV_LIGHTNING;

  02904	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+24, 64 ; 00000040H

; 1284 : 	enumSLEV.TRAIN = SLEV_TRAIN;

  0290e	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+28, 128 ; 00000080H

; 1285 : 	enumSLEV.PULSE = SLEV_PULSE;

  02918	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+32, 256 ; 00000100H

; 1286 : 	enumSLEV.COL_ADD_HORIZON = SLEV_COL_ADD_HORIZON;

  02922	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+36, 512 ; 00000200H

; 1287 : 	enumSLEV.RESET_HUB = SLEV_RESET_HUB;

  0292c	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+40, 1024 ; 00000400H

; 1288 : 	enumSLEV.LENS_FLARE = SLEV_LENS_FLARE;

  02936	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+44, 2048 ; 00000800H

; 1289 : 	enumSLEV.TIMER = SLEV_TIMER;

  02940	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+48, 4096 ; 00001000H

; 1290 : 	enumSLEV.MIRROR = SLEV_MIRROR;

  0294a	c7 05 34 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+52, 8192 ; 00002000H

; 1291 : 	enumSLEV.REMOVE_AMULET = SLEV_REMOVE_AMULET;

  02954	c7 05 38 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+56, 16384 ; 00004000H

; 1292 : 	enumSLEV.NO_LEVEL = SLEV_NO_LEVEL;

  0295e	c7 05 3c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumSLEV@@3UStrEnumSLEV@@A+60, 32768 ; 00008000H

; 1293 : 
; 1294 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSMAIN----------------------
; 1295 : 	enumSMAIN.FLY_CHEAT = SMAIN_FLY_CHEAT;

  02968	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSMAIN@@3UStrEnumSMAIN@@A, 1

; 1296 : 	enumSMAIN.LOAD_SAVE = SMAIN_LOAD_SAVE;

  02972	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSMAIN@@3UStrEnumSMAIN@@A+4, 2

; 1297 : 	enumSMAIN.TITLE = SMAIN_TITLE;

  0297c	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSMAIN@@3UStrEnumSMAIN@@A+8, 4

; 1298 : 	enumSMAIN.PLAY_ANY_LEVEL = SMAIN_PLAY_ANY_LEVEL;

  02986	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSMAIN@@3UStrEnumSMAIN@@A+12, 8

; 1299 : 	enumSMAIN.DEMO_DISK = SMAIN_DEMO_DISK;

  02990	c7 05 10 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumSMAIN@@3UStrEnumSMAIN@@A+16, 128 ; 00000080H

; 1300 : 
; 1301 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumEDGX----------------------
; 1302 : 	enumEDGX.CONCISE_SCRIPT_LOG = EDGX_CONCISE_SCRIPT_LOG;

  0299a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A, 1

; 1303 : 	enumEDGX.SLOW_MOTION = EDGX_SLOW_MOTION;

  029a4	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+4, 2

; 1304 : 	enumEDGX.SWAP_VIEW = EDGX_SWAP_VIEW;

  029ae	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+8, 4

; 1305 : 	enumEDGX.LARA_CORD_IN_LOG = EDGX_LARA_CORD_IN_LOG;

  029b8	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+12, 8

; 1306 : 	enumEDGX.TRIGGER_TIMING = EDGX_TRIGGER_TIMING;

  029c2	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+16, 16 ; 00000010H

; 1307 : 	enumEDGX.RECORDING_DEMO = EDGX_RECORDING_DEMO;

  029cc	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+20, 32 ; 00000020H

; 1308 : 	enumEDGX.CUTSCENE_LOG = EDGX_CUTSCENE_LOG;

  029d6	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+24, 64 ; 00000040H

; 1309 : 	enumEDGX.ANIMATION_SLOT = EDGX_ANIMATION_SLOT;

  029e0	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumEDGX@@3UStrEnumEDGX@@A+28, 128 ; 00000080H

; 1310 : 
; 1311 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumDGX----------------------
; 1312 : 	enumDGX.LARA = DGX_LARA;

  029ea	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A, 1

; 1313 : 	enumDGX.ANIMATION = DGX_ANIMATION;

  029f4	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+4, 2

; 1314 : 	enumDGX.SFX_SOUNDS = DGX_SFX_SOUNDS;

  029fe	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+8, 4

; 1315 : 	enumDGX.FAR_VIEW = DGX_FAR_VIEW;

  02a08	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+12, 8

; 1316 : 	enumDGX.AUDIO_TRACKS = DGX_AUDIO_TRACKS;

  02a12	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+16, 16 ; 00000010H

; 1317 : 	enumDGX.CHEATS = DGX_CHEATS;

  02a1c	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+20, 32 ; 00000020H

; 1318 : 	enumDGX.FOG = DGX_FOG;

  02a26	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+24, 64 ; 00000040H

; 1319 : 	enumDGX.COMMON_VARIABLES = DGX_COMMON_VARIABLES;

  02a30	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+28, 128 ; 00000080H

; 1320 : 	enumDGX.STORE_VARIABLES = DGX_STORE_VARIABLES;

  02a3a	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+32, 256 ; 00000100H

; 1321 : 	enumDGX.FLYBY = DGX_FLYBY;

  02a44	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+36, 512 ; 00000200H

; 1322 : 	enumDGX.TEXT_VARIABLES = DGX_TEXT_VARIABLES;

  02a4e	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+40, 1024 ; 00000400H

; 1323 : 	enumDGX.LOG_SCRIPT_COMMANDS = DGX_LOG_SCRIPT_COMMANDS;

  02a58	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+44, 2048 ; 00000800H

; 1324 : 	enumDGX.WEAPON_ANIMATION = DGX_WEAPON_ANIMATION;

  02a62	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+48, 4096 ; 00001000H

; 1325 : 	enumDGX.ADJUSTMENT_MODE = DGX_ADJUSTMENT_MODE;

  02a6c	c7 05 34 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+52, 8192 ; 00002000H

; 1326 : 	enumDGX.FPS = DGX_FPS;

  02a76	c7 05 38 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+56, 16384 ; 00004000H

; 1327 : 	enumDGX.ERRORS = DGX_ERRORS;

  02a80	c7 05 3c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumDGX@@3UStrEnumDGX@@A+60, 32768 ; 00008000H

; 1328 : 
; 1329 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFROOM----------------------
; 1330 : 	enumFROOM.COLD = FROOM_COLD;

  02a8a	c7 05 00 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A, 4096 ; 00001000H

; 1331 : 	enumFROOM.RAIN = FROOM_RAIN;

  02a94	c7 05 04 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+4, 2048 ; 00000800H

; 1332 : 	enumFROOM.SNOW = FROOM_SNOW;

  02a9e	c7 05 08 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+8, 1024 ; 00000400H

; 1333 : 	enumFROOM.REFLECTION = FROOM_REFLECTION;

  02aa8	c7 05 0c 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+12, 512 ; 00000200H

; 1334 : 	enumFROOM.MIST = FROOM_MIST;

  02ab2	c7 05 10 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+16, 256 ; 00000100H

; 1335 : 	enumFROOM.NON_LENS_FLARE = FROOM_NON_LENS_FLARE;

  02abc	c7 05 14 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+20, 128 ; 00000080H

; 1336 : 	enumFROOM.MISTERY = FROOM_MISTERY;

  02ac6	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+24, 64 ; 00000040H

; 1337 : 	enumFROOM.OUTSIDE = FROOM_OUTSIDE;

  02ad0	c7 05 1c 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+28, 32 ; 00000020H

; 1338 : 	enumFROOM.DAMAGE = FROOM_DAMAGE;

  02ada	c7 05 20 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+32, 16 ; 00000010H

; 1339 : 	enumFROOM.HORIZON = FROOM_HORIZON;

  02ae4	c7 05 24 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+36, 8

; 1340 : 	enumFROOM.QUICKSAND = FROOM_QUICKSAND;

  02aee	c7 05 28 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+40, 4

; 1341 : 	enumFROOM.IS_FLIPROOM = FROOM_IS_FLIPROOM;

  02af8	c7 05 2c 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+44, 2

; 1342 : 	enumFROOM.WATER = FROOM_WATER;

  02b02	c7 05 30 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFROOM@@3UStrEnumFROOM@@A+48, 1

; 1343 : 
; 1344 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFIND----------------------
; 1345 : 	enumFIND.ITEM = FIND_ITEM;

  02b0c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A, 0

; 1346 : 	enumFIND.STATIC = FIND_STATIC;

  02b16	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+4, 1

; 1347 : 	enumFIND.AI = FIND_AI;

  02b20	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+8, 2

; 1348 : 	enumFIND.LIGHT = FIND_LIGHT;

  02b2a	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+12, 3

; 1349 : 	enumFIND.CAMERA_FIXED = FIND_CAMERA_FIXED;

  02b34	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+16, 4

; 1350 : 	enumFIND.CAMERA_FLY = FIND_CAMERA_FLY;

  02b3e	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+20, 5

; 1351 : 	enumFIND.ITEMS_NEARBY = FIND_ITEMS_NEARBY;

  02b48	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+24, 6

; 1352 : 	enumFIND.ITEMS_SECTOR = FIND_ITEMS_SECTOR;

  02b52	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+28, 7

; 1353 : 	enumFIND.STATICS_NEARBY = FIND_STATICS_NEARBY;

  02b5c	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+32, 8

; 1354 : 	enumFIND.STATICS_SECTOR = FIND_STATICS_SECTOR;

  02b66	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+36, 9

; 1355 : 	enumFIND.ENEMY_COMMAND = FIND_ENEMY_COMMAND;

  02b70	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+40, 10 ; 0000000aH

; 1356 : 	enumFIND.IMAGE_COMMAND = FIND_IMAGE_COMMAND;

  02b7a	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+44, 11 ; 0000000bH

; 1357 : 	enumFIND.WINDOWS_FONT = FIND_WINDOWS_FONT;

  02b84	c7 05 30 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+48, 12 ; 0000000cH

; 1358 : 	enumFIND.DIAGNOSTIC = FIND_DIAGNOSTIC;

  02b8e	c7 05 34 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+52, 13 ; 0000000dH

; 1359 : 	enumFIND.PROGR_ACTION_TRNG = FIND_PROGR_ACTION_TRNG;

  02b98	c7 05 38 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+56, 14 ; 0000000eH

; 1360 : 	enumFIND.PROGR_ACTION_MINE = FIND_PROGR_ACTION_MINE;

  02ba2	c7 05 3c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+60, 15 ; 0000000fH

; 1361 : 	enumFIND.ASSIGN_SLOT_MINE = FIND_ASSIGN_SLOT_MINE;

  02bac	c7 05 40 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFIND@@3UStrEnumFIND@@A+64, 16 ; 00000010H

; 1362 : 
; 1363 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSSLOT----------------------
; 1364 : 	enumSSLOT.PLANT0 = SSLOT_PLANT0;

  02bb6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A, 0

; 1365 : 	enumSSLOT.PLANT1 = SSLOT_PLANT1;

  02bc0	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+4, 1

; 1366 : 	enumSSLOT.PLANT2 = SSLOT_PLANT2;

  02bca	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+8, 2

; 1367 : 	enumSSLOT.PLANT3 = SSLOT_PLANT3;

  02bd4	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+12, 3

; 1368 : 	enumSSLOT.PLANT4 = SSLOT_PLANT4;

  02bde	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+16, 4

; 1369 : 	enumSSLOT.PLANT5 = SSLOT_PLANT5;

  02be8	c7 05 14 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+20, 5

; 1370 : 	enumSSLOT.PLANT6 = SSLOT_PLANT6;

  02bf2	c7 05 18 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+24, 6

; 1371 : 	enumSSLOT.PLANT7 = SSLOT_PLANT7;

  02bfc	c7 05 1c 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+28, 7

; 1372 : 	enumSSLOT.PLANT8 = SSLOT_PLANT8;

  02c06	c7 05 20 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+32, 8

; 1373 : 	enumSSLOT.PLANT9 = SSLOT_PLANT9;

  02c10	c7 05 24 00 00
	00 09 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+36, 9

; 1374 : 	enumSSLOT.FURNITURE0 = SSLOT_FURNITURE0;

  02c1a	c7 05 28 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+40, 10 ; 0000000aH

; 1375 : 	enumSSLOT.FURNITURE1 = SSLOT_FURNITURE1;

  02c24	c7 05 2c 00 00
	00 0b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+44, 11 ; 0000000bH

; 1376 : 	enumSSLOT.FURNITURE2 = SSLOT_FURNITURE2;

  02c2e	c7 05 30 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+48, 12 ; 0000000cH

; 1377 : 	enumSSLOT.FURNITURE3 = SSLOT_FURNITURE3;

  02c38	c7 05 34 00 00
	00 0d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+52, 13 ; 0000000dH

; 1378 : 	enumSSLOT.FURNITURE4 = SSLOT_FURNITURE4;

  02c42	c7 05 38 00 00
	00 0e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+56, 14 ; 0000000eH

; 1379 : 	enumSSLOT.FURNITURE5 = SSLOT_FURNITURE5;

  02c4c	c7 05 3c 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+60, 15 ; 0000000fH

; 1380 : 	enumSSLOT.FURNITURE6 = SSLOT_FURNITURE6;

  02c56	c7 05 40 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+64, 16 ; 00000010H

; 1381 : 	enumSSLOT.FURNITURE7 = SSLOT_FURNITURE7;

  02c60	c7 05 44 00 00
	00 11 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+68, 17 ; 00000011H

; 1382 : 	enumSSLOT.FURNITURE8 = SSLOT_FURNITURE8;

  02c6a	c7 05 48 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+72, 18 ; 00000012H

; 1383 : 	enumSSLOT.FURNITURE9 = SSLOT_FURNITURE9;

  02c74	c7 05 4c 00 00
	00 13 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+76, 19 ; 00000013H

; 1384 : 	enumSSLOT.ROCK0 = SSLOT_ROCK0;

  02c7e	c7 05 50 00 00
	00 14 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+80, 20 ; 00000014H

; 1385 : 	enumSSLOT.ROCK1 = SSLOT_ROCK1;

  02c88	c7 05 54 00 00
	00 15 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+84, 21 ; 00000015H

; 1386 : 	enumSSLOT.ROCK2 = SSLOT_ROCK2;

  02c92	c7 05 58 00 00
	00 16 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+88, 22 ; 00000016H

; 1387 : 	enumSSLOT.ROCK3 = SSLOT_ROCK3;

  02c9c	c7 05 5c 00 00
	00 17 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+92, 23 ; 00000017H

; 1388 : 	enumSSLOT.ROCK4 = SSLOT_ROCK4;

  02ca6	c7 05 60 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+96, 24 ; 00000018H

; 1389 : 	enumSSLOT.ROCK5 = SSLOT_ROCK5;

  02cb0	c7 05 64 00 00
	00 19 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+100, 25 ; 00000019H

; 1390 : 	enumSSLOT.ROCK6 = SSLOT_ROCK6;

  02cba	c7 05 68 00 00
	00 1a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+104, 26 ; 0000001aH

; 1391 : 	enumSSLOT.ROCK7 = SSLOT_ROCK7;

  02cc4	c7 05 6c 00 00
	00 1b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+108, 27 ; 0000001bH

; 1392 : 	enumSSLOT.ROCK8 = SSLOT_ROCK8;

  02cce	c7 05 70 00 00
	00 1c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+112, 28 ; 0000001cH

; 1393 : 	enumSSLOT.ROCK9 = SSLOT_ROCK9;

  02cd8	c7 05 74 00 00
	00 1d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+116, 29 ; 0000001dH

; 1394 : 	enumSSLOT.ARCHITECTURE0 = SSLOT_ARCHITECTURE0;

  02ce2	c7 05 78 00 00
	00 1e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+120, 30 ; 0000001eH

; 1395 : 	enumSSLOT.ARCHITECTURE1 = SSLOT_ARCHITECTURE1;

  02cec	c7 05 7c 00 00
	00 1f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+124, 31 ; 0000001fH

; 1396 : 	enumSSLOT.ARCHITECTURE2 = SSLOT_ARCHITECTURE2;

  02cf6	c7 05 80 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+128, 32 ; 00000020H

; 1397 : 	enumSSLOT.ARCHITECTURE3 = SSLOT_ARCHITECTURE3;

  02d00	c7 05 84 00 00
	00 21 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+132, 33 ; 00000021H

; 1398 : 	enumSSLOT.ARCHITECTURE4 = SSLOT_ARCHITECTURE4;

  02d0a	c7 05 88 00 00
	00 22 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+136, 34 ; 00000022H

; 1399 : 	enumSSLOT.ARCHITECTURE5 = SSLOT_ARCHITECTURE5;

  02d14	c7 05 8c 00 00
	00 23 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+140, 35 ; 00000023H

; 1400 : 	enumSSLOT.ARCHITECTURE6 = SSLOT_ARCHITECTURE6;

  02d1e	c7 05 90 00 00
	00 24 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+144, 36 ; 00000024H

; 1401 : 	enumSSLOT.ARCHITECTURE7 = SSLOT_ARCHITECTURE7;

  02d28	c7 05 94 00 00
	00 25 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+148, 37 ; 00000025H

; 1402 : 	enumSSLOT.ARCHITECTURE8 = SSLOT_ARCHITECTURE8;

  02d32	c7 05 98 00 00
	00 26 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+152, 38 ; 00000026H

; 1403 : 	enumSSLOT.ARCHITECTURE9 = SSLOT_ARCHITECTURE9;

  02d3c	c7 05 9c 00 00
	00 27 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+156, 39 ; 00000027H

; 1404 : 	enumSSLOT.DEBRIS0 = SSLOT_DEBRIS0;

  02d46	c7 05 a0 00 00
	00 28 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+160, 40 ; 00000028H

; 1405 : 	enumSSLOT.DEBRIS1 = SSLOT_DEBRIS1;

  02d50	c7 05 a4 00 00
	00 29 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+164, 41 ; 00000029H

; 1406 : 	enumSSLOT.DEBRIS2 = SSLOT_DEBRIS2;

  02d5a	c7 05 a8 00 00
	00 2a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+168, 42 ; 0000002aH

; 1407 : 	enumSSLOT.DEBRIS3 = SSLOT_DEBRIS3;

  02d64	c7 05 ac 00 00
	00 2b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+172, 43 ; 0000002bH

; 1408 : 	enumSSLOT.DEBRIS4 = SSLOT_DEBRIS4;

  02d6e	c7 05 b0 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+176, 44 ; 0000002cH

; 1409 : 	enumSSLOT.DEBRIS5 = SSLOT_DEBRIS5;

  02d78	c7 05 b4 00 00
	00 2d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+180, 45 ; 0000002dH

; 1410 : 	enumSSLOT.DEBRIS6 = SSLOT_DEBRIS6;

  02d82	c7 05 b8 00 00
	00 2e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+184, 46 ; 0000002eH

; 1411 : 	enumSSLOT.DEBRIS7 = SSLOT_DEBRIS7;

  02d8c	c7 05 bc 00 00
	00 2f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+188, 47 ; 0000002fH

; 1412 : 	enumSSLOT.DEBRIS8 = SSLOT_DEBRIS8;

  02d96	c7 05 c0 00 00
	00 30 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+192, 48 ; 00000030H

; 1413 : 	enumSSLOT.DEBRIS9 = SSLOT_DEBRIS9;

  02da0	c7 05 c4 00 00
	00 31 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+196, 49 ; 00000031H

; 1414 : 	enumSSLOT.SHATTER0 = SSLOT_SHATTER0;

  02daa	c7 05 c8 00 00
	00 32 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+200, 50 ; 00000032H

; 1415 : 	enumSSLOT.SHATTER1 = SSLOT_SHATTER1;

  02db4	c7 05 cc 00 00
	00 33 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+204, 51 ; 00000033H

; 1416 : 	enumSSLOT.SHATTER2 = SSLOT_SHATTER2;

  02dbe	c7 05 d0 00 00
	00 34 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+208, 52 ; 00000034H

; 1417 : 	enumSSLOT.SHATTER3 = SSLOT_SHATTER3;

  02dc8	c7 05 d4 00 00
	00 35 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+212, 53 ; 00000035H

; 1418 : 	enumSSLOT.SHATTER4 = SSLOT_SHATTER4;

  02dd2	c7 05 d8 00 00
	00 36 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+216, 54 ; 00000036H

; 1419 : 	enumSSLOT.SHATTER5 = SSLOT_SHATTER5;

  02ddc	c7 05 dc 00 00
	00 37 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+220, 55 ; 00000037H

; 1420 : 	enumSSLOT.SHATTER6 = SSLOT_SHATTER6;

  02de6	c7 05 e0 00 00
	00 38 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+224, 56 ; 00000038H

; 1421 : 	enumSSLOT.SHATTER7 = SSLOT_SHATTER7;

  02df0	c7 05 e4 00 00
	00 39 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+228, 57 ; 00000039H

; 1422 : 	enumSSLOT.SHATTER8 = SSLOT_SHATTER8;

  02dfa	c7 05 e8 00 00
	00 3a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+232, 58 ; 0000003aH

; 1423 : 	enumSSLOT.SHATTER9 = SSLOT_SHATTER9;

  02e04	c7 05 ec 00 00
	00 3b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+236, 59 ; 0000003bH

; 1424 : 	enumSSLOT.EXTRA00 = SSLOT_EXTRA00;

  02e0e	c7 05 f0 00 00
	00 3c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+240, 60 ; 0000003cH

; 1425 : 	enumSSLOT.EXTRA01 = SSLOT_EXTRA01;

  02e18	c7 05 f4 00 00
	00 3d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+244, 61 ; 0000003dH

; 1426 : 	enumSSLOT.EXTRA02 = SSLOT_EXTRA02;

  02e22	c7 05 f8 00 00
	00 3e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+248, 62 ; 0000003eH

; 1427 : 	enumSSLOT.EXTRA03 = SSLOT_EXTRA03;

  02e2c	c7 05 fc 00 00
	00 3f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+252, 63 ; 0000003fH

; 1428 : 	enumSSLOT.EXTRA04 = SSLOT_EXTRA04;

  02e36	c7 05 00 01 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+256, 64 ; 00000040H

; 1429 : 	enumSSLOT.EXTRA05 = SSLOT_EXTRA05;

  02e40	c7 05 04 01 00
	00 41 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+260, 65 ; 00000041H

; 1430 : 	enumSSLOT.EXTRA06 = SSLOT_EXTRA06;

  02e4a	c7 05 08 01 00
	00 42 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+264, 66 ; 00000042H

; 1431 : 	enumSSLOT.EXTRA07 = SSLOT_EXTRA07;

  02e54	c7 05 0c 01 00
	00 43 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+268, 67 ; 00000043H

; 1432 : 	enumSSLOT.EXTRA08 = SSLOT_EXTRA08;

  02e5e	c7 05 10 01 00
	00 44 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+272, 68 ; 00000044H

; 1433 : 	enumSSLOT.EXTRA09 = SSLOT_EXTRA09;

  02e68	c7 05 14 01 00
	00 45 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+276, 69 ; 00000045H

; 1434 : 	enumSSLOT.EXTRA10 = SSLOT_EXTRA10;

  02e72	c7 05 18 01 00
	00 46 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+280, 70 ; 00000046H

; 1435 : 	enumSSLOT.EXTRA11 = SSLOT_EXTRA11;

  02e7c	c7 05 1c 01 00
	00 47 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+284, 71 ; 00000047H

; 1436 : 	enumSSLOT.EXTRA12 = SSLOT_EXTRA12;

  02e86	c7 05 20 01 00
	00 48 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+288, 72 ; 00000048H

; 1437 : 	enumSSLOT.EXTRA13 = SSLOT_EXTRA13;

  02e90	c7 05 24 01 00
	00 49 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+292, 73 ; 00000049H

; 1438 : 	enumSSLOT.EXTRA14 = SSLOT_EXTRA14;

  02e9a	c7 05 28 01 00
	00 4a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+296, 74 ; 0000004aH

; 1439 : 	enumSSLOT.EXTRA15 = SSLOT_EXTRA15;

  02ea4	c7 05 2c 01 00
	00 4b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+300, 75 ; 0000004bH

; 1440 : 	enumSSLOT.EXTRA16 = SSLOT_EXTRA16;

  02eae	c7 05 30 01 00
	00 4c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+304, 76 ; 0000004cH

; 1441 : 	enumSSLOT.EXTRA17 = SSLOT_EXTRA17;

  02eb8	c7 05 34 01 00
	00 4d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+308, 77 ; 0000004dH

; 1442 : 	enumSSLOT.EXTRA18 = SSLOT_EXTRA18;

  02ec2	c7 05 38 01 00
	00 4e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+312, 78 ; 0000004eH

; 1443 : 	enumSSLOT.EXTRA19 = SSLOT_EXTRA19;

  02ecc	c7 05 3c 01 00
	00 4f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+316, 79 ; 0000004fH

; 1444 : 	enumSSLOT.EXTRA20 = SSLOT_EXTRA20;

  02ed6	c7 05 40 01 00
	00 50 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+320, 80 ; 00000050H

; 1445 : 	enumSSLOT.EXTRA21 = SSLOT_EXTRA21;

  02ee0	c7 05 44 01 00
	00 51 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+324, 81 ; 00000051H

; 1446 : 	enumSSLOT.EXTRA22 = SSLOT_EXTRA22;

  02eea	c7 05 48 01 00
	00 52 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+328, 82 ; 00000052H

; 1447 : 	enumSSLOT.EXTRA23 = SSLOT_EXTRA23;

  02ef4	c7 05 4c 01 00
	00 53 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+332, 83 ; 00000053H

; 1448 : 	enumSSLOT.EXTRA24 = SSLOT_EXTRA24;

  02efe	c7 05 50 01 00
	00 54 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+336, 84 ; 00000054H

; 1449 : 	enumSSLOT.EXTRA25 = SSLOT_EXTRA25;

  02f08	c7 05 54 01 00
	00 55 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+340, 85 ; 00000055H

; 1450 : 	enumSSLOT.EXTRA26 = SSLOT_EXTRA26;

  02f12	c7 05 58 01 00
	00 56 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+344, 86 ; 00000056H

; 1451 : 	enumSSLOT.EXTRA27 = SSLOT_EXTRA27;

  02f1c	c7 05 5c 01 00
	00 57 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+348, 87 ; 00000057H

; 1452 : 	enumSSLOT.EXTRA28 = SSLOT_EXTRA28;

  02f26	c7 05 60 01 00
	00 58 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+352, 88 ; 00000058H

; 1453 : 	enumSSLOT.EXTRA29 = SSLOT_EXTRA29;

  02f30	c7 05 64 01 00
	00 59 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+356, 89 ; 00000059H

; 1454 : 	enumSSLOT.EXTRA30 = SSLOT_EXTRA30;

  02f3a	c7 05 68 01 00
	00 5a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+360, 90 ; 0000005aH

; 1455 : 	enumSSLOT.EXTRA31 = SSLOT_EXTRA31;

  02f44	c7 05 6c 01 00
	00 5b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+364, 91 ; 0000005bH

; 1456 : 	enumSSLOT.EXTRA32 = SSLOT_EXTRA32;

  02f4e	c7 05 70 01 00
	00 5c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+368, 92 ; 0000005cH

; 1457 : 	enumSSLOT.EXTRA33 = SSLOT_EXTRA33;

  02f58	c7 05 74 01 00
	00 5d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+372, 93 ; 0000005dH

; 1458 : 	enumSSLOT.EXTRA34 = SSLOT_EXTRA34;

  02f62	c7 05 78 01 00
	00 5e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+376, 94 ; 0000005eH

; 1459 : 	enumSSLOT.EXTRA35 = SSLOT_EXTRA35;

  02f6c	c7 05 7c 01 00
	00 5f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+380, 95 ; 0000005fH

; 1460 : 	enumSSLOT.EXTRA36 = SSLOT_EXTRA36;

  02f76	c7 05 80 01 00
	00 60 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+384, 96 ; 00000060H

; 1461 : 	enumSSLOT.EXTRA37 = SSLOT_EXTRA37;

  02f80	c7 05 84 01 00
	00 61 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+388, 97 ; 00000061H

; 1462 : 	enumSSLOT.EXTRA38 = SSLOT_EXTRA38;

  02f8a	c7 05 88 01 00
	00 62 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+392, 98 ; 00000062H

; 1463 : 	enumSSLOT.EXTRA39 = SSLOT_EXTRA39;

  02f94	c7 05 8c 01 00
	00 63 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+396, 99 ; 00000063H

; 1464 : 	enumSSLOT.EXTRA40 = SSLOT_EXTRA40;

  02f9e	c7 05 90 01 00
	00 64 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+400, 100 ; 00000064H

; 1465 : 	enumSSLOT.EXTRA41 = SSLOT_EXTRA41;

  02fa8	c7 05 94 01 00
	00 65 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+404, 101 ; 00000065H

; 1466 : 	enumSSLOT.EXTRA42 = SSLOT_EXTRA42;

  02fb2	c7 05 98 01 00
	00 66 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+408, 102 ; 00000066H

; 1467 : 	enumSSLOT.EXTRA43 = SSLOT_EXTRA43;

  02fbc	c7 05 9c 01 00
	00 67 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+412, 103 ; 00000067H

; 1468 : 	enumSSLOT.EXTRA44 = SSLOT_EXTRA44;

  02fc6	c7 05 a0 01 00
	00 68 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+416, 104 ; 00000068H

; 1469 : 	enumSSLOT.EXTRA45 = SSLOT_EXTRA45;

  02fd0	c7 05 a4 01 00
	00 69 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+420, 105 ; 00000069H

; 1470 : 	enumSSLOT.EXTRA46 = SSLOT_EXTRA46;

  02fda	c7 05 a8 01 00
	00 6a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+424, 106 ; 0000006aH

; 1471 : 	enumSSLOT.EXTRA47 = SSLOT_EXTRA47;

  02fe4	c7 05 ac 01 00
	00 6b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+428, 107 ; 0000006bH

; 1472 : 	enumSSLOT.EXTRA48 = SSLOT_EXTRA48;

  02fee	c7 05 b0 01 00
	00 6c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+432, 108 ; 0000006cH

; 1473 : 	enumSSLOT.EXTRA49 = SSLOT_EXTRA49;

  02ff8	c7 05 b4 01 00
	00 6d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+436, 109 ; 0000006dH

; 1474 : 	enumSSLOT.EXTRA50 = SSLOT_EXTRA50;

  03002	c7 05 b8 01 00
	00 6e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+440, 110 ; 0000006eH

; 1475 : 	enumSSLOT.EXTRA51 = SSLOT_EXTRA51;

  0300c	c7 05 bc 01 00
	00 6f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+444, 111 ; 0000006fH

; 1476 : 	enumSSLOT.EXTRA52 = SSLOT_EXTRA52;

  03016	c7 05 c0 01 00
	00 70 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+448, 112 ; 00000070H

; 1477 : 	enumSSLOT.EXTRA53 = SSLOT_EXTRA53;

  03020	c7 05 c4 01 00
	00 71 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+452, 113 ; 00000071H

; 1478 : 	enumSSLOT.EXTRA54 = SSLOT_EXTRA54;

  0302a	c7 05 c8 01 00
	00 72 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+456, 114 ; 00000072H

; 1479 : 	enumSSLOT.EXTRA55 = SSLOT_EXTRA55;

  03034	c7 05 cc 01 00
	00 73 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+460, 115 ; 00000073H

; 1480 : 	enumSSLOT.EXTRA56 = SSLOT_EXTRA56;

  0303e	c7 05 d0 01 00
	00 74 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+464, 116 ; 00000074H

; 1481 : 	enumSSLOT.EXTRA57 = SSLOT_EXTRA57;

  03048	c7 05 d4 01 00
	00 75 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+468, 117 ; 00000075H

; 1482 : 	enumSSLOT.EXTRA58 = SSLOT_EXTRA58;

  03052	c7 05 d8 01 00
	00 76 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+472, 118 ; 00000076H

; 1483 : 	enumSSLOT.EXTRA59 = SSLOT_EXTRA59;

  0305c	c7 05 dc 01 00
	00 77 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+476, 119 ; 00000077H

; 1484 : 	enumSSLOT.EXTRA60 = SSLOT_EXTRA60;

  03066	c7 05 e0 01 00
	00 78 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+480, 120 ; 00000078H

; 1485 : 	enumSSLOT.EXTRA61 = SSLOT_EXTRA61;

  03070	c7 05 e4 01 00
	00 79 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+484, 121 ; 00000079H

; 1486 : 	enumSSLOT.EXTRA62 = SSLOT_EXTRA62;

  0307a	c7 05 e8 01 00
	00 7a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+488, 122 ; 0000007aH

; 1487 : 	enumSSLOT.EXTRA63 = SSLOT_EXTRA63;

  03084	c7 05 ec 01 00
	00 7b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+492, 123 ; 0000007bH

; 1488 : 	enumSSLOT.EXTRA64 = SSLOT_EXTRA64;

  0308e	c7 05 f0 01 00
	00 7c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+496, 124 ; 0000007cH

; 1489 : 	enumSSLOT.EXTRA65 = SSLOT_EXTRA65;

  03098	c7 05 f4 01 00
	00 7d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+500, 125 ; 0000007dH

; 1490 : 	enumSSLOT.EXTRA66 = SSLOT_EXTRA66;

  030a2	c7 05 f8 01 00
	00 7e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+504, 126 ; 0000007eH

; 1491 : 	enumSSLOT.EXTRA67 = SSLOT_EXTRA67;

  030ac	c7 05 fc 01 00
	00 7f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+508, 127 ; 0000007fH

; 1492 : 	enumSSLOT.EXTRA68 = SSLOT_EXTRA68;

  030b6	c7 05 00 02 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+512, 128 ; 00000080H

; 1493 : 	enumSSLOT.EXTRA69 = SSLOT_EXTRA69;

  030c0	c7 05 04 02 00
	00 81 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+516, 129 ; 00000081H

; 1494 : 	enumSSLOT.EXTRA70 = SSLOT_EXTRA70;

  030ca	c7 05 08 02 00
	00 82 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+520, 130 ; 00000082H

; 1495 : 	enumSSLOT.EXTRA71 = SSLOT_EXTRA71;

  030d4	c7 05 0c 02 00
	00 83 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+524, 131 ; 00000083H

; 1496 : 	enumSSLOT.EXTRA72 = SSLOT_EXTRA72;

  030de	c7 05 10 02 00
	00 84 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+528, 132 ; 00000084H

; 1497 : 	enumSSLOT.EXTRA73 = SSLOT_EXTRA73;

  030e8	c7 05 14 02 00
	00 85 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+532, 133 ; 00000085H

; 1498 : 	enumSSLOT.EXTRA74 = SSLOT_EXTRA74;

  030f2	c7 05 18 02 00
	00 86 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+536, 134 ; 00000086H

; 1499 : 	enumSSLOT.EXTRA75 = SSLOT_EXTRA75;

  030fc	c7 05 1c 02 00
	00 87 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+540, 135 ; 00000087H

; 1500 : 	enumSSLOT.EXTRA76 = SSLOT_EXTRA76;

  03106	c7 05 20 02 00
	00 88 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+544, 136 ; 00000088H

; 1501 : 	enumSSLOT.EXTRA77 = SSLOT_EXTRA77;

  03110	c7 05 24 02 00
	00 89 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+548, 137 ; 00000089H

; 1502 : 	enumSSLOT.EXTRA78 = SSLOT_EXTRA78;

  0311a	c7 05 28 02 00
	00 8a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+552, 138 ; 0000008aH

; 1503 : 	enumSSLOT.EXTRA79 = SSLOT_EXTRA79;

  03124	c7 05 2c 02 00
	00 8b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+556, 139 ; 0000008bH

; 1504 : 	enumSSLOT.EXTRA80 = SSLOT_EXTRA80;

  0312e	c7 05 30 02 00
	00 8c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+560, 140 ; 0000008cH

; 1505 : 	enumSSLOT.EXTRA81 = SSLOT_EXTRA81;

  03138	c7 05 34 02 00
	00 8d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+564, 141 ; 0000008dH

; 1506 : 	enumSSLOT.EXTRA82 = SSLOT_EXTRA82;

  03142	c7 05 38 02 00
	00 8e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+568, 142 ; 0000008eH

; 1507 : 	enumSSLOT.EXTRA83 = SSLOT_EXTRA83;

  0314c	c7 05 3c 02 00
	00 8f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+572, 143 ; 0000008fH

; 1508 : 	enumSSLOT.EXTRA84 = SSLOT_EXTRA84;

  03156	c7 05 40 02 00
	00 90 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+576, 144 ; 00000090H

; 1509 : 	enumSSLOT.EXTRA85 = SSLOT_EXTRA85;

  03160	c7 05 44 02 00
	00 91 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+580, 145 ; 00000091H

; 1510 : 	enumSSLOT.EXTRA86 = SSLOT_EXTRA86;

  0316a	c7 05 48 02 00
	00 92 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+584, 146 ; 00000092H

; 1511 : 	enumSSLOT.EXTRA87 = SSLOT_EXTRA87;

  03174	c7 05 4c 02 00
	00 93 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+588, 147 ; 00000093H

; 1512 : 	enumSSLOT.EXTRA88 = SSLOT_EXTRA88;

  0317e	c7 05 50 02 00
	00 94 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+592, 148 ; 00000094H

; 1513 : 	enumSSLOT.EXTRA89 = SSLOT_EXTRA89;

  03188	c7 05 54 02 00
	00 95 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+596, 149 ; 00000095H

; 1514 : 	enumSSLOT.EXTRA90 = SSLOT_EXTRA90;

  03192	c7 05 58 02 00
	00 96 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+600, 150 ; 00000096H

; 1515 : 	enumSSLOT.EXTRA91 = SSLOT_EXTRA91;

  0319c	c7 05 5c 02 00
	00 97 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+604, 151 ; 00000097H

; 1516 : 	enumSSLOT.EXTRA92 = SSLOT_EXTRA92;

  031a6	c7 05 60 02 00
	00 98 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+608, 152 ; 00000098H

; 1517 : 	enumSSLOT.EXTRA93 = SSLOT_EXTRA93;

  031b0	c7 05 64 02 00
	00 99 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+612, 153 ; 00000099H

; 1518 : 	enumSSLOT.EXTRA94 = SSLOT_EXTRA94;

  031ba	c7 05 68 02 00
	00 9a 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+616, 154 ; 0000009aH

; 1519 : 	enumSSLOT.EXTRA95 = SSLOT_EXTRA95;

  031c4	c7 05 6c 02 00
	00 9b 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+620, 155 ; 0000009bH

; 1520 : 	enumSSLOT.EXTRA96 = SSLOT_EXTRA96;

  031ce	c7 05 70 02 00
	00 9c 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+624, 156 ; 0000009cH

; 1521 : 	enumSSLOT.EXTRA97 = SSLOT_EXTRA97;

  031d8	c7 05 74 02 00
	00 9d 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+628, 157 ; 0000009dH

; 1522 : 	enumSSLOT.EXTRA98 = SSLOT_EXTRA98;

  031e2	c7 05 78 02 00
	00 9e 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+632, 158 ; 0000009eH

; 1523 : 	enumSSLOT.EXTRA99 = SSLOT_EXTRA99;

  031ec	c7 05 7c 02 00
	00 9f 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+636, 159 ; 0000009fH

; 1524 : 	enumSSLOT.NUMBER_STATIC_OBJECTS = SSLOT_NUMBER_STATIC_OBJECTS;

  031f6	c7 05 80 02 00
	00 a0 00 00 00	 mov	 DWORD PTR ?enumSSLOT@@3UStrEnumSSLOT@@A+640, 160 ; 000000a0H

; 1525 : 
; 1526 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFWEAP----------------------
; 1527 : 	enumFWEAP.PRESENT = FWEAP_PRESENT;

  03200	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFWEAP@@3UStrEnumFWEAP@@A, 1

; 1528 : 	enumFWEAP.LASERSIGHT = FWEAP_LASERSIGHT;

  0320a	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFWEAP@@3UStrEnumFWEAP@@A+4, 4

; 1529 : 	enumFWEAP.AMMO_NORMAL = FWEAP_AMMO_NORMAL;

  03214	c7 05 08 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFWEAP@@3UStrEnumFWEAP@@A+8, 8

; 1530 : 	enumFWEAP.AMMO_SUPER = FWEAP_AMMO_SUPER;

  0321e	c7 05 0c 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFWEAP@@3UStrEnumFWEAP@@A+12, 16 ; 00000010H

; 1531 : 	enumFWEAP.AMMO_EXPLOSIVE = FWEAP_AMMO_EXPLOSIVE;

  03228	c7 05 10 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFWEAP@@3UStrEnumFWEAP@@A+16, 32 ; 00000020H

; 1532 : 
; 1533 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCBEET----------------------
; 1534 : 	enumCBEET.BEETLE_WITH_KEY = CBEET_BEETLE_WITH_KEY;

  03232	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCBEET@@3UStrEnumCBEET@@A, 1

; 1535 : 	enumCBEET.KEY_SINGLE = CBEET_KEY_SINGLE;

  0323c	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCBEET@@3UStrEnumCBEET@@A+4, 2

; 1536 : 	enumCBEET.BEETLE_SINGLE = CBEET_BEETLE_SINGLE;

  03246	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCBEET@@3UStrEnumCBEET@@A+8, 4

; 1537 : 
; 1538 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumWSKIN----------------------
; 1539 : 	enumWSKIN.MISSING = WSKIN_MISSING;

  03250	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumWSKIN@@3UStrEnumWSKIN@@A, 0

; 1540 : 	enumWSKIN.EMPTY_WATER_SKIN = WSKIN_EMPTY_WATER_SKIN;

  0325a	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumWSKIN@@3UStrEnumWSKIN@@A+4, 1

; 1541 : 	enumWSKIN.ONE_LITER = WSKIN_ONE_LITER;

  03264	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumWSKIN@@3UStrEnumWSKIN@@A+8, 2

; 1542 : 	enumWSKIN.THREE_LITERS = WSKIN_THREE_LITERS;

  0326e	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumWSKIN@@3UStrEnumWSKIN@@A+12, 4

; 1543 : 	enumWSKIN.FIVE_LITERS = WSKIN_FIVE_LITERS;

  03278	c7 05 10 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?enumWSKIN@@3UStrEnumWSKIN@@A+16, 6

; 1544 : 
; 1545 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumCOMBO----------------------
; 1546 : 	enumCOMBO.ITEM1_FOR_PUZZLE_1 = COMBO_ITEM1_FOR_PUZZLE_1;

  03282	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A, 1

; 1547 : 	enumCOMBO.ITEM2_FOR_PUZZLE_1 = COMBO_ITEM2_FOR_PUZZLE_1;

  0328c	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+4, 2

; 1548 : 	enumCOMBO.ITEM1_FOR_PUZZLE_2 = COMBO_ITEM1_FOR_PUZZLE_2;

  03296	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+8, 4

; 1549 : 	enumCOMBO.ITEM2_FOR_PUZZLE_2 = COMBO_ITEM2_FOR_PUZZLE_2;

  032a0	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+12, 8

; 1550 : 	enumCOMBO.ITEM1_FOR_PUZZLE_3 = COMBO_ITEM1_FOR_PUZZLE_3;

  032aa	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+16, 16 ; 00000010H

; 1551 : 	enumCOMBO.ITEM2_FOR_PUZZLE_3 = COMBO_ITEM2_FOR_PUZZLE_3;

  032b4	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+20, 32 ; 00000020H

; 1552 : 	enumCOMBO.ITEM1_FOR_PUZZLE_4 = COMBO_ITEM1_FOR_PUZZLE_4;

  032be	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+24, 64 ; 00000040H

; 1553 : 	enumCOMBO.ITEM2_FOR_PUZZLE_4 = COMBO_ITEM2_FOR_PUZZLE_4;

  032c8	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+28, 128 ; 00000080H

; 1554 : 	enumCOMBO.ITEM1_FOR_PUZZLE_5 = COMBO_ITEM1_FOR_PUZZLE_5;

  032d2	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+32, 256 ; 00000100H

; 1555 : 	enumCOMBO.ITEM2_FOR_PUZZLE_5 = COMBO_ITEM2_FOR_PUZZLE_5;

  032dc	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+36, 512 ; 00000200H

; 1556 : 	enumCOMBO.ITEM1_FOR_PUZZLE_6 = COMBO_ITEM1_FOR_PUZZLE_6;

  032e6	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+40, 1024 ; 00000400H

; 1557 : 	enumCOMBO.ITEM2_FOR_PUZZLE_6 = COMBO_ITEM2_FOR_PUZZLE_6;

  032f0	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+44, 2048 ; 00000800H

; 1558 : 	enumCOMBO.ITEM1_FOR_PUZZLE_7 = COMBO_ITEM1_FOR_PUZZLE_7;

  032fa	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+48, 4096 ; 00001000H

; 1559 : 	enumCOMBO.ITEM2_FOR_PUZZLE_7 = COMBO_ITEM2_FOR_PUZZLE_7;

  03304	c7 05 34 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+52, 8192 ; 00002000H

; 1560 : 	enumCOMBO.ITEM1_FOR_PUZZLE_8 = COMBO_ITEM1_FOR_PUZZLE_8;

  0330e	c7 05 38 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+56, 16384 ; 00004000H

; 1561 : 	enumCOMBO.ITEM2_FOR_PUZZLE_8 = COMBO_ITEM2_FOR_PUZZLE_8;

  03318	c7 05 3c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumCOMBO@@3UStrEnumCOMBO@@A+60, 32768 ; 00008000H

; 1562 : 
; 1563 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumKCOMBO----------------------
; 1564 : 	enumKCOMBO.ITEM1_FOR_KEY_1 = KCOMBO_ITEM1_FOR_KEY_1;

  03322	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A, 1

; 1565 : 	enumKCOMBO.ITEM2_FOR_KEY_1 = KCOMBO_ITEM2_FOR_KEY_1;

  0332c	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+4, 2

; 1566 : 	enumKCOMBO.ITEM1_FOR_KEY_2 = KCOMBO_ITEM1_FOR_KEY_2;

  03336	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+8, 4

; 1567 : 	enumKCOMBO.ITEM2_FOR_KEY_2 = KCOMBO_ITEM2_FOR_KEY_2;

  03340	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+12, 8

; 1568 : 	enumKCOMBO.ITEM1_FOR_KEY_3 = KCOMBO_ITEM1_FOR_KEY_3;

  0334a	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+16, 16 ; 00000010H

; 1569 : 	enumKCOMBO.ITEM2_FOR_KEY_3 = KCOMBO_ITEM2_FOR_KEY_3;

  03354	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+20, 32 ; 00000020H

; 1570 : 	enumKCOMBO.ITEM1_FOR_KEY_4 = KCOMBO_ITEM1_FOR_KEY_4;

  0335e	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+24, 64 ; 00000040H

; 1571 : 	enumKCOMBO.ITEM2_FOR_KEY_4 = KCOMBO_ITEM2_FOR_KEY_4;

  03368	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+28, 128 ; 00000080H

; 1572 : 	enumKCOMBO.ITEM1_FOR_KEY_5 = KCOMBO_ITEM1_FOR_KEY_5;

  03372	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+32, 256 ; 00000100H

; 1573 : 	enumKCOMBO.ITEM2_FOR_KEY_5 = KCOMBO_ITEM2_FOR_KEY_5;

  0337c	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+36, 512 ; 00000200H

; 1574 : 	enumKCOMBO.ITEM1_FOR_KEY_6 = KCOMBO_ITEM1_FOR_KEY_6;

  03386	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+40, 1024 ; 00000400H

; 1575 : 	enumKCOMBO.ITEM2_FOR_KEY_6 = KCOMBO_ITEM2_FOR_KEY_6;

  03390	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+44, 2048 ; 00000800H

; 1576 : 	enumKCOMBO.ITEM1_FOR_KEY_7 = KCOMBO_ITEM1_FOR_KEY_7;

  0339a	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+48, 4096 ; 00001000H

; 1577 : 	enumKCOMBO.ITEM2_FOR_KEY_7 = KCOMBO_ITEM2_FOR_KEY_7;

  033a4	c7 05 34 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+52, 8192 ; 00002000H

; 1578 : 	enumKCOMBO.ITEM1_FOR_KEY_8 = KCOMBO_ITEM1_FOR_KEY_8;

  033ae	c7 05 38 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+56, 16384 ; 00004000H

; 1579 : 	enumKCOMBO.ITEM2_FOR_KEY_8 = KCOMBO_ITEM2_FOR_KEY_8;

  033b8	c7 05 3c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumKCOMBO@@3UStrEnumKCOMBO@@A+60, 32768 ; 00008000H

; 1580 : 
; 1581 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumEX16----------------------
; 1582 : 	enumEX16.EXIST_1 = EX16_EXIST_1;

  033c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A, 1

; 1583 : 	enumEX16.EXIST_2 = EX16_EXIST_2;

  033cc	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+4, 2

; 1584 : 	enumEX16.EXIST_3 = EX16_EXIST_3;

  033d6	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+8, 4

; 1585 : 	enumEX16.EXIST_4 = EX16_EXIST_4;

  033e0	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+12, 8

; 1586 : 	enumEX16.EXIST_5 = EX16_EXIST_5;

  033ea	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+16, 16 ; 00000010H

; 1587 : 	enumEX16.EXIST_6 = EX16_EXIST_6;

  033f4	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+20, 32 ; 00000020H

; 1588 : 	enumEX16.EXIST_7 = EX16_EXIST_7;

  033fe	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+24, 64 ; 00000040H

; 1589 : 	enumEX16.EXIST_8 = EX16_EXIST_8;

  03408	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+28, 128 ; 00000080H

; 1590 : 	enumEX16.EXIST_9 = EX16_EXIST_9;

  03412	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+32, 256 ; 00000100H

; 1591 : 	enumEX16.EXIST_10 = EX16_EXIST_10;

  0341c	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+36, 512 ; 00000200H

; 1592 : 	enumEX16.EXIST_11 = EX16_EXIST_11;

  03426	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+40, 1024 ; 00000400H

; 1593 : 	enumEX16.EXIST_12 = EX16_EXIST_12;

  03430	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+44, 2048 ; 00000800H

; 1594 : 	enumEX16.EXIST_13 = EX16_EXIST_13;

  0343a	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+48, 4096 ; 00001000H

; 1595 : 	enumEX16.EXIST_14 = EX16_EXIST_14;

  03444	c7 05 34 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+52, 8192 ; 00002000H

; 1596 : 	enumEX16.EXIST_15 = EX16_EXIST_15;

  0344e	c7 05 38 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+56, 16384 ; 00004000H

; 1597 : 	enumEX16.EXIST_16 = EX16_EXIST_16;

  03458	c7 05 3c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumEX16@@3UStrEnumEX16@@A+60, 32768 ; 00008000H

; 1598 : 
; 1599 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumPCOMBO----------------------
; 1600 : 	enumPCOMBO.ITEM1_FOR_PICKUP_1 = PCOMBO_ITEM1_FOR_PICKUP_1;

  03462	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A, 1

; 1601 : 	enumPCOMBO.ITEM2_FOR_PICKUP_1 = PCOMBO_ITEM2_FOR_PICKUP_1;

  0346c	c7 05 04 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+4, 2

; 1602 : 	enumPCOMBO.ITEM1_FOR_PICKUP_2 = PCOMBO_ITEM1_FOR_PICKUP_2;

  03476	c7 05 08 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+8, 4

; 1603 : 	enumPCOMBO.ITEM2_FOR_PICKUP_2 = PCOMBO_ITEM2_FOR_PICKUP_2;

  03480	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+12, 8

; 1604 : 	enumPCOMBO.ITEM1_FOR_PICKUP_3 = PCOMBO_ITEM1_FOR_PICKUP_3;

  0348a	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+16, 16 ; 00000010H

; 1605 : 	enumPCOMBO.ITEM2_FOR_PICKUP_3 = PCOMBO_ITEM2_FOR_PICKUP_3;

  03494	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+20, 32 ; 00000020H

; 1606 : 	enumPCOMBO.ITEM1_FOR_PICKUP_4 = PCOMBO_ITEM1_FOR_PICKUP_4;

  0349e	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+24, 64 ; 00000040H

; 1607 : 	enumPCOMBO.ITEM2_FOR_PICKUP_4 = PCOMBO_ITEM2_FOR_PICKUP_4;

  034a8	c7 05 1c 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+28, 128 ; 00000080H

; 1608 : 	enumPCOMBO.ITEM1_FOR_PICKUP_5 = PCOMBO_ITEM1_FOR_PICKUP_5;

  034b2	c7 05 20 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+32, 256 ; 00000100H

; 1609 : 	enumPCOMBO.ITEM2_FOR_PICKUP_5 = PCOMBO_ITEM2_FOR_PICKUP_5;

  034bc	c7 05 24 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+36, 512 ; 00000200H

; 1610 : 	enumPCOMBO.ITEM1_FOR_PICKUP_6 = PCOMBO_ITEM1_FOR_PICKUP_6;

  034c6	c7 05 28 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+40, 1024 ; 00000400H

; 1611 : 	enumPCOMBO.ITEM2_FOR_PICKUP_6 = PCOMBO_ITEM2_FOR_PICKUP_6;

  034d0	c7 05 2c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+44, 2048 ; 00000800H

; 1612 : 	enumPCOMBO.ITEM1_FOR_PICKUP_7 = PCOMBO_ITEM1_FOR_PICKUP_7;

  034da	c7 05 30 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+48, 4096 ; 00001000H

; 1613 : 	enumPCOMBO.ITEM2_FOR_PICKUP_7 = PCOMBO_ITEM2_FOR_PICKUP_7;

  034e4	c7 05 34 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+52, 8192 ; 00002000H

; 1614 : 	enumPCOMBO.ITEM1_FOR_PICKUP_8 = PCOMBO_ITEM1_FOR_PICKUP_8;

  034ee	c7 05 38 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+56, 16384 ; 00004000H

; 1615 : 	enumPCOMBO.ITEM2_FOR_PICKUP_8 = PCOMBO_ITEM2_FOR_PICKUP_8;

  034f8	c7 05 3c 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumPCOMBO@@3UStrEnumPCOMBO@@A+60, 32768 ; 00008000H

; 1616 : 
; 1617 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumDENV----------------------
; 1618 : 	enumDENV.FLAG_FACE2FACE = DENV_FLAG_FACE2FACE;

  03502	c7 05 00 00 00
	00 00 80 00 00	 mov	 DWORD PTR ?enumDENV@@3UStrEnumDENV@@A, 32768 ; 00008000H

; 1619 : 	enumDENV.FLAG_FACE2BACK = DENV_FLAG_FACE2BACK;

  0350c	c7 05 04 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumDENV@@3UStrEnumDENV@@A+4, 16384 ; 00004000H

; 1620 : 	enumDENV.MASK_DISTANCE = DENV_MASK_DISTANCE;

  03516	c7 05 08 00 00
	00 ff 3f 00 00	 mov	 DWORD PTR ?enumDENV@@3UStrEnumDENV@@A+8, 16383 ; 00003fffH

; 1621 : 	enumDENV.MASK_FLAGS = DENV_MASK_FLAGS;

  03520	c7 05 0c 00 00
	00 00 c0 00 00	 mov	 DWORD PTR ?enumDENV@@3UStrEnumDENV@@A+12, 49152 ; 0000c000H

; 1622 : 
; 1623 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumSLOPE----------------------
; 1624 : 	enumSLOPE.FLAT = SLOPE_FLAT;

  0352a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumSLOPE@@3UStrEnumSLOPE@@A, 0

; 1625 : 	enumSLOPE.GENTLE_SLOPE = SLOPE_GENTLE_SLOPE;

  03534	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumSLOPE@@3UStrEnumSLOPE@@A+4, 1

; 1626 : 	enumSLOPE.STEEP_SLOPE = SLOPE_STEEP_SLOPE;

  0353e	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumSLOPE@@3UStrEnumSLOPE@@A+8, 2

; 1627 : 	enumSLOPE.GENTLE_CORNER = SLOPE_GENTLE_CORNER;

  03548	c7 05 0c 00 00
	00 03 00 00 00	 mov	 DWORD PTR ?enumSLOPE@@3UStrEnumSLOPE@@A+12, 3

; 1628 : 	enumSLOPE.STEEP_CORNER = SLOPE_STEEP_CORNER;

  03552	c7 05 10 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumSLOPE@@3UStrEnumSLOPE@@A+16, 4

; 1629 : 
; 1630 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumORIENT----------------------
; 1631 : 	enumORIENT.NORTH = ORIENT_NORTH;

  0355c	c7 05 00 00 00
	00 00 c0 ff ff	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A, -16384 ; ffffc000H

; 1632 : 	enumORIENT.SOUTH = ORIENT_SOUTH;

  03566	c7 05 04 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+4, 16384 ; 00004000H

; 1633 : 	enumORIENT.EAST = ORIENT_EAST;

  03570	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+8, 0

; 1634 : 	enumORIENT.WEST = ORIENT_WEST;

  0357a	c7 05 0c 00 00
	00 00 80 ff ff	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+12, -32768 ; ffff8000H

; 1635 : 	enumORIENT.SOUTH_EAST = ORIENT_SOUTH_EAST;

  03584	c7 05 10 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+16, 8192 ; 00002000H

; 1636 : 	enumORIENT.NORTH_EAST = ORIENT_NORTH_EAST;

  0358e	c7 05 14 00 00
	00 00 e0 ff ff	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+20, -8192 ; ffffe000H

; 1637 : 	enumORIENT.SOUTH_WEST = ORIENT_SOUTH_WEST;

  03598	c7 05 18 00 00
	00 00 60 00 00	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+24, 24576 ; 00006000H

; 1638 : 	enumORIENT.NORTH_WEST = ORIENT_NORTH_WEST;

  035a2	c7 05 1c 00 00
	00 00 a0 ff ff	 mov	 DWORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+28, -24576 ; ffffa000H

; 1639 : 
; 1640 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFSLOT----------------------
; 1641 : 	enumFSLOT.NONE = FSLOT_NONE;

  035ac	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A, 0

; 1642 : 	enumFSLOT.PRESENT = FSLOT_PRESENT;

  035b6	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 1

; 1643 : 	enumFSLOT.AI_STANDARD = FSLOT_AI_STANDARD;

  035c0	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+8, 2

; 1644 : 	enumFSLOT.CHANGE_POS_ITEM = FSLOT_CHANGE_POS_ITEM;

  035ca	c7 05 0c 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+12, 8

; 1645 : 	enumFSLOT.MOVED_BY_ANIMATIONS = FSLOT_MOVED_BY_ANIMATIONS;

  035d4	c7 05 10 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+16, 16 ; 00000010H

; 1646 : 	enumFSLOT.SAVE_ALL_DATA = FSLOT_SAVE_ALL_DATA;

  035de	c7 05 14 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+20, 32 ; 00000020H

; 1647 : 	enumFSLOT.AFFECT_LARA_AT_CONTACT = FSLOT_AFFECT_LARA_AT_CONTACT;

  035e8	c7 05 18 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+24, 64 ; 00000040H

; 1648 : 	enumFSLOT.SFX_LOCAL_SOUND = FSLOT_SFX_LOCAL_SOUND;

  035f2	c7 05 1c 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+28, 256 ; 00000100H

; 1649 : 	enumFSLOT.USE_COLLISION_BOX = FSLOT_USE_COLLISION_BOX;

  035fc	c7 05 20 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+32, 512 ; 00000200H

; 1650 : 	enumFSLOT.AMPHIBIOUS_CREATURE = FSLOT_AMPHIBIOUS_CREATURE;

  03606	c7 05 24 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+36, 1024 ; 00000400H

; 1651 : 	enumFSLOT.HIT_BUT_NOT_HURT_BY_SHOTGUN = FSLOT_HIT_BUT_NOT_HURT_BY_SHOTGUN;

  03610	c7 05 28 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+40, 2048 ; 00000800H

; 1652 : 	enumFSLOT.NO_DAMAGE_FOR_NO_EXPLOSIVE_AMMO = FSLOT_NO_DAMAGE_FOR_NO_EXPLOSIVE_AMMO;

  0361a	c7 05 2c 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+44, 4096 ; 00001000H

; 1653 : 	enumFSLOT.SAVE_MESH_MASK = FSLOT_SAVE_MESH_MASK;

  03624	c7 05 30 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+48, 8192 ; 00002000H

; 1654 : 
; 1655 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumFITEM----------------------
; 1656 : 	enumFITEM.NONE = FITEM_NONE;

  0362e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A, 0

; 1657 : 	enumFITEM.ACTIVE = FITEM_ACTIVE;

  03638	c7 05 04 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+4, 1

; 1658 : 	enumFITEM.CREATURE = FITEM_CREATURE;

  03642	c7 05 08 00 00
	00 02 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+8, 2

; 1659 : 	enumFITEM.NOT_VISIBLE = FITEM_NOT_VISIBLE;

  0364c	c7 05 0c 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+12, 4

; 1660 : 	enumFITEM.GRAVITY_AFFECTED = FITEM_GRAVITY_AFFECTED;

  03656	c7 05 10 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+16, 8

; 1661 : 	enumFITEM.FLAG_10 = FITEM_FLAG_10;

  03660	c7 05 14 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+20, 16 ; 00000010H

; 1662 : 	enumFITEM.ITEM_HAS_BEEN_HIT = FITEM_ITEM_HAS_BEEN_HIT;

  0366a	c7 05 18 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+24, 16 ; 00000010H

; 1663 : 	enumFITEM.NOT_YET_ENABLED = FITEM_NOT_YET_ENABLED;

  03674	c7 05 1c 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+28, 32 ; 00000020H

; 1664 : 	enumFITEM.KILLED_WITH_EXPLOSION = FITEM_KILLED_WITH_EXPLOSION;

  0367e	c7 05 20 00 00
	00 40 00 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+32, 64 ; 00000040H

; 1665 : 	enumFITEM.POISONED = FITEM_POISONED;

  03688	c7 05 24 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+36, 256 ; 00000100H

; 1666 : 	enumFITEM.AI_GUARD = FITEM_AI_GUARD;

  03692	c7 05 28 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+40, 512 ; 00000200H

; 1667 : 	enumFITEM.AI_AMBUSH = FITEM_AI_AMBUSH;

  0369c	c7 05 2c 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+44, 1024 ; 00000400H

; 1668 : 	enumFITEM.AI_PATROL1 = FITEM_AI_PATROL1;

  036a6	c7 05 30 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+48, 2048 ; 00000800H

; 1669 : 	enumFITEM.AI_MODIFY = FITEM_AI_MODIFY;

  036b0	c7 05 34 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+52, 4096 ; 00001000H

; 1670 : 	enumFITEM.AI_FOLLOW = FITEM_AI_FOLLOW;

  036ba	c7 05 38 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+56, 8192 ; 00002000H

; 1671 : 	enumFITEM.THROWN_AMMO = FITEM_THROWN_AMMO;

  036c4	c7 05 3c 00 00
	00 00 40 00 00	 mov	 DWORD PTR ?enumFITEM@@3UStrEnumFITEM@@A+60, 16384 ; 00004000H

; 1672 : 
; 1673 : //  --------------- LOAD CONSTANTS FOR ENUM STRUCTURE: enumMEMT----------------------
; 1674 : 	enumMEMT.SAVEGAME = MEMT_SAVEGAME;

  036ce	c7 05 00 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?enumMEMT@@3UStrEnumMEMT@@A, 256 ; 00000100H

; 1675 : 	enumMEMT.CODE = MEMT_CODE;

  036d8	c7 05 04 00 00
	00 00 02 00 00	 mov	 DWORD PTR ?enumMEMT@@3UStrEnumMEMT@@A+4, 512 ; 00000200H

; 1676 : 	enumMEMT.ITEM = MEMT_ITEM;

  036e2	c7 05 08 00 00
	00 00 04 00 00	 mov	 DWORD PTR ?enumMEMT@@3UStrEnumMEMT@@A+8, 1024 ; 00000400H

; 1677 : 	enumMEMT.SLOT = MEMT_SLOT;

  036ec	c7 05 0c 00 00
	00 00 08 00 00	 mov	 DWORD PTR ?enumMEMT@@3UStrEnumMEMT@@A+12, 2048 ; 00000800H

; 1678 : 	enumMEMT.ANIMATION = MEMT_ANIMATION;

  036f6	c7 05 10 00 00
	00 00 10 00 00	 mov	 DWORD PTR ?enumMEMT@@3UStrEnumMEMT@@A+16, 4096 ; 00001000H

; 1679 : 	enumMEMT.INVENTORY = MEMT_INVENTORY;

  03700	c7 05 14 00 00
	00 00 20 00 00	 mov	 DWORD PTR ?enumMEMT@@3UStrEnumMEMT@@A+20, 8192 ; 00002000H

; 1680 : 
; 1681 : 
; 1682 : }

  0370a	5f		 pop	 edi
  0370b	5e		 pop	 esi
  0370c	5b		 pop	 ebx
  0370d	8b e5		 mov	 esp, ebp
  0370f	5d		 pop	 ebp
  03710	c3		 ret	 0
?InitialiseEnums@@YAXXZ ENDP				; InitialiseEnums
_TEXT	ENDS
PUBLIC	?Service@@YAHKZZ				; Service
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?Service@@YAHKZZ
_TEXT	SEGMENT
_pArgs$ = -8						; size = 4
_SRV_Type$ = 8						; size = 4
?Service@@YAHKZZ PROC					; Service, COMDAT

; 1691 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1692 : 	va_list pArgs;
; 1693 : 	
; 1694 : 	va_start(pArgs, SRV_Type);

  0001e	8d 45 0c	 lea	 eax, DWORD PTR _SRV_Type$[ebp+4]
  00021	89 45 f8	 mov	 DWORD PTR _pArgs$[ebp], eax

; 1695 : 	
; 1696 : 	
; 1697 : 
; 1698 : 	return Trng.Service(Trng.IdMyPlugin, SRV_Type, pArgs);

  00024	8b f4		 mov	 esi, esp
  00026	8b 45 f8	 mov	 eax, DWORD PTR _pArgs$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _SRV_Type$[ebp]
  0002d	51		 push	 ecx
  0002e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00034	52		 push	 edx
  00035	ff 15 10 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+16
  0003b	3b f4		 cmp	 esi, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1699 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?Service@@YAHKZZ ENDP					; Service
_TEXT	ENDS
PUBLIC	?CreateNewMoveable@@YAFGKHKH@Z			; CreateNewMoveable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CreateNewMoveable@@YAFGKHKH@Z
_TEXT	SEGMENT
_Slot$ = 8						; size = 2
_CordX$ = 12						; size = 4
_CordY$ = 16						; size = 4
_CordZ$ = 20						; size = 4
_Room$ = 24						; size = 4
?CreateNewMoveable@@YAFGKHKH@Z PROC			; CreateNewMoveable, COMDAT

; 1702 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1703 : 	return Service(SRV_F_CreateNewMoveable, Slot, CordX, CordY, CordZ, Room);

  0001e	8b 45 18	 mov	 eax, DWORD PTR _Room$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR _CordZ$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 10	 mov	 edx, DWORD PTR _CordY$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _CordX$[ebp]
  0002d	50		 push	 eax
  0002e	0f b7 4d 08	 movzx	 ecx, WORD PTR _Slot$[ebp]
  00032	51		 push	 ecx
  00033	6a 1c		 push	 28			; 0000001cH
  00035	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0003a	83 c4 18	 add	 esp, 24			; 00000018H

; 1704 : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx
  00040	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?CreateNewMoveable@@YAFGKHKH@Z ENDP			; CreateNewMoveable
_TEXT	ENDS
PUBLIC	?DeleteNewMoveable@@YAXF@Z			; DeleteNewMoveable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteNewMoveable@@YAXF@Z
_TEXT	SEGMENT
_Index$ = 8						; size = 2
?DeleteNewMoveable@@YAXF@Z PROC				; DeleteNewMoveable, COMDAT

; 1709 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1710 : 	Service(SRV_F_DeleteNewMoveable, Index);

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _Index$[ebp]
  00022	50		 push	 eax
  00023	6a 1d		 push	 29			; 0000001dH
  00025	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002a	83 c4 08	 add	 esp, 8

; 1711 : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?DeleteNewMoveable@@YAXF@Z ENDP				; DeleteNewMoveable
_TEXT	ENDS
PUBLIC	?CreateAIObject@@YAHGKHKGHF@Z			; CreateAIObject
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CreateAIObject@@YAHGKHKGHF@Z
_TEXT	SEGMENT
_Slot$ = 8						; size = 2
_CordX$ = 12						; size = 4
_CordY$ = 16						; size = 4
_CordZ$ = 20						; size = 4
_Room$ = 24						; size = 2
_OcbValue$ = 28						; size = 4
_Facing$ = 32						; size = 2
?CreateAIObject@@YAHGKHKGHF@Z PROC			; CreateAIObject, COMDAT

; 1716 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1717 : 	return Service(SRV_F_CreateAIRecord, Slot, CordX, CordY, CordZ, Room, OcbValue, Facing);

  0001e	0f bf 45 20	 movsx	 eax, WORD PTR _Facing$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 1c	 mov	 ecx, DWORD PTR _OcbValue$[ebp]
  00026	51		 push	 ecx
  00027	0f b7 55 18	 movzx	 edx, WORD PTR _Room$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 14	 mov	 eax, DWORD PTR _CordZ$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 10	 mov	 ecx, DWORD PTR _CordY$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 0c	 mov	 edx, DWORD PTR _CordX$[ebp]
  00037	52		 push	 edx
  00038	0f b7 45 08	 movzx	 eax, WORD PTR _Slot$[ebp]
  0003c	50		 push	 eax
  0003d	6a 1a		 push	 26			; 0000001aH
  0003f	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00044	83 c4 20	 add	 esp, 32			; 00000020H

; 1718 : 
; 1719 : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?CreateAIObject@@YAHGKHKGHF@Z ENDP			; CreateAIObject
_TEXT	ENDS
PUBLIC	?DeleteAIObject@@YAXGG_N@Z			; DeleteAIObject
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteAIObject@@YAXGG_N@Z
_TEXT	SEGMENT
_Slot$ = 8						; size = 2
_OcbValue$ = 12						; size = 2
_TestAlls$ = 16						; size = 1
?DeleteAIObject@@YAXGG_N@Z PROC				; DeleteAIObject, COMDAT

; 1724 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1725 : 	Service(SRV_F_DeleteAIRecord, Slot, OcbValue, TestAlls);

  0001e	0f b6 45 10	 movzx	 eax, BYTE PTR _TestAlls$[ebp]
  00022	50		 push	 eax
  00023	0f b7 4d 0c	 movzx	 ecx, WORD PTR _OcbValue$[ebp]
  00027	51		 push	 ecx
  00028	0f b7 55 08	 movzx	 edx, WORD PTR _Slot$[ebp]
  0002c	52		 push	 edx
  0002d	6a 1b		 push	 27			; 0000001bH
  0002f	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 1726 : 
; 1727 : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?DeleteAIObject@@YAXGG_N@Z ENDP				; DeleteAIObject
_TEXT	ENDS
PUBLIC	?DeleteParamCommand@@YAXHH@Z			; DeleteParamCommand
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteParamCommand@@YAXHH@Z
_TEXT	SEGMENT
_ParamType$ = 8						; size = 4
_IdParam$ = 12						; size = 4
?DeleteParamCommand@@YAXHH@Z PROC			; DeleteParamCommand, COMDAT

; 1730 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1731 : 	Service(SRV_DeleteParamCommand, ParamType, IdParam);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _IdParam$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _ParamType$[ebp]
  00025	51		 push	 ecx
  00026	6a 1f		 push	 31			; 0000001fH
  00028	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1732 : 
; 1733 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?DeleteParamCommand@@YAXHH@Z ENDP			; DeleteParamCommand
_TEXT	ENDS
PUBLIC	?DeleteTriggerGroup@@YAXH@Z			; DeleteTriggerGroup
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteTriggerGroup@@YAXH@Z
_TEXT	SEGMENT
_IdTriggerGroup$ = 8					; size = 4
?DeleteTriggerGroup@@YAXH@Z PROC			; DeleteTriggerGroup, COMDAT

; 1736 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1737 : 	Service(SRV_DeleteTriggerGroup, IdTriggerGroup);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IdTriggerGroup$[ebp]
  00021	50		 push	 eax
  00022	6a 20		 push	 32			; 00000020H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 1738 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DeleteTriggerGroup@@YAXH@Z ENDP			; DeleteTriggerGroup
_TEXT	ENDS
PUBLIC	?DeleteColorRgb@@YAXH@Z				; DeleteColorRgb
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteColorRgb@@YAXH@Z
_TEXT	SEGMENT
_IdColorRgb$ = 8					; size = 4
?DeleteColorRgb@@YAXH@Z PROC				; DeleteColorRgb, COMDAT

; 1741 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1742 : 	Service(SRV_DeleteColorRgb, IdColorRgb);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IdColorRgb$[ebp]
  00021	50		 push	 eax
  00022	6a 21		 push	 33			; 00000021H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 1743 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DeleteColorRgb@@YAXH@Z ENDP				; DeleteColorRgb
_TEXT	ENDS
PUBLIC	?DeleteMultEnvCondition@@YAXH@Z			; DeleteMultEnvCondition
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteMultEnvCondition@@YAXH@Z
_TEXT	SEGMENT
_IdMultEnv$ = 8						; size = 4
?DeleteMultEnvCondition@@YAXH@Z PROC			; DeleteMultEnvCondition, COMDAT

; 1746 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1747 : 	Service(SRV_DeleteMultEnvCondition, IdMultEnv);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IdMultEnv$[ebp]
  00021	50		 push	 eax
  00022	6a 22		 push	 34			; 00000022H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 1748 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DeleteMultEnvCondition@@YAXH@Z ENDP			; DeleteMultEnvCondition
_TEXT	ENDS
PUBLIC	?DeleteTestPosition@@YAXH@Z			; DeleteTestPosition
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteTestPosition@@YAXH@Z
_TEXT	SEGMENT
_IdTest$ = 8						; size = 4
?DeleteTestPosition@@YAXH@Z PROC			; DeleteTestPosition, COMDAT

; 1751 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1752 : 	Service(SRV_DeleteTestPosition, IdTest);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IdTest$[ebp]
  00021	50		 push	 eax
  00022	6a 23		 push	 35			; 00000023H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 1753 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DeleteTestPosition@@YAXH@Z ENDP			; DeleteTestPosition
_TEXT	ENDS
PUBLIC	?DeleteAddEffect@@YAXH@Z			; DeleteAddEffect
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DeleteAddEffect@@YAXH@Z
_TEXT	SEGMENT
_IdEffect$ = 8						; size = 4
?DeleteAddEffect@@YAXH@Z PROC				; DeleteAddEffect, COMDAT

; 1756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1757 : 	Service(SRV_DeleteAddEffect,IdEffect);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IdEffect$[ebp]
  00021	50		 push	 eax
  00022	6a 24		 push	 36			; 00000024H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 1758 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DeleteAddEffect@@YAXH@Z ENDP				; DeleteAddEffect
_TEXT	ENDS
PUBLIC	?DisableSaving@@YAXH@Z				; DisableSaving
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DisableSaving@@YAXH@Z
_TEXT	SEGMENT
_FrameDurate$ = 8					; size = 4
?DisableSaving@@YAXH@Z PROC				; DisableSaving, COMDAT

; 1761 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1762 : 	Service(SRV_F_DisableSaving, FrameDurate);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _FrameDurate$[ebp]
  00021	50		 push	 eax
  00022	6a 25		 push	 37			; 00000025H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 1763 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?DisableSaving@@YAXH@Z ENDP				; DisableSaving
_TEXT	ENDS
PUBLIC	?AbsDiff@@YAHKK@Z				; AbsDiff
EXTRN	_abs:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AbsDiff@@YAHKK@Z
_TEXT	SEGMENT
_First$ = 8						; size = 4
_Second$ = 12						; size = 4
?AbsDiff@@YAHKK@Z PROC					; AbsDiff, COMDAT

; 1766 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1767 : 	return (int) abs((int) First - (int) Second);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _First$[ebp]
  00021	2b 45 0c	 sub	 eax, DWORD PTR _Second$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _abs
  0002a	83 c4 04	 add	 esp, 4

; 1768 : 
; 1769 : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?AbsDiff@@YAHKK@Z ENDP					; AbsDiff
_TEXT	ENDS
PUBLIC	?AbsDiffY@@YAHHH@Z				; AbsDiffY
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AbsDiffY@@YAHHH@Z
_TEXT	SEGMENT
_First$ = 8						; size = 4
_Second$ = 12						; size = 4
?AbsDiffY@@YAHHH@Z PROC					; AbsDiffY, COMDAT

; 1773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1774 : 
; 1775 : 	return abs(First - Second);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _First$[ebp]
  00021	2b 45 0c	 sub	 eax, DWORD PTR _Second$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _abs
  0002a	83 c4 04	 add	 esp, 4

; 1776 : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?AbsDiffY@@YAHHH@Z ENDP					; AbsDiffY
_TEXT	ENDS
PUBLIC	?AbsDiffO@@YAHFF@Z				; AbsDiffO
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AbsDiffO@@YAHFF@Z
_TEXT	SEGMENT
_WordValue$ = -20					; size = 2
_SwapValue$ = -8					; size = 2
_First$ = 8						; size = 2
_Second$ = 12						; size = 2
?AbsDiffO@@YAHFF@Z PROC					; AbsDiffO, COMDAT

; 1779 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1780 : 
; 1781 : 	short SwapValue;
; 1782 : 	WORD WordValue;
; 1783 : 
; 1784 : 
; 1785 : 	if (First > Second) {

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _First$[ebp]
  00022	0f bf 4d 0c	 movsx	 ecx, WORD PTR _Second$[ebp]
  00026	3b c1		 cmp	 eax, ecx
  00028	7e 18		 jle	 SHORT $LN2@AbsDiffO

; 1786 : 		SwapValue = First;

  0002a	66 8b 45 08	 mov	 ax, WORD PTR _First$[ebp]
  0002e	66 89 45 f8	 mov	 WORD PTR _SwapValue$[ebp], ax

; 1787 : 		First = Second;

  00032	66 8b 45 0c	 mov	 ax, WORD PTR _Second$[ebp]
  00036	66 89 45 08	 mov	 WORD PTR _First$[ebp], ax

; 1788 : 		Second = SwapValue;

  0003a	66 8b 45 f8	 mov	 ax, WORD PTR _SwapValue$[ebp]
  0003e	66 89 45 0c	 mov	 WORD PTR _Second$[ebp], ax
$LN2@AbsDiffO:

; 1789 : 	}
; 1790 : 
; 1791 : 	// check for problem: first value is negative (very little value) and second positive (very higher value)
; 1792 : 	// but really two values are very closed (0x7fff 0x8001)
; 1793 : 	if (First < -16384 && Second > 16384) {

  00042	0f bf 45 08	 movsx	 eax, WORD PTR _First$[ebp]
  00046	3d 00 c0 ff ff	 cmp	 eax, -16384		; ffffc000H
  0004b	7d 27		 jge	 SHORT $LN1@AbsDiffO
  0004d	0f bf 45 0c	 movsx	 eax, WORD PTR _Second$[ebp]
  00051	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00056	7e 1c		 jle	 SHORT $LN1@AbsDiffO

; 1794 : 		// compute with positive values
; 1795 : 		WordValue = (WORD) First;

  00058	66 8b 45 08	 mov	 ax, WORD PTR _First$[ebp]
  0005c	66 89 45 ec	 mov	 WORD PTR _WordValue$[ebp], ax

; 1796 : 		return AbsDiffY(WordValue, Second);

  00060	0f bf 45 0c	 movsx	 eax, WORD PTR _Second$[ebp]
  00064	50		 push	 eax
  00065	0f b7 4d ec	 movzx	 ecx, WORD PTR _WordValue$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?AbsDiffY@@YAHHH@Z	; AbsDiffY
  0006f	83 c4 08	 add	 esp, 8
  00072	eb 13		 jmp	 SHORT $LN3@AbsDiffO
$LN1@AbsDiffO:

; 1797 : 	}
; 1798 : 
; 1799 : 	return abs(First-Second);

  00074	0f bf 45 08	 movsx	 eax, WORD PTR _First$[ebp]
  00078	0f bf 4d 0c	 movsx	 ecx, WORD PTR _Second$[ebp]
  0007c	2b c1		 sub	 eax, ecx
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _abs
  00084	83 c4 04	 add	 esp, 4
$LN3@AbsDiffO:

; 1800 : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00090	3b ec		 cmp	 ebp, esp
  00092	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?AbsDiffO@@YAHFF@Z ENDP					; AbsDiffO
_TEXT	ENDS
PUBLIC	?SendToLog@@YA_NPADZZ				; SendToLog
EXTRN	__imp__vsprintf:PROC
_BSS	SEGMENT
?MyInternalBuffer@?1??SendToLog@@YA_NPADZZ@4PADA DB 0200H DUP (?) ; `SendToLog'::`2'::MyInternalBuffer
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT ?SendToLog@@YA_NPADZZ
_TEXT	SEGMENT
_pArgs$ = -8						; size = 4
_szFormat$ = 8						; size = 4
?SendToLog@@YA_NPADZZ PROC				; SendToLog, COMDAT

; 1804 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1805 : 	static DWORD* pTombWind4 = (DWORD*) 0x75385C;  //  ;HandleWindowMain
; 1806 : 	static char MyInternalBuffer[512];
; 1807 : 
; 1808 : 	if (*pTombWind4 == 0) return false;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pTombWind4@?1??SendToLog@@YA_NPADZZ@4PAKA
  00023	83 38 00	 cmp	 DWORD PTR [eax], 0
  00026	75 04		 jne	 SHORT $LN1@SendToLog
  00028	32 c0		 xor	 al, al
  0002a	eb 3d		 jmp	 SHORT $LN2@SendToLog
$LN1@SendToLog:

; 1809 : 
; 1810 :     va_list pArgs;
; 1811 :     va_start(pArgs, szFormat);

  0002c	8d 45 0c	 lea	 eax, DWORD PTR _szFormat$[ebp+4]
  0002f	89 45 f8	 mov	 DWORD PTR _pArgs$[ebp], eax

; 1812 :     vsprintf(MyInternalBuffer, szFormat, pArgs);

  00032	8b f4		 mov	 esi, esp
  00034	8b 45 f8	 mov	 eax, DWORD PTR _pArgs$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _szFormat$[ebp]
  0003b	51		 push	 ecx
  0003c	68 00 00 00 00	 push	 OFFSET ?MyInternalBuffer@?1??SendToLog@@YA_NPADZZ@4PADA
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1813 :     va_end(pArgs);

  00051	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pArgs$[ebp], 0

; 1814 : 
; 1815 : 	Service(SRV_F_InviaLog, MyInternalBuffer);

  00058	68 00 00 00 00	 push	 OFFSET ?MyInternalBuffer@?1??SendToLog@@YA_NPADZZ@4PADA
  0005d	6a 18		 push	 24			; 00000018H
  0005f	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00064	83 c4 08	 add	 esp, 8

; 1816 : 	return true;

  00067	b0 01		 mov	 al, 1
$LN2@SendToLog:

; 1817 : 
; 1818 : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?SendToLog@@YA_NPADZZ ENDP				; SendToLog
_TEXT	ENDS
PUBLIC	?LogOnDebug@@YA_NPADZZ				; LogOnDebug
_BSS	SEGMENT
?MyInternalBuffer@?1??LogOnDebug@@YA_NPADZZ@4PADA DB 0200H DUP (?) ; `LogOnDebug'::`2'::MyInternalBuffer
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT ?LogOnDebug@@YA_NPADZZ
_TEXT	SEGMENT
_pArgs$ = -8						; size = 4
_szFormat$ = 8						; size = 4
?LogOnDebug@@YA_NPADZZ PROC				; LogOnDebug, COMDAT

; 1821 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1822 : 	static DWORD* pTombWind4 = (DWORD*) 0x75385C;  //  ;HandleWindowMain
; 1823 : 	static char MyInternalBuffer[512];
; 1824 : 
; 1825 : 	if (Trng.TestDebugMode == false) return false;

  0001e	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+32, 0
  00025	75 04		 jne	 SHORT $LN2@LogOnDebug
  00027	32 c0		 xor	 al, al
  00029	eb 4b		 jmp	 SHORT $LN3@LogOnDebug
$LN2@LogOnDebug:

; 1826 : 	if (*pTombWind4 == 0) return false;

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pTombWind4@?1??LogOnDebug@@YA_NPADZZ@4PAKA
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 04		 jne	 SHORT $LN1@LogOnDebug
  00035	32 c0		 xor	 al, al
  00037	eb 3d		 jmp	 SHORT $LN3@LogOnDebug
$LN1@LogOnDebug:

; 1827 : 
; 1828 :     va_list pArgs;
; 1829 :     va_start(pArgs, szFormat);

  00039	8d 45 0c	 lea	 eax, DWORD PTR _szFormat$[ebp+4]
  0003c	89 45 f8	 mov	 DWORD PTR _pArgs$[ebp], eax

; 1830 :     vsprintf(MyInternalBuffer, szFormat, pArgs);

  0003f	8b f4		 mov	 esi, esp
  00041	8b 45 f8	 mov	 eax, DWORD PTR _pArgs$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _szFormat$[ebp]
  00048	51		 push	 ecx
  00049	68 00 00 00 00	 push	 OFFSET ?MyInternalBuffer@?1??LogOnDebug@@YA_NPADZZ@4PADA
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1831 :     va_end(pArgs);

  0005e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pArgs$[ebp], 0

; 1832 : 
; 1833 : 	Service(SRV_F_InviaLog, MyInternalBuffer);

  00065	68 00 00 00 00	 push	 OFFSET ?MyInternalBuffer@?1??LogOnDebug@@YA_NPADZZ@4PADA
  0006a	6a 18		 push	 24			; 00000018H
  0006c	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00071	83 c4 08	 add	 esp, 8

; 1834 : 
; 1835 : 	return true;

  00074	b0 01		 mov	 al, 1
$LN3@LogOnDebug:

; 1836 : 
; 1837 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?LogOnDebug@@YA_NPADZZ ENDP				; LogOnDebug
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	?Float2Int@@YAHM@Z				; Float2Int
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Float2Int@@YAHM@Z
_TEXT	SEGMENT
tv70 = -200						; size = 8
_x$ = 8							; size = 4
?Float2Int@@YAHM@Z PROC					; Float2Int, COMDAT

; 1841 : { 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 38 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-200]
  00012	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1842 :     return (int)(x > 0.0 ? x + 0.5 : x - 0.5); 

  0001e	d9 45 08	 fld	 DWORD PTR _x$[ebp]
  00021	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@0000000000000000
  00027	df e0		 fnstsw	 ax
  00029	f6 c4 41	 test	 ah, 65			; 00000041H
  0002c	75 11		 jne	 SHORT $LN3@Float2Int
  0002e	d9 45 08	 fld	 DWORD PTR _x$[ebp]
  00031	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  00037	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv70[ebp]
  0003d	eb 0f		 jmp	 SHORT $LN4@Float2Int
$LN3@Float2Int:
  0003f	d9 45 08	 fld	 DWORD PTR _x$[ebp]
  00042	dc 25 00 00 00
	00		 fsub	 QWORD PTR __real@3fe0000000000000
  00048	dd 9d 38 ff ff
	ff		 fstp	 QWORD PTR tv70[ebp]
$LN4@Float2Int:
  0004e	dd 85 38 ff ff
	ff		 fld	 QWORD PTR tv70[ebp]
  00054	e8 00 00 00 00	 call	 __ftol2_sse

; 1843 : 
; 1844 : } 

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	81 c4 c8 00 00
	00		 add	 esp, 200		; 000000c8H
  00062	3b ec		 cmp	 ebp, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?Float2Int@@YAHM@Z ENDP					; Float2Int
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
PUBLIC	?pow@@YAMMH@Z					; pow
PUBLIC	?GetDistanceXZY@@YAHKHKKHK@Z			; GetDistanceXZY
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetDistanceXZY@@YAHKHKKHK@Z
_TEXT	SEGMENT
tv173 = -248						; size = 4
tv184 = -244						; size = 8
tv149 = -244						; size = 8
tv138 = -244						; size = 8
tv182 = -236						; size = 8
tv145 = -236						; size = 8
tv134 = -236						; size = 8
_DifY$ = -32						; size = 4
_DifZ$ = -20						; size = 4
_DifX$ = -8						; size = 4
_SourceX$ = 8						; size = 4
_SourceY$ = 12						; size = 4
_SourceZ$ = 16						; size = 4
_TargetX$ = 20						; size = 4
_TargetY$ = 24						; size = 4
_TargetZ$ = 28						; size = 4
?GetDistanceXZY@@YAHKHKKHK@Z PROC			; GetDistanceXZY, COMDAT

; 1848 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1849 : 	float DifX, DifZ, DifY;
; 1850 : 
; 1851 : 	DifX = (float) SourceX - (float) TargetX;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _SourceX$[ebp]
  00021	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv134[ebp], eax
  00027	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp+4], 0
  00031	df ad 14 ff ff
	ff		 fild	 QWORD PTR tv134[ebp]
  00037	8b 4d 14	 mov	 ecx, DWORD PTR _TargetX$[ebp]
  0003a	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv138[ebp], ecx
  00040	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp+4], 0
  0004a	df ad 0c ff ff
	ff		 fild	 QWORD PTR tv138[ebp]
  00050	de e9		 fsubp	 ST(1), ST(0)
  00052	d9 5d f8	 fstp	 DWORD PTR _DifX$[ebp]

; 1852 : 	DifZ = (float) SourceZ - (float) TargetZ;

  00055	8b 45 10	 mov	 eax, DWORD PTR _SourceZ$[ebp]
  00058	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv145[ebp], eax
  0005e	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv145[ebp+4], 0
  00068	df ad 14 ff ff
	ff		 fild	 QWORD PTR tv145[ebp]
  0006e	8b 4d 1c	 mov	 ecx, DWORD PTR _TargetZ$[ebp]
  00071	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv149[ebp], ecx
  00077	c7 85 10 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv149[ebp+4], 0
  00081	df ad 0c ff ff
	ff		 fild	 QWORD PTR tv149[ebp]
  00087	de e9		 fsubp	 ST(1), ST(0)
  00089	d9 5d ec	 fstp	 DWORD PTR _DifZ$[ebp]

; 1853 : 	DifY = (float) SourceY - (float) TargetY;

  0008c	db 45 0c	 fild	 DWORD PTR _SourceY$[ebp]
  0008f	da 65 18	 fisub	 DWORD PTR _TargetY$[ebp]
  00092	d9 5d e0	 fstp	 DWORD PTR _DifY$[ebp]

; 1854 : 
; 1855 : 	return Float2Int((float) sqrt(
; 1856 : 			pow(DifX,2) +
; 1857 : 			pow(DifZ,2) +
; 1858 : 			pow(DifY,2)));

  00095	6a 02		 push	 2
  00097	51		 push	 ecx
  00098	d9 45 f8	 fld	 DWORD PTR _DifX$[ebp]
  0009b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0009e	e8 00 00 00 00	 call	 ?pow@@YAMMH@Z		; pow
  000a3	83 c4 08	 add	 esp, 8
  000a6	6a 02		 push	 2
  000a8	51		 push	 ecx
  000a9	d9 45 ec	 fld	 DWORD PTR _DifZ$[ebp]
  000ac	d9 1c 24	 fstp	 DWORD PTR [esp]
  000af	dd 9d 14 ff ff
	ff		 fstp	 QWORD PTR tv182[ebp]
  000b5	e8 00 00 00 00	 call	 ?pow@@YAMMH@Z		; pow
  000ba	83 c4 08	 add	 esp, 8
  000bd	dc 85 14 ff ff
	ff		 fadd	 QWORD PTR tv182[ebp]
  000c3	6a 02		 push	 2
  000c5	51		 push	 ecx
  000c6	d9 45 e0	 fld	 DWORD PTR _DifY$[ebp]
  000c9	d9 1c 24	 fstp	 DWORD PTR [esp]
  000cc	dd 9d 0c ff ff
	ff		 fstp	 QWORD PTR tv184[ebp]
  000d2	e8 00 00 00 00	 call	 ?pow@@YAMMH@Z		; pow
  000d7	83 c4 08	 add	 esp, 8
  000da	dc 85 0c ff ff
	ff		 fadd	 QWORD PTR tv184[ebp]
  000e0	d9 9d 08 ff ff
	ff		 fstp	 DWORD PTR tv173[ebp]
  000e6	d9 85 08 ff ff
	ff		 fld	 DWORD PTR tv173[ebp]
  000ec	51		 push	 ecx
  000ed	d9 1c 24	 fstp	 DWORD PTR [esp]
  000f0	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  000f5	d9 1c 24	 fstp	 DWORD PTR [esp]
  000f8	e8 00 00 00 00	 call	 ?Float2Int@@YAHM@Z	; Float2Int
  000fd	83 c4 04	 add	 esp, 4

; 1859 : 
; 1860 : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00109	3b ec		 cmp	 ebp, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
?GetDistanceXZY@@YAHKHKKHK@Z ENDP			; GetDistanceXZY
_TEXT	ENDS
PUBLIC	??$_Pow_int@M@@YAMMH@Z				; _Pow_int<float>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT ?pow@@YAMMH@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
?pow@@YAMMH@Z PROC					; pow, COMDAT

; 536  :         {return (_Pow_int(_X, _Y)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Y$[ebp]
  00021	50		 push	 eax
  00022	51		 push	 ecx
  00023	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00026	d9 1c 24	 fstp	 DWORD PTR [esp]
  00029	e8 00 00 00 00	 call	 ??$_Pow_int@M@@YAMMH@Z	; _Pow_int<float>
  0002e	83 c4 08	 add	 esp, 8
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?pow@@YAMMH@Z ENDP					; pow
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	51		 push	 ecx
  0001f	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00022	d9 1c 24	 fstp	 DWORD PTR [esp]
  00025	e8 00 00 00 00	 call	 _sqrtf
  0002a	83 c4 04	 add	 esp, 4
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -196						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00021	83 ec 08	 sub	 esp, 8
  00024	dd 1c 24	 fstp	 QWORD PTR [esp]
  00027	e8 00 00 00 00	 call	 _sqrt
  0002c	83 c4 08	 add	 esp, 8
  0002f	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv73[ebp]
  00035	d9 85 3c ff ff
	ff		 fld	 DWORD PTR tv73[ebp]
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?GetDistanceXZ@@YAHKKKK@Z			; GetDistanceXZ
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\trng.cpp
;	COMDAT ?GetDistanceXZ@@YAHKKKK@Z
_TEXT	SEGMENT
tv138 = -232						; size = 8
tv95 = -232						; size = 8
tv154 = -228						; size = 4
tv163 = -224						; size = 8
tv134 = -224						; size = 8
tv91 = -224						; size = 8
_DifZ$ = -20						; size = 4
_DifX$ = -8						; size = 4
_SourceX$ = 8						; size = 4
_SourceZ$ = 12						; size = 4
_TargetX$ = 16						; size = 4
_TargetZ$ = 20						; size = 4
?GetDistanceXZ@@YAHKKKK@Z PROC				; GetDistanceXZ, COMDAT

; 1865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1866 : 	float DifX, DifZ;
; 1867 : 
; 1868 : 	DifX = (float) SourceX - (float) TargetX;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _SourceX$[ebp]
  00021	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv91[ebp], eax
  00027	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv91[ebp+4], 0
  00031	df ad 20 ff ff
	ff		 fild	 QWORD PTR tv91[ebp]
  00037	8b 4d 10	 mov	 ecx, DWORD PTR _TargetX$[ebp]
  0003a	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  00040	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv95[ebp+4], 0
  0004a	df ad 18 ff ff
	ff		 fild	 QWORD PTR tv95[ebp]
  00050	de e9		 fsubp	 ST(1), ST(0)
  00052	d9 5d f8	 fstp	 DWORD PTR _DifX$[ebp]

; 1869 : 	DifZ = (float) SourceZ - (float) TargetZ;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _SourceZ$[ebp]
  00058	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv134[ebp], eax
  0005e	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv134[ebp+4], 0
  00068	df ad 20 ff ff
	ff		 fild	 QWORD PTR tv134[ebp]
  0006e	8b 4d 14	 mov	 ecx, DWORD PTR _TargetZ$[ebp]
  00071	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv138[ebp], ecx
  00077	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv138[ebp+4], 0
  00081	df ad 18 ff ff
	ff		 fild	 QWORD PTR tv138[ebp]
  00087	de e9		 fsubp	 ST(1), ST(0)
  00089	d9 5d ec	 fstp	 DWORD PTR _DifZ$[ebp]

; 1870 : 
; 1871 : 	return Float2Int((float) sqrt(
; 1872 : 			pow(DifX,2) +
; 1873 : 			pow(DifZ,2)));

  0008c	6a 02		 push	 2
  0008e	51		 push	 ecx
  0008f	d9 45 f8	 fld	 DWORD PTR _DifX$[ebp]
  00092	d9 1c 24	 fstp	 DWORD PTR [esp]
  00095	e8 00 00 00 00	 call	 ?pow@@YAMMH@Z		; pow
  0009a	83 c4 08	 add	 esp, 8
  0009d	6a 02		 push	 2
  0009f	51		 push	 ecx
  000a0	d9 45 ec	 fld	 DWORD PTR _DifZ$[ebp]
  000a3	d9 1c 24	 fstp	 DWORD PTR [esp]
  000a6	dd 9d 20 ff ff
	ff		 fstp	 QWORD PTR tv163[ebp]
  000ac	e8 00 00 00 00	 call	 ?pow@@YAMMH@Z		; pow
  000b1	83 c4 08	 add	 esp, 8
  000b4	dc 85 20 ff ff
	ff		 fadd	 QWORD PTR tv163[ebp]
  000ba	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR tv154[ebp]
  000c0	d9 85 1c ff ff
	ff		 fld	 DWORD PTR tv154[ebp]
  000c6	51		 push	 ecx
  000c7	d9 1c 24	 fstp	 DWORD PTR [esp]
  000ca	e8 00 00 00 00	 call	 ?sqrt@@YAMM@Z		; sqrt
  000cf	d9 1c 24	 fstp	 DWORD PTR [esp]
  000d2	e8 00 00 00 00	 call	 ?Float2Int@@YAHM@Z	; Float2Int
  000d7	83 c4 04	 add	 esp, 4

; 1874 : 
; 1875 : }

  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	5b		 pop	 ebx
  000dd	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000e3	3b ec		 cmp	 ebp, esp
  000e5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
?GetDistanceXZ@@YAHKKKK@Z ENDP				; GetDistanceXZ
_TEXT	ENDS
PUBLIC	?GetMaxDistance@@YAHPAK0_N@Z			; GetMaxDistance
EXTRN	__RTC_UninitUse:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetMaxDistance@@YAHPAK0_N@Z
_TEXT	SEGMENT
$T47000 = -245						; size = 1
_MaxDif$ = -44						; size = 4
_DifZ$ = -32						; size = 4
_DifY$ = -20						; size = 4
_DifX$ = -8						; size = 4
_pSource$ = 8						; size = 4
_pTarget$ = 12						; size = 4
_TestIgnoreY$ = 16					; size = 1
?GetMaxDistance@@YAHPAK0_N@Z PROC			; GetMaxDistance, COMDAT

; 1880 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 0b ff ff
	ff 00		 mov	 BYTE PTR $T47000[ebp], 0

; 1881 : 	DWORD DifX;
; 1882 : 	DWORD DifY;
; 1883 : 	DWORD DifZ;
; 1884 : 	DWORD MaxDif;
; 1885 : 
; 1886 : 	DifX = AbsDiff(pSource[0], pTarget[0] );

  00025	8b 45 0c	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	8b 55 08	 mov	 edx, DWORD PTR _pSource$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?AbsDiff@@YAHKK@Z	; AbsDiff
  00036	83 c4 08	 add	 esp, 8
  00039	89 45 f8	 mov	 DWORD PTR _DifX$[ebp], eax

; 1887 : 	if (TestIgnoreY==false) {

  0003c	0f b6 45 10	 movzx	 eax, BYTE PTR _TestIgnoreY$[ebp]
  00040	85 c0		 test	 eax, eax
  00042	75 20		 jne	 SHORT $LN4@GetMaxDist

; 1888 : 		DifY = AbsDiff(pSource[1],pTarget[1]);

  00044	8b 45 0c	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00047	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR _pSource$[ebp]
  0004e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?AbsDiff@@YAHKK@Z	; AbsDiff
  00057	83 c4 08	 add	 esp, 8
  0005a	c6 85 0b ff ff
	ff 01		 mov	 BYTE PTR $T47000[ebp], 1
  00061	89 45 ec	 mov	 DWORD PTR _DifY$[ebp], eax
$LN4@GetMaxDist:

; 1889 : 	}
; 1890 : 	DifZ = AbsDiff(pSource[2],pTarget[2]);

  00064	8b 45 0c	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00067	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0006a	51		 push	 ecx
  0006b	8b 55 08	 mov	 edx, DWORD PTR _pSource$[ebp]
  0006e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?AbsDiff@@YAHKK@Z	; AbsDiff
  00077	83 c4 08	 add	 esp, 8
  0007a	89 45 e0	 mov	 DWORD PTR _DifZ$[ebp], eax

; 1891 : 
; 1892 : 	MaxDif= DifX;

  0007d	8b 45 f8	 mov	 eax, DWORD PTR _DifX$[ebp]
  00080	89 45 d4	 mov	 DWORD PTR _MaxDif$[ebp], eax

; 1893 : 	if (TestIgnoreY==false) {

  00083	0f b6 45 10	 movzx	 eax, BYTE PTR _TestIgnoreY$[ebp]
  00087	85 c0		 test	 eax, eax
  00089	75 3a		 jne	 SHORT $LN3@GetMaxDist

; 1894 : 		if (DifY > MaxDif) MaxDif = DifY;

  0008b	80 bd 0b ff ff
	ff 00		 cmp	 BYTE PTR $T47000[ebp], 0
  00092	75 0d		 jne	 SHORT $LN7@GetMaxDist
  00094	68 00 00 00 00	 push	 OFFSET $LN8@GetMaxDist
  00099	e8 00 00 00 00	 call	 __RTC_UninitUse
  0009e	83 c4 04	 add	 esp, 4
$LN7@GetMaxDist:
  000a1	8b 45 ec	 mov	 eax, DWORD PTR _DifY$[ebp]
  000a4	3b 45 d4	 cmp	 eax, DWORD PTR _MaxDif$[ebp]
  000a7	76 1c		 jbe	 SHORT $LN3@GetMaxDist
  000a9	80 bd 0b ff ff
	ff 00		 cmp	 BYTE PTR $T47000[ebp], 0
  000b0	75 0d		 jne	 SHORT $LN9@GetMaxDist
  000b2	68 00 00 00 00	 push	 OFFSET $LN8@GetMaxDist
  000b7	e8 00 00 00 00	 call	 __RTC_UninitUse
  000bc	83 c4 04	 add	 esp, 4
$LN9@GetMaxDist:
  000bf	8b 45 ec	 mov	 eax, DWORD PTR _DifY$[ebp]
  000c2	89 45 d4	 mov	 DWORD PTR _MaxDif$[ebp], eax
$LN3@GetMaxDist:

; 1895 : 	}
; 1896 : 	if (DifZ > MaxDif) MaxDif = DifZ;

  000c5	8b 45 e0	 mov	 eax, DWORD PTR _DifZ$[ebp]
  000c8	3b 45 d4	 cmp	 eax, DWORD PTR _MaxDif$[ebp]
  000cb	76 06		 jbe	 SHORT $LN1@GetMaxDist
  000cd	8b 45 e0	 mov	 eax, DWORD PTR _DifZ$[ebp]
  000d0	89 45 d4	 mov	 DWORD PTR _MaxDif$[ebp], eax
$LN1@GetMaxDist:

; 1897 : 	return MaxDif;

  000d3	8b 45 d4	 mov	 eax, DWORD PTR _MaxDif$[ebp]

; 1898 : 
; 1899 : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000df	3b ec		 cmp	 ebp, esp
  000e1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
$LN10@GetMaxDist:
$LN8@GetMaxDist:
  000ea	44		 DB	 68			; 00000044H
  000eb	69		 DB	 105			; 00000069H
  000ec	66		 DB	 102			; 00000066H
  000ed	59		 DB	 89			; 00000059H
  000ee	00		 DB	 0
?GetMaxDistance@@YAHPAK0_N@Z ENDP			; GetMaxDistance
_TEXT	ENDS
PUBLIC	?ForceAnimationForItem@@YAXPAUStrItemTr4@@HH@Z	; ForceAnimationForItem
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ForceAnimationForItem@@YAXPAUStrItemTr4@@HH@Z
_TEXT	SEGMENT
_pItem$ = 8						; size = 4
_NumAnimation$ = 12					; size = 4
_NextStateId$ = 16					; size = 4
?ForceAnimationForItem@@YAXPAUStrItemTr4@@HH@Z PROC	; ForceAnimationForItem, COMDAT

; 1904 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1905 : 	Service(SRV_F_EseguiAnimNemico, pItem, NumAnimation, NextStateId);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _NextStateId$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR _NumAnimation$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  00029	52		 push	 edx
  0002a	6a 19		 push	 25			; 00000019H
  0002c	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 1906 : 
; 1907 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?ForceAnimationForItem@@YAXPAUStrItemTr4@@HH@Z ENDP	; ForceAnimationForItem
_TEXT	ENDS
PUBLIC	?PrintText@@YAXHHPADGHG@Z			; PrintText
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PrintText@@YAXHHPADGHG@Z
_TEXT	SEGMENT
_CordX$ = 8						; size = 4
_CordY$ = 12						; size = 4
_pText$ = 16						; size = 4
_FTflags$ = 20						; size = 2
_FCindex$ = 24						; size = 4
_FTSflags$ = 28						; size = 2
?PrintText@@YAXHHPADGHG@Z PROC				; PrintText, COMDAT

; 1917 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1918 : 	Service(SRV_F_PrintText, CordX, CordY, pText, FTflags, FCindex, FTSflags);

  0001e	0f b7 45 1c	 movzx	 eax, WORD PTR _FTSflags$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 18	 mov	 ecx, DWORD PTR _FCindex$[ebp]
  00026	51		 push	 ecx
  00027	0f b7 55 14	 movzx	 edx, WORD PTR _FTflags$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 10	 mov	 eax, DWORD PTR _pText$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR _CordY$[ebp]
  00033	51		 push	 ecx
  00034	8b 55 08	 mov	 edx, DWORD PTR _CordX$[ebp]
  00037	52		 push	 edx
  00038	6a 32		 push	 50			; 00000032H
  0003a	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0003f	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1919 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?PrintText@@YAXHHPADGHG@Z ENDP				; PrintText
_TEXT	ENDS
PUBLIC	??_C@_0CM@HFDDJGMI@ERROR?3?5missing?5animation?5number?5@ ; `string'
PUBLIC	?ForceAnimationForLara@@YAXHH@Z			; ForceAnimationForLara
;	COMDAT ??_C@_0CM@HFDDJGMI@ERROR?3?5missing?5animation?5number?5@
CONST	SEGMENT
??_C@_0CM@HFDDJGMI@ERROR?3?5missing?5animation?5number?5@ DB 'ERROR: miss'
	DB	'ing animation number %d for Lara', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?ForceAnimationForLara@@YAXHH@Z
_TEXT	SEGMENT
_pAnim$ = -44						; size = 4
_pLara$ = -32						; size = 4
_IndexAnim$ = -20					; size = 4
_StartAnim$ = -8					; size = 4
_NumAnimation$ = 8					; size = 4
_NextStateId$ = 12					; size = 4
?ForceAnimationForLara@@YAXHH@Z PROC			; ForceAnimationForLara, COMDAT

; 1923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1924 : 	int StartAnim;
; 1925 : 	int IndexAnim;
; 1926 : 	StrItemTr4 *pLara;
; 1927 : 	StrAnimationTr4 * pAnim;
; 1928 : 
; 1929 : 	pLara = Trng.pGlobTomb4->pAdr->pLara;

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 55 e0	 mov	 DWORD PTR _pLara$[ebp], edx

; 1930 : 
; 1931 : 	StartAnim= Trng.pGlobTomb4->pAdr->pVetSlot[0].IndexFirstAnim;

  0002e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00033	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00039	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0003c	0f b7 42 26	 movzx	 eax, WORD PTR [edx+38]
  00040	89 45 f8	 mov	 DWORD PTR _StartAnim$[ebp], eax

; 1932 : 	IndexAnim = StartAnim+NumAnimation;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _StartAnim$[ebp]
  00046	03 45 08	 add	 eax, DWORD PTR _NumAnimation$[ebp]
  00049	89 45 ec	 mov	 DWORD PTR _IndexAnim$[ebp], eax

; 1933 : 
; 1934 : 	pAnim = &Trng.pGlobTomb4->pAdr->pVetAnimations[IndexAnim];

  0004c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00051	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00057	8b 55 ec	 mov	 edx, DWORD PTR _IndexAnim$[ebp]
  0005a	6b d2 28	 imul	 edx, 40			; 00000028H
  0005d	03 51 30	 add	 edx, DWORD PTR [ecx+48]
  00060	89 55 d4	 mov	 DWORD PTR _pAnim$[ebp], edx

; 1935 : 
; 1936 : 
; 1937 : 	// if current lara animation is already the same to set: quit
; 1938 : 	if (pLara->AnimationNow == IndexAnim) return;

  00063	8b 45 e0	 mov	 eax, DWORD PTR _pLara$[ebp]
  00066	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0006a	3b 4d ec	 cmp	 ecx, DWORD PTR _IndexAnim$[ebp]
  0006d	75 02		 jne	 SHORT $LN3@ForceAnima
  0006f	eb 64		 jmp	 SHORT $LN4@ForceAnima
$LN3@ForceAnima:

; 1939 : 
; 1940 : 	// verifiy that wished animation existed really
; 1941 : 	if (pAnim->FrameSize == 0) {

  00071	8b 45 d4	 mov	 eax, DWORD PTR _pAnim$[ebp]
  00074	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00078	85 c9		 test	 ecx, ecx
  0007a	75 13		 jne	 SHORT $LN2@ForceAnima

; 1942 : 		SendToLog("ERROR: missing animation number %d for Lara", NumAnimation);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _NumAnimation$[ebp]
  0007f	50		 push	 eax
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@HFDDJGMI@ERROR?3?5missing?5animation?5number?5@
  00085	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0008a	83 c4 08	 add	 esp, 8

; 1943 : 		return;

  0008d	eb 46		 jmp	 SHORT $LN4@ForceAnima
$LN2@ForceAnima:

; 1944 : 	}
; 1945 : 
; 1946 : 	pLara->FrameNow = pAnim->FrameStart;

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _pLara$[ebp]
  00092	8b 4d d4	 mov	 ecx, DWORD PTR _pAnim$[ebp]
  00095	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00099	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 1947 : 	pLara->StateIdCurrent = pAnim->StateId;

  0009d	8b 45 e0	 mov	 eax, DWORD PTR _pLara$[ebp]
  000a0	8b 4d d4	 mov	 ecx, DWORD PTR _pAnim$[ebp]
  000a3	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  000a7	66 89 50 0e	 mov	 WORD PTR [eax+14], dx

; 1948 : 	pLara->StateIdNext = pAnim->StateId;

  000ab	8b 45 e0	 mov	 eax, DWORD PTR _pLara$[ebp]
  000ae	8b 4d d4	 mov	 ecx, DWORD PTR _pAnim$[ebp]
  000b1	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  000b5	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 1949 : 
; 1950 : 	if (NextStateId != -1) {

  000b9	83 7d 0c ff	 cmp	 DWORD PTR _NextStateId$[ebp], -1
  000bd	74 0b		 je	 SHORT $LN1@ForceAnima

; 1951 : 		pLara->StateIdNext = NextStateId;

  000bf	8b 45 e0	 mov	 eax, DWORD PTR _pLara$[ebp]
  000c2	66 8b 4d 0c	 mov	 cx, WORD PTR _NextStateId$[ebp]
  000c6	66 89 48 10	 mov	 WORD PTR [eax+16], cx
$LN1@ForceAnima:

; 1952 : 	}
; 1953 : 
; 1954 : 	pLara->AnimationNow = IndexAnim;

  000ca	8b 45 e0	 mov	 eax, DWORD PTR _pLara$[ebp]
  000cd	66 8b 4d ec	 mov	 cx, WORD PTR _IndexAnim$[ebp]
  000d1	66 89 48 14	 mov	 WORD PTR [eax+20], cx
$LN4@ForceAnima:

; 1955 : 	
; 1956 : 	
; 1957 : }

  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi
  000d7	5b		 pop	 ebx
  000d8	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000de	3b ec		 cmp	 ebp, esp
  000e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
?ForceAnimationForLara@@YAXHH@Z ENDP			; ForceAnimationForLara
_TEXT	ENDS
PUBLIC	?DistanceProp@@YAHHH@Z				; DistanceProp
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DistanceProp@@YAHHH@Z
_TEXT	SEGMENT
_Incremento$ = 8					; size = 4
_Distanza$ = 12						; size = 4
?DistanceProp@@YAHHH@Z PROC				; DistanceProp, COMDAT

; 1963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1964 : 
; 1965 : 	return Service(SRV_F_ProporzioneDistanza, Incremento, Distanza);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _Distanza$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _Incremento$[ebp]
  00025	51		 push	 ecx
  00026	6a 0e		 push	 14			; 0000000eH
  00028	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1966 : 
; 1967 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?DistanceProp@@YAHHH@Z ENDP				; DistanceProp
_TEXT	ENDS
PUBLIC	?FromNgleIndexToTomb4Index@@YAHH@Z		; FromNgleIndexToTomb4Index
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FromNgleIndexToTomb4Index@@YAHH@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_NgleIndex$ = 8						; size = 4
?FromNgleIndexToTomb4Index@@YAHH@Z PROC			; FromNgleIndexToTomb4Index, COMDAT

; 1974 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1975 : 	int i;
; 1976 : 
; 1977 : 	i= Trng.pGlobTomb4->VetRemapObjects[NgleIndex];

  0001e	8b 45 08	 mov	 eax, DWORD PTR _NgleIndex$[ebp]
  00021	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00027	0f bf 94 41 74
	2c 1a 00	 movsx	 edx, WORD PTR [ecx+eax*2+1715316]
  0002f	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 1978 : #ifdef DEBUG_ON
; 1979 : 	if (i == -1) {
; 1980 : 		SendToLog("ERROR: the Ngle index %d doesn't correspond to any tomb4 index",
; 1981 : 			NgleIndex);
; 1982 : 	}
; 1983 : #endif
; 1984 : 	
; 1985 : 	return i;

  00032	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 1986 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?FromNgleIndexToTomb4Index@@YAHH@Z ENDP			; FromNgleIndexToTomb4Index
_TEXT	ENDS
PUBLIC	??_C@_0FE@OBHJENKO@ERROR?3?5cann?8t?5find?5the?5ngle?5stat@ ; `string'
PUBLIC	?FromStaticIndicesToNgleIndex@@YAHHH@Z		; FromStaticIndicesToNgleIndex
;	COMDAT ??_C@_0FE@OBHJENKO@ERROR?3?5cann?8t?5find?5the?5ngle?5stat@
CONST	SEGMENT
??_C@_0FE@OBHJENKO@ERROR?3?5cann?8t?5find?5the?5ngle?5stat@ DB 'ERROR: ca'
	DB	'nn''t find the ngle static index that matched with (room=%d S'
	DB	'taticIndex=%d)', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?FromStaticIndicesToNgleIndex@@YAHHH@Z
_TEXT	SEGMENT
_i$ = -20						; size = 4
_pDouble$ = -8						; size = 4
_RoomIndex$ = 8						; size = 4
_StaticIndex$ = 12					; size = 4
?FromStaticIndicesToNgleIndex@@YAHHH@Z PROC		; FromStaticIndicesToNgleIndex, COMDAT

; 1993 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1994 : 	StrCercaStatic *pDouble;
; 1995 : 	int i;
; 1996 : 
; 1997 : 	pDouble = &Trng.pGlobTomb4->VetRemapStatics[0];

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	05 96 66 09 00	 add	 eax, 616086		; 00096696H
  00028	89 45 f8	 mov	 DWORD PTR _pDouble$[ebp], eax

; 1998 : 
; 1999 : 	for (i=0;i<6000;i++) {

  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN4@FromStatic
$LN3@FromStatic:
  00034	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FromStatic:
  0003d	81 7d ec 70 17
	00 00		 cmp	 DWORD PTR _i$[ebp], 6000 ; 00001770H
  00044	7d 27		 jge	 SHORT $LN2@FromStatic

; 2000 : 		if (pDouble->IndiceRoom == RoomIndex &&
; 2001 : 			pDouble->IndiceStatic == StaticIndex) {

  00046	8b 45 f8	 mov	 eax, DWORD PTR _pDouble$[ebp]
  00049	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0004c	3b 4d 08	 cmp	 ecx, DWORD PTR _RoomIndex$[ebp]
  0004f	75 11		 jne	 SHORT $LN1@FromStatic
  00051	8b 45 f8	 mov	 eax, DWORD PTR _pDouble$[ebp]
  00054	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00058	3b 4d 0c	 cmp	 ecx, DWORD PTR _StaticIndex$[ebp]
  0005b	75 05		 jne	 SHORT $LN1@FromStatic

; 2002 : 			// found
; 2003 : 			return i;

  0005d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00060	eb 23		 jmp	 SHORT $LN5@FromStatic
$LN1@FromStatic:

; 2004 : 		}
; 2005 : 		pDouble++;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _pDouble$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	89 45 f8	 mov	 DWORD PTR _pDouble$[ebp], eax

; 2006 : 	}

  0006b	eb c7		 jmp	 SHORT $LN3@FromStatic
$LN2@FromStatic:

; 2007 : 
; 2008 : 	SendToLog("ERROR: cann't find the ngle static index that matched with (room=%d StaticIndex=%d)",
; 2009 : 		RoomIndex, StaticIndex);

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  00070	50		 push	 eax
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _RoomIndex$[ebp]
  00074	51		 push	 ecx
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@OBHJENKO@ERROR?3?5cann?8t?5find?5the?5ngle?5stat@
  0007a	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2010 : 	return -1;

  00082	83 c8 ff	 or	 eax, -1
$LN5@FromStatic:

; 2011 : 
; 2012 : }

  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?FromStaticIndicesToNgleIndex@@YAHHH@Z ENDP		; FromStaticIndicesToNgleIndex
_TEXT	ENDS
PUBLIC	?CreateNgleStaticIndex@@YAHHH@Z			; CreateNgleStaticIndex
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CreateNgleStaticIndex@@YAHHH@Z
_TEXT	SEGMENT
_NgleStaticIndex$ = -20					; size = 4
_pDouble$ = -8						; size = 4
_RoomIndex$ = 8						; size = 4
_StaticIndex$ = 12					; size = 4
?CreateNgleStaticIndex@@YAHHH@Z PROC			; CreateNgleStaticIndex, COMDAT

; 2017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2018 : 	StrCercaStatic *pDouble;
; 2019 : 	int NgleStaticIndex;
; 2020 : 
; 2021 : 	NgleStaticIndex=6000;

  0001e	c7 45 ec 70 17
	00 00		 mov	 DWORD PTR _NgleStaticIndex$[ebp], 6000 ; 00001770H

; 2022 : 	pDouble = &Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex];

  00025	8b 45 ec	 mov	 eax, DWORD PTR _NgleStaticIndex$[ebp]
  00028	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0002e	8d 94 81 96 66
	09 00		 lea	 edx, DWORD PTR [ecx+eax*4+616086]
  00035	89 55 f8	 mov	 DWORD PTR _pDouble$[ebp], edx

; 2023 : 
; 2024 : 	pDouble->IndiceRoom = RoomIndex;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _pDouble$[ebp]
  0003b	66 8b 4d 08	 mov	 cx, WORD PTR _RoomIndex$[ebp]
  0003f	66 89 08	 mov	 WORD PTR [eax], cx

; 2025 : 	pDouble->IndiceStatic = StaticIndex;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pDouble$[ebp]
  00045	66 8b 4d 0c	 mov	 cx, WORD PTR _StaticIndex$[ebp]
  00049	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 2026 : 
; 2027 : 	return NgleStaticIndex;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _NgleStaticIndex$[ebp]

; 2028 : 
; 2029 : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?CreateNgleStaticIndex@@YAHHH@Z ENDP			; CreateNgleStaticIndex
_TEXT	ENDS
PUBLIC	?UpdateItemRoom@@YA_NH@Z			; UpdateItemRoom
EXTRN	?ItemNewRoom@@3P6AXHG@ZA:DWORD			; ItemNewRoom
EXTRN	?GetFloor@@3P6APAXKHKPAF@ZA:DWORD		; GetFloor
EXTRN	@_RTC_CheckStackVars@8:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?UpdateItemRoom@@YA_NH@Z
_TEXT	SEGMENT
_Index$ = -32						; size = 4
_pItem$ = -20						; size = 4
_NewRoom$ = -8						; size = 2
_ItemIndex$ = 8						; size = 4
?UpdateItemRoom@@YA_NH@Z PROC				; UpdateItemRoom, COMDAT

; 2036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2037 : 	short NewRoom;
; 2038 : 	StrItemTr4 *pItem;
; 2039 : 	int Index;
; 2040 : 
; 2041 : 	if (ItemIndex & NGLE_INDEX) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  00021	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00026	74 27		 je	 SHORT $LN3@UpdateItem

; 2042 : 		Index = ItemIndex & MASK_NGLE_INDEX;

  00028	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  0002b	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00030	89 45 e0	 mov	 DWORD PTR _Index$[ebp], eax

; 2043 : 		ItemIndex = FromNgleIndexToTomb4Index(Index);

  00033	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 08	 mov	 DWORD PTR _ItemIndex$[ebp], eax

; 2044 : 		if (ItemIndex == -1) return false;

  00042	83 7d 08 ff	 cmp	 DWORD PTR _ItemIndex$[ebp], -1
  00046	75 07		 jne	 SHORT $LN3@UpdateItem
  00048	32 c0		 xor	 al, al
  0004a	e9 80 00 00 00	 jmp	 $LN4@UpdateItem
$LN3@UpdateItem:

; 2045 : 	
; 2046 : 	}
; 2047 : 	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

  0004f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00054	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0005a	8b 55 08	 mov	 edx, DWORD PTR _ItemIndex$[ebp]
  0005d	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00063	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00066	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 2048 : 
; 2049 : 	NewRoom = pItem->Room;

  00069	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  0006c	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00070	66 89 4d f8	 mov	 WORD PTR _NewRoom$[ebp], cx

; 2050 : 
; 2051 : 	GetFloor(pItem->CordX, pItem->CordY, pItem->CordZ, &NewRoom);

  00074	8b f4		 mov	 esi, esp
  00076	8d 45 f8	 lea	 eax, DWORD PTR _NewRoom$[ebp]
  00079	50		 push	 eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0007d	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00080	52		 push	 edx
  00081	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00084	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00087	51		 push	 ecx
  00088	8b 55 ec	 mov	 edx, DWORD PTR _pItem$[ebp]
  0008b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetFloor@@3P6APAXKHKPAF@ZA ; GetFloor
  00095	83 c4 10	 add	 esp, 16			; 00000010H
  00098	3b f4		 cmp	 esi, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2052 : 	
; 2053 : 	if (NewRoom != pItem->Room) {

  0009f	0f bf 45 f8	 movsx	 eax, WORD PTR _NewRoom$[ebp]
  000a3	8b 4d ec	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000a6	0f bf 51 18	 movsx	 edx, WORD PTR [ecx+24]
  000aa	3b c2		 cmp	 eax, edx
  000ac	74 1f		 je	 SHORT $LN1@UpdateItem

; 2054 : 		// the room changed
; 2055 : 		ItemNewRoom(ItemIndex, NewRoom);

  000ae	8b f4		 mov	 esi, esp
  000b0	0f b7 45 f8	 movzx	 eax, WORD PTR _NewRoom$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d 08	 mov	 ecx, DWORD PTR _ItemIndex$[ebp]
  000b8	51		 push	 ecx
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR ?ItemNewRoom@@3P6AXHG@ZA ; ItemNewRoom
  000bf	83 c4 08	 add	 esp, 8
  000c2	3b f4		 cmp	 esi, esp
  000c4	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2056 : 		return true;

  000c9	b0 01		 mov	 al, 1
  000cb	eb 02		 jmp	 SHORT $LN4@UpdateItem
$LN1@UpdateItem:

; 2057 : 	}
; 2058 : 	return false;

  000cd	32 c0		 xor	 al, al
$LN4@UpdateItem:

; 2059 : }

  000cf	52		 push	 edx
  000d0	8b cd		 mov	 ecx, ebp
  000d2	50		 push	 eax
  000d3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@UpdateItem
  000d9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000de	58		 pop	 eax
  000df	5a		 pop	 edx
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000e9	3b ec		 cmp	 ebp, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
$LN8@UpdateItem:
  000f4	01 00 00 00	 DD	 1
  000f8	00 00 00 00	 DD	 $LN7@UpdateItem
$LN7@UpdateItem:
  000fc	f8 ff ff ff	 DD	 -8			; fffffff8H
  00100	02 00 00 00	 DD	 2
  00104	00 00 00 00	 DD	 $LN6@UpdateItem
$LN6@UpdateItem:
  00108	4e		 DB	 78			; 0000004eH
  00109	65		 DB	 101			; 00000065H
  0010a	77		 DB	 119			; 00000077H
  0010b	52		 DB	 82			; 00000052H
  0010c	6f		 DB	 111			; 0000006fH
  0010d	6f		 DB	 111			; 0000006fH
  0010e	6d		 DB	 109			; 0000006dH
  0010f	00		 DB	 0
?UpdateItemRoom@@YA_NH@Z ENDP				; UpdateItemRoom
_TEXT	ENDS
PUBLIC	?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z
_TEXT	SEGMENT
_Index$ = -8						; size = 4
_pTestPosition$ = 8					; size = 4
_ObjectIndex$ = 12					; size = 4
?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z PROC ; CheckPositionAlignment, COMDAT

; 2062 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2063 : 	int Index;
; 2064 : 
; 2065 : 
; 2066 : 
; 2067 : 	if (ObjectIndex & NGLE_INDEX) {

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  00021	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00026	74 1a		 je	 SHORT $LN3@CheckPosit

; 2068 : 		Index = ObjectIndex & MASK_NGLE_INDEX;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  0002b	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00030	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 2069 : 		ObjectIndex = FromNgleIndexToTomb4Index(Index);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 0c	 mov	 DWORD PTR _ObjectIndex$[ebp], eax
$LN3@CheckPosit:

; 2070 : 	
; 2071 : 	}	
; 2072 : 
; 2073 : 	if (ObjectIndex==-1) return false;

  00042	83 7d 0c ff	 cmp	 DWORD PTR _ObjectIndex$[ebp], -1
  00046	75 04		 jne	 SHORT $LN2@CheckPosit
  00048	32 c0		 xor	 al, al
  0004a	eb 1c		 jmp	 SHORT $LN4@CheckPosit
$LN2@CheckPosit:

; 2074 : 
; 2075 : 	if (Service(SRV_F_VerificaTestPosition, pTestPosition, ObjectIndex) ==0) return false;

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR _pTestPosition$[ebp]
  00053	51		 push	 ecx
  00054	6a 15		 push	 21			; 00000015H
  00056	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN1@CheckPosit
  00062	32 c0		 xor	 al, al
  00064	eb 02		 jmp	 SHORT $LN4@CheckPosit
$LN1@CheckPosit:

; 2076 : 
; 2077 : 	return true;

  00066	b0 01		 mov	 al, 1
$LN4@CheckPosit:

; 2078 : }

  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5b		 pop	 ebx
  0006b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00071	3b ec		 cmp	 ebp, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ENDP ; CheckPositionAlignment
_TEXT	ENDS
PUBLIC	?SignalMovedItem@@YAXH@Z			; SignalMovedItem
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SignalMovedItem@@YAXH@Z
_TEXT	SEGMENT
_IndexItem$ = 8						; size = 4
?SignalMovedItem@@YAXH@Z PROC				; SignalMovedItem, COMDAT

; 2081 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2082 : 	Service(SRV_F_AggiungiItemMosso, IndexItem);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IndexItem$[ebp]
  00021	50		 push	 eax
  00022	6a 26		 push	 38			; 00000026H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 2083 : 
; 2084 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?SignalMovedItem@@YAXH@Z ENDP				; SignalMovedItem
_TEXT	ENDS
PUBLIC	?BackupLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z ; BackupLara
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?BackupLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z
_TEXT	SEGMENT
_pCopiaOrientamento$ = -8				; size = 4
_pBack$ = 8						; size = 4
_pOggetto$ = 12						; size = 4
?BackupLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z PROC ; BackupLara, COMDAT

; 2087 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2088 : 	DWORD *pCopiaOrientamento = (DWORD *)  0x80DF64; //   ;ZonaSave_FB_CopiaOrientamento

  0001e	c7 45 f8 64 df
	80 00		 mov	 DWORD PTR _pCopiaOrientamento$[ebp], 8445796 ; 0080df64H

; 2089 : 
; 2090 : 	pBack->CopiaOrientamento = *pCopiaOrientamento;

  00025	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _pCopiaOrientamento$[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 2091 : 	pBack->AnimationNow  = pOggetto->AnimationNow;

  00030	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  00036	66 8b 51 14	 mov	 dx, WORD PTR [ecx+20]
  0003a	66 89 10	 mov	 WORD PTR [eax], dx

; 2092 : 	pBack->FrameNow  = pOggetto->FrameNow;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  00043	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  00047	66 89 50 06	 mov	 WORD PTR [eax+6], dx

; 2093 : 	pBack->StateIdCurrent  =pOggetto->StateIdCurrent;

  0004b	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  00051	66 8b 51 0e	 mov	 dx, WORD PTR [ecx+14]
  00055	66 89 50 02	 mov	 WORD PTR [eax+2], dx

; 2094 : 	pBack->StateIdNext  = pOggetto->StateIdNext;

  00059	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  0005c	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  0005f	66 8b 51 10	 mov	 dx, WORD PTR [ecx+16]
  00063	66 89 50 04	 mov	 WORD PTR [eax+4], dx

; 2095 : 	pBack->LaraRoom = pOggetto->Room;

  00067	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  0006d	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00071	66 89 50 14	 mov	 WORD PTR [eax+20], dx

; 2096 : 	pBack->LaraX = pOggetto->CordX;

  00075	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  00078	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  0007b	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0007e	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 2097 : 	pBack->LaraY = pOggetto->CordY;

  00081	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  00087	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0008a	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 2098 : 	pBack->LaraZ = pOggetto->CordZ;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  00090	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  00093	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00096	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2099 : 	pBack->Orient = pOggetto->OrientationH;

  00099	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  0009c	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  0009f	66 8b 51 4e	 mov	 dx, WORD PTR [ecx+78]
  000a3	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 2100 : 	pBack->SpeedH = pOggetto->SpeedH;

  000a7	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  000aa	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  000ad	66 8b 51 1e	 mov	 dx, WORD PTR [ecx+30]
  000b1	66 89 50 18	 mov	 WORD PTR [eax+24], dx

; 2101 : 	pBack->SpeedV = pOggetto->SpeedV;

  000b5	8b 45 08	 mov	 eax, DWORD PTR _pBack$[ebp]
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _pOggetto$[ebp]
  000bb	66 8b 51 20	 mov	 dx, WORD PTR [ecx+32]
  000bf	66 89 50 1a	 mov	 WORD PTR [eax+26], dx

; 2102 : 
; 2103 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
?BackupLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z ENDP ; BackupLara
_TEXT	ENDS
PUBLIC	?RestoreLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z ; RestoreLara
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?RestoreLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z
_TEXT	SEGMENT
_pCopiaOrientamento$ = -8				; size = 4
_pBack$ = 8						; size = 4
_pOggetto$ = 12						; size = 4
?RestoreLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z PROC ; RestoreLara, COMDAT

; 2106 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2107 : 
; 2108 : 	DWORD *pCopiaOrientamento = (DWORD *)  0x80DF64; //   ;ZonaSave_FB_CopiaOrientamento

  0001e	c7 45 f8 64 df
	80 00		 mov	 DWORD PTR _pCopiaOrientamento$[ebp], 8445796 ; 0080df64H

; 2109 : 
; 2110 : 	*pCopiaOrientamento = pBack->CopiaOrientamento;

  00025	8b 45 f8	 mov	 eax, DWORD PTR _pCopiaOrientamento$[ebp]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  0002b	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0002e	89 10		 mov	 DWORD PTR [eax], edx

; 2111 : 
; 2112 : 	pOggetto->AnimationNow = pBack->AnimationNow;

  00030	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  00036	66 8b 11	 mov	 dx, WORD PTR [ecx]
  00039	66 89 50 14	 mov	 WORD PTR [eax+20], dx

; 2113 : 	pOggetto->FrameNow =pBack->FrameNow;

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  00043	66 8b 51 06	 mov	 dx, WORD PTR [ecx+6]
  00047	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 2114 : 	pOggetto->StateIdCurrent = pBack->StateIdCurrent;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  00051	66 8b 51 02	 mov	 dx, WORD PTR [ecx+2]
  00055	66 89 50 0e	 mov	 WORD PTR [eax+14], dx

; 2115 : 	pOggetto->StateIdNext =	pBack->StateIdNext;

  00059	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  0005f	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  00063	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 2116 : 	pOggetto->Room = pBack->LaraRoom;

  00067	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  0006d	66 8b 51 14	 mov	 dx, WORD PTR [ecx+20]
  00071	66 89 50 18	 mov	 WORD PTR [eax+24], dx

; 2117 : 	pOggetto->CordX = pBack->LaraX;

  00075	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  0007b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0007e	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 2118 : 	pOggetto->CordY = pBack->LaraY;

  00081	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  00084	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  00087	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0008a	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 2119 : 	pOggetto->CordZ = pBack->LaraZ;

  0008d	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  00093	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00096	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 2120 : 	pOggetto->OrientationH= pBack->Orient;

  00099	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  0009f	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  000a3	66 89 50 4e	 mov	 WORD PTR [eax+78], dx

; 2121 : 	pOggetto->SpeedH=pBack->SpeedH;

  000a7	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  000ad	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  000b1	66 89 50 1e	 mov	 WORD PTR [eax+30], dx

; 2122 : 	pOggetto->SpeedV = pBack->SpeedV;

  000b5	8b 45 0c	 mov	 eax, DWORD PTR _pOggetto$[ebp]
  000b8	8b 4d 08	 mov	 ecx, DWORD PTR _pBack$[ebp]
  000bb	66 8b 51 1a	 mov	 dx, WORD PTR [ecx+26]
  000bf	66 89 50 20	 mov	 WORD PTR [eax+32], dx

; 2123 : 
; 2124 : 
; 2125 : }

  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi
  000c5	5b		 pop	 ebx
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
?RestoreLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z ENDP ; RestoreLara
_TEXT	ENDS
PUBLIC	?StartMoveItem@@YA_NH@Z				; StartMoveItem
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?StartMoveItem@@YA_NH@Z
_TEXT	SEGMENT
_ItemIndex$ = 8						; size = 4
?StartMoveItem@@YA_NH@Z PROC				; StartMoveItem, COMDAT

; 2132 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2133 : 	if (Service(SRV_F_CheckForStartMovePushable, ItemIndex) > 0) return true;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  00021	50		 push	 eax
  00022	6a 27		 push	 39			; 00000027H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8
  0002c	85 c0		 test	 eax, eax
  0002e	7e 04		 jle	 SHORT $LN1@StartMoveI
  00030	b0 01		 mov	 al, 1
  00032	eb 02		 jmp	 SHORT $LN2@StartMoveI
$LN1@StartMoveI:

; 2134 : 	return false;

  00034	32 c0		 xor	 al, al
$LN2@StartMoveI:

; 2135 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?StartMoveItem@@YA_NH@Z ENDP				; StartMoveItem
_TEXT	ENDS
PUBLIC	?EndMoveItem@@YAXH@Z				; EndMoveItem
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?EndMoveItem@@YAXH@Z
_TEXT	SEGMENT
_ItemIndex$ = 8						; size = 4
?EndMoveItem@@YAXH@Z PROC				; EndMoveItem, COMDAT

; 2141 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2142 : 	Service(SRV_F_CheckForEndMovePushable, ItemIndex);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  00021	50		 push	 eax
  00022	6a 28		 push	 40			; 00000028H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 2143 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?EndMoveItem@@YAXH@Z ENDP				; EndMoveItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
EXTRN	?MoveLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA:DWORD ; MoveLaraPosition
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z
_TEXT	SEGMENT
_Index$ = -132						; size = 4
_SalvaLara$ = -120					; size = 32
_DifOrientH$ = -80					; size = 2
_pMovPos$ = -68						; size = 4
_SalvaOrientH$ = -56					; size = 2
_MovePosData$ = -44					; size = 12
_pLara$ = -24						; size = 4
_pItem$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_pTestPosition$ = 8					; size = 4
_ObjectIndex$ = 12					; size = 4
?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z PROC ; AlignLaraAtPosition, COMDAT

; 2148 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd b8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-328]
  00012	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2149 : 
; 2150 : 	StrItemTr4 *pItem;
; 2151 : 	StrItemTr4 *pLara;
; 2152 : 	StrMovePosition MovePosData;
; 2153 : 	short SalvaOrientH;
; 2154 : 	StrMovePosition *pMovPos;
; 2155 : 	short DifOrientH;
; 2156 : 	StrBackupLara SalvaLara;
; 2157 : 	int Index;
; 2158 : 
; 2159 : 	if (ObjectIndex & NGLE_INDEX) {

  00028	8b 45 0c	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  0002b	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00030	74 20		 je	 SHORT $LN8@AlignLaraA

; 2160 : 		Index = ObjectIndex & MASK_NGLE_INDEX;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  00035	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0003a	89 85 7c ff ff
	ff		 mov	 DWORD PTR _Index$[ebp], eax

; 2161 : 		ObjectIndex = FromNgleIndexToTomb4Index(Index);

  00040	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Index$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0004c	83 c4 04	 add	 esp, 4
  0004f	89 45 0c	 mov	 DWORD PTR _ObjectIndex$[ebp], eax
$LN8@AlignLaraA:

; 2162 : 	
; 2163 : 	}
; 2164 : 	Trng.pGlobTomb4->TestFixLaraMovPos=false;

  00052	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00057	c6 80 d8 e6 00
	00 00		 mov	 BYTE PTR [eax+59096], 0

; 2165 : 	pLara= Trng.pGlobTomb4->pAdr->pLara;

  0005e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00063	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00069	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006b	89 55 e8	 mov	 DWORD PTR _pLara$[ebp], edx

; 2166 : 	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ObjectIndex];

  0006e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00073	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00079	8b 55 0c	 mov	 edx, DWORD PTR _ObjectIndex$[ebp]
  0007c	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00082	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00085	89 55 f4	 mov	 DWORD PTR _pItem$[ebp], edx

; 2167 : 
; 2168 : 	// farlo in modo immediato se c''e orientamento round in testposition
; 2169 : 	if (pTestPosition->Flags & TPOS_ROUND_HORIENT) {

  00088	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  0008b	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  0008f	83 e1 20	 and	 ecx, 32			; 00000020H
  00092	74 3d		 je	 SHORT $LN7@AlignLaraA

; 2170 : 		pItem->CordX = Trng.pGlobTomb4->TestPosXIdeal;

  00094	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00097	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0009d	8b 91 8c 7b 07
	00		 mov	 edx, DWORD PTR [ecx+490380]
  000a3	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 2171 : 		pItem->CordZ = Trng.pGlobTomb4->TestPosZIdeal;

  000a6	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  000a9	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000af	8b 91 90 7b 07
	00		 mov	 edx, DWORD PTR [ecx+490384]
  000b5	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 2172 : 		pItem->OrientationH = Trng.pGlobTomb4->TestPosOrientIdeal;

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  000bb	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000c1	66 8b 91 8a 7b
	07 00		 mov	 dx, WORD PTR [ecx+490378]
  000c8	66 89 50 4e	 mov	 WORD PTR [eax+78], dx

; 2173 : 	}else {

  000cc	e9 36 02 00 00	 jmp	 $LN6@AlignLaraA
$LN7@AlignLaraA:

; 2174 : 		// traditionl alignment
; 2175 : 
; 2176 : 		Trng.pGlobTomb4->TestAlignmentInProgress=true;

  000d1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000d6	c6 80 a3 5e 21
	00 01		 mov	 BYTE PTR [eax+2186915], 1

; 2177 : 		*Trng.pGlobTomb4->pAdr->pObjectActive = ObjectIndex;

  000dd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000e2	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000e8	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  000ee	8b 45 0c	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  000f1	89 02		 mov	 DWORD PTR [edx], eax

; 2178 : 
; 2179 : 		pMovPos = &MovePosData;

  000f3	8d 45 d4	 lea	 eax, DWORD PTR _MovePosData$[ebp]
  000f6	89 45 bc	 mov	 DWORD PTR _pMovPos$[ebp], eax

; 2180 : 
; 2181 : 
; 2182 : 		pMovPos->RelX  = (pTestPosition->DatiPosition.Distance.MaxX + 
; 2183 : 					pTestPosition->DatiPosition.Distance.MinX ) / 2;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  000fc	0f bf 40 08	 movsx	 eax, WORD PTR [eax+8]
  00100	8b 4d 08	 mov	 ecx, DWORD PTR _pTestPosition$[ebp]
  00103	0f bf 51 06	 movsx	 edx, WORD PTR [ecx+6]
  00107	03 c2		 add	 eax, edx
  00109	99		 cdq
  0010a	2b c2		 sub	 eax, edx
  0010c	d1 f8		 sar	 eax, 1
  0010e	8b 4d bc	 mov	 ecx, DWORD PTR _pMovPos$[ebp]
  00111	89 01		 mov	 DWORD PTR [ecx], eax

; 2184 : 
; 2185 : 		pMovPos->RelY = (pTestPosition->DatiPosition.Distance.MaxY +
; 2186 : 					pTestPosition->DatiPosition.Distance.MinY) / 2;

  00113	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  00116	0f bf 40 0c	 movsx	 eax, WORD PTR [eax+12]
  0011a	8b 4d 08	 mov	 ecx, DWORD PTR _pTestPosition$[ebp]
  0011d	0f bf 51 0a	 movsx	 edx, WORD PTR [ecx+10]
  00121	03 c2		 add	 eax, edx
  00123	99		 cdq
  00124	2b c2		 sub	 eax, edx
  00126	d1 f8		 sar	 eax, 1
  00128	8b 4d bc	 mov	 ecx, DWORD PTR _pMovPos$[ebp]
  0012b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2187 : 
; 2188 : 		pMovPos->RelZ = (pTestPosition->DatiPosition.Distance.MaxZ + 
; 2189 : 					pTestPosition->DatiPosition.Distance.MinZ ) / 2;

  0012e	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  00131	0f bf 40 10	 movsx	 eax, WORD PTR [eax+16]
  00135	8b 4d 08	 mov	 ecx, DWORD PTR _pTestPosition$[ebp]
  00138	0f bf 51 0e	 movsx	 edx, WORD PTR [ecx+14]
  0013c	03 c2		 add	 eax, edx
  0013e	99		 cdq
  0013f	2b c2		 sub	 eax, edx
  00141	d1 f8		 sar	 eax, 1
  00143	8b 4d bc	 mov	 ecx, DWORD PTR _pMovPos$[ebp]
  00146	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 2190 : 
; 2191 : 		DifOrientH = (pTestPosition->DatiPosition.Orienting.OrientHMax +
; 2192 : 					pTestPosition->DatiPosition.Orienting.OrientHMin) / 2;

  00149	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  0014c	0f bf 40 18	 movsx	 eax, WORD PTR [eax+24]
  00150	8b 4d 08	 mov	 ecx, DWORD PTR _pTestPosition$[ebp]
  00153	0f bf 51 16	 movsx	 edx, WORD PTR [ecx+22]
  00157	03 c2		 add	 eax, edx
  00159	99		 cdq
  0015a	2b c2		 sub	 eax, edx
  0015c	d1 f8		 sar	 eax, 1
  0015e	66 89 45 b0	 mov	 WORD PTR _DifOrientH$[ebp], ax

; 2193 : 		
; 2194 : 		if (pTestPosition->Flags & TPOS_TURN_FACING_90) {

  00162	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  00165	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00169	83 e1 40	 and	 ecx, 64			; 00000040H
  0016c	74 24		 je	 SHORT $LN5@AlignLaraA

; 2195 : 			// fixing turning 90 position:
; 2196 : 			
; 2197 : 			Index = pMovPos->RelX;

  0016e	8b 45 bc	 mov	 eax, DWORD PTR _pMovPos$[ebp]
  00171	8b 08		 mov	 ecx, DWORD PTR [eax]
  00173	89 8d 7c ff ff
	ff		 mov	 DWORD PTR _Index$[ebp], ecx

; 2198 : 			pMovPos->RelX = pMovPos->RelZ;

  00179	8b 45 bc	 mov	 eax, DWORD PTR _pMovPos$[ebp]
  0017c	8b 4d bc	 mov	 ecx, DWORD PTR _pMovPos$[ebp]
  0017f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00182	89 10		 mov	 DWORD PTR [eax], edx

; 2199 : 			pMovPos->RelZ = -Index;

  00184	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _Index$[ebp]
  0018a	f7 d8		 neg	 eax
  0018c	8b 4d bc	 mov	 ecx, DWORD PTR _pMovPos$[ebp]
  0018f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN5@AlignLaraA:

; 2200 : 		}
; 2201 : 
; 2202 : 
; 2203 : 	
; 2204 : 		SalvaOrientH = pItem->OrientationH;

  00192	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00195	66 8b 48 4e	 mov	 cx, WORD PTR [eax+78]
  00199	66 89 4d c8	 mov	 WORD PTR _SalvaOrientH$[ebp], cx

; 2205 : 		pItem->OrientationH = Trng.pGlobTomb4->TestPosOrientIdeal;

  0019d	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  001a0	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  001a6	66 8b 91 8a 7b
	07 00		 mov	 dx, WORD PTR [ecx+490378]
  001ad	66 89 50 4e	 mov	 WORD PTR [eax+78], dx

; 2206 : 		
; 2207 : 		BackupLara(&SalvaLara, pLara);

  001b1	8b 45 e8	 mov	 eax, DWORD PTR _pLara$[ebp]
  001b4	50		 push	 eax
  001b5	8d 4d 88	 lea	 ecx, DWORD PTR _SalvaLara$[ebp]
  001b8	51		 push	 ecx
  001b9	e8 00 00 00 00	 call	 ?BackupLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z ; BackupLara
  001be	83 c4 08	 add	 esp, 8

; 2208 : 		if (pTestPosition->Flags & TPOS_FAST_ALIGNMENT) {

  001c1	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  001c4	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  001c8	83 e1 08	 and	 ecx, 8
  001cb	74 2b		 je	 SHORT $LN4@AlignLaraA

; 2209 : 			*Trng.pGlobTomb4->pAdr->pFlagsLara |= 0x20;

  001cd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  001d2	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  001d8	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  001de	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001e1	83 c8 20	 or	 eax, 32			; 00000020H
  001e4	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  001ea	8b 91 4a 34 19
	00		 mov	 edx, DWORD PTR [ecx+1651786]
  001f0	8b 8a 8c 00 00
	00		 mov	 ecx, DWORD PTR [edx+140]
  001f6	88 01		 mov	 BYTE PTR [ecx], al
$LN4@AlignLaraA:

; 2210 : 					
; 2211 : 		}
; 2212 : 
; 2213 : 		if (pTestPosition->Flags & TPOS_OPPOSITE_FACING) {

  001f8	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  001fb	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  001ff	83 e1 10	 and	 ecx, 16			; 00000010H
  00202	74 25		 je	 SHORT $LN3@AlignLaraA

; 2214 : 			// attivare correzione di orientamento
; 2215 : 			Trng.pGlobTomb4->TestFixLaraMovPos=true;

  00204	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00209	c6 80 d8 e6 00
	00 01		 mov	 BYTE PTR [eax+59096], 1

; 2216 : 			Trng.pGlobTomb4->OrientFixLaraMovPos = 
; 2217 : 				pItem->OrientationH + DifOrientH;

  00210	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00213	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  00217	0f bf 55 b0	 movsx	 edx, WORD PTR _DifOrientH$[ebp]
  0021b	03 ca		 add	 ecx, edx
  0021d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00222	66 89 88 db e6
	00 00		 mov	 WORD PTR [eax+59099], cx
$LN3@AlignLaraA:

; 2218 : 		}
; 2219 : 		if (pTestPosition->Flags & TPOS_TURN_FACING_180) {

  00229	8b 45 08	 mov	 eax, DWORD PTR _pTestPosition$[ebp]
  0022c	0f b7 48 02	 movzx	 ecx, WORD PTR [eax+2]
  00230	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00236	74 26		 je	 SHORT $LN2@AlignLaraA

; 2220 : 			// fixing turning 180
; 2221 : 			Trng.pGlobTomb4->TestFixLaraMovPos = true;

  00238	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0023d	c6 80 d8 e6 00
	00 01		 mov	 BYTE PTR [eax+59096], 1

; 2222 : 			Trng.pGlobTomb4->OrientFixLaraMovPos = pItem->OrientationH + 0x8000;

  00244	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00247	0f bf 48 4e	 movsx	 ecx, WORD PTR [eax+78]
  0024b	81 c1 00 80 00
	00		 add	 ecx, 32768		; 00008000H
  00251	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00257	66 89 8a db e6
	00 00		 mov	 WORD PTR [edx+59099], cx
$LN2@AlignLaraA:

; 2223 : 		}
; 2224 : 	
; 2225 : 		if (MoveLaraPosition(pMovPos, pItem ,pLara) == false) {

  0025e	8b f4		 mov	 esi, esp
  00260	8b 45 e8	 mov	 eax, DWORD PTR _pLara$[ebp]
  00263	50		 push	 eax
  00264	8b 4d f4	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00267	51		 push	 ecx
  00268	8b 55 bc	 mov	 edx, DWORD PTR _pMovPos$[ebp]
  0026b	52		 push	 edx
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR ?MoveLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA ; MoveLaraPosition
  00272	83 c4 0c	 add	 esp, 12			; 0000000cH
  00275	3b f4		 cmp	 esi, esp
  00277	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0027c	0f b6 c0	 movzx	 eax, al
  0027f	85 c0		 test	 eax, eax
  00281	75 0f		 jne	 SHORT $LN1@AlignLaraA

; 2226 : 
; 2227 : 			pItem->OrientationH = SalvaOrientH;

  00283	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00286	66 8b 4d c8	 mov	 cx, WORD PTR _SalvaOrientH$[ebp]
  0028a	66 89 48 4e	 mov	 WORD PTR [eax+78], cx

; 2228 : 
; 2229 : 
; 2230 : 			return false;

  0028e	32 c0		 xor	 al, al
  00290	eb 77		 jmp	 SHORT $LN9@AlignLaraA
$LN1@AlignLaraA:

; 2231 : 		}
; 2232 : 		// completed
; 2233 : 
; 2234 : 		RestoreLara(&SalvaLara, pLara);

  00292	8b 45 e8	 mov	 eax, DWORD PTR _pLara$[ebp]
  00295	50		 push	 eax
  00296	8d 4d 88	 lea	 ecx, DWORD PTR _SalvaLara$[ebp]
  00299	51		 push	 ecx
  0029a	e8 00 00 00 00	 call	 ?RestoreLara@@YAXPAUStrBackupLara@@PAUStrItemTr4@@@Z ; RestoreLara
  0029f	83 c4 08	 add	 esp, 8

; 2235 : 		Trng.pGlobTomb4->TestFixLaraMovPos=false;

  002a2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002a7	c6 80 d8 e6 00
	00 00		 mov	 BYTE PTR [eax+59096], 0

; 2236 : 		
; 2237 : 		pItem->OrientationH = SalvaOrientH;

  002ae	8b 45 f4	 mov	 eax, DWORD PTR _pItem$[ebp]
  002b1	66 8b 4d c8	 mov	 cx, WORD PTR _SalvaOrientH$[ebp]
  002b5	66 89 48 4e	 mov	 WORD PTR [eax+78], cx

; 2238 : 
; 2239 : 		*Trng.pGlobTomb4->pAdr->pObjectActive = -1;

  002b9	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002be	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  002c4	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  002ca	c7 02 ff ff ff
	ff		 mov	 DWORD PTR [edx], -1

; 2240 : 		Trng.pGlobTomb4->TestAlignmentInProgress=false;

  002d0	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002d5	c6 80 a3 5e 21
	00 00		 mov	 BYTE PTR [eax+2186915], 0

; 2241 : 		*Trng.pGlobTomb4->pAdr->pFlagsLara &= ~0x20;

  002dc	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002e1	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  002e7	8b 91 8c 00 00
	00		 mov	 edx, DWORD PTR [ecx+140]
  002ed	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  002f0	83 e0 df	 and	 eax, -33		; ffffffdfH
  002f3	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002f9	8b 91 4a 34 19
	00		 mov	 edx, DWORD PTR [ecx+1651786]
  002ff	8b 8a 8c 00 00
	00		 mov	 ecx, DWORD PTR [edx+140]
  00305	88 01		 mov	 BYTE PTR [ecx], al
$LN6@AlignLaraA:

; 2242 : 		
; 2243 : 		
; 2244 : 
; 2245 : 	}
; 2246 : 	return true;

  00307	b0 01		 mov	 al, 1
$LN9@AlignLaraA:

; 2247 : 
; 2248 : }

  00309	52		 push	 edx
  0030a	8b cd		 mov	 ecx, ebp
  0030c	50		 push	 eax
  0030d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@AlignLaraA
  00313	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00318	58		 pop	 eax
  00319	5a		 pop	 edx
  0031a	5f		 pop	 edi
  0031b	5e		 pop	 esi
  0031c	5b		 pop	 ebx
  0031d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00320	33 cd		 xor	 ecx, ebp
  00322	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00327	81 c4 48 01 00
	00		 add	 esp, 328		; 00000148H
  0032d	3b ec		 cmp	 ebp, esp
  0032f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00334	8b e5		 mov	 esp, ebp
  00336	5d		 pop	 ebp
  00337	c3		 ret	 0
$LN14@AlignLaraA:
  00338	02 00 00 00	 DD	 2
  0033c	00 00 00 00	 DD	 $LN13@AlignLaraA
$LN13@AlignLaraA:
  00340	d4 ff ff ff	 DD	 -44			; ffffffd4H
  00344	0c 00 00 00	 DD	 12			; 0000000cH
  00348	00 00 00 00	 DD	 $LN11@AlignLaraA
  0034c	88 ff ff ff	 DD	 -120			; ffffff88H
  00350	20 00 00 00	 DD	 32			; 00000020H
  00354	00 00 00 00	 DD	 $LN12@AlignLaraA
$LN12@AlignLaraA:
  00358	53		 DB	 83			; 00000053H
  00359	61		 DB	 97			; 00000061H
  0035a	6c		 DB	 108			; 0000006cH
  0035b	76		 DB	 118			; 00000076H
  0035c	61		 DB	 97			; 00000061H
  0035d	4c		 DB	 76			; 0000004cH
  0035e	61		 DB	 97			; 00000061H
  0035f	72		 DB	 114			; 00000072H
  00360	61		 DB	 97			; 00000061H
  00361	00		 DB	 0
$LN11@AlignLaraA:
  00362	4d		 DB	 77			; 0000004dH
  00363	6f		 DB	 111			; 0000006fH
  00364	76		 DB	 118			; 00000076H
  00365	65		 DB	 101			; 00000065H
  00366	50		 DB	 80			; 00000050H
  00367	6f		 DB	 111			; 0000006fH
  00368	73		 DB	 115			; 00000073H
  00369	44		 DB	 68			; 00000044H
  0036a	61		 DB	 97			; 00000061H
  0036b	74		 DB	 116			; 00000074H
  0036c	61		 DB	 97			; 00000061H
  0036d	00		 DB	 0
?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ENDP ; AlignLaraAtPosition
_TEXT	ENDS
PUBLIC	?ClearMemory@@YAXPAXK@Z				; ClearMemory
EXTRN	_memset:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ClearMemory@@YAXPAXK@Z
_TEXT	SEGMENT
_pZone$ = 8						; size = 4
_SizeBytes$ = 12					; size = 4
?ClearMemory@@YAXPAXK@Z PROC				; ClearMemory, COMDAT

; 2252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2253 : 	memset(pZone, 0, SizeBytes);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _SizeBytes$[ebp]
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _pZone$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2254 : 
; 2255 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?ClearMemory@@YAXPAXK@Z ENDP				; ClearMemory
_TEXT	ENDS
PUBLIC	?IsCollideWithMoveable@@YA_NHHH@Z		; IsCollideWithMoveable
EXTRN	?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA:DWORD ; GetBestFrame
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsCollideWithMoveable@@YA_NHHH@Z
_TEXT	SEGMENT
_pSlot$ = -92						; size = 4
_pPrimary$ = -80					; size = 4
_pColl$ = -68						; size = 4
_Index$ = -56						; size = 4
_pItem$ = -44						; size = 4
_CustomItem$ = -32					; size = 28
_IndexPrimaryItem$ = 8					; size = 4
_IndexSecondaryItem$ = 12				; size = 4
_Tollerance$ = 16					; size = 4
?IsCollideWithMoveable@@YA_NHHH@Z PROC			; IsCollideWithMoveable, COMDAT

; 2258 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2259 : 	StrCustomItem CustomItem;
; 2260 : 	StrItemTr4 *pItem;
; 2261 : 	int Index;
; 2262 : 	StrBoxCollisione *pColl;
; 2263 : 	StrItemTr4 *pPrimary;
; 2264 : 	StrSlot *pSlot;
; 2265 : 
; 2266 : 
; 2267 : 	ClearMemory(&COLLIDE.BoxItem, sizeof(StrAbsBoxCollision));

  0001e	6a 18		 push	 24			; 00000018H
  00020	68 0c 00 00 00	 push	 OFFSET ?COLLIDE@@3UStrCollisionLast@@A+12
  00025	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  0002a	83 c4 08	 add	 esp, 8

; 2268 : 	ClearMemory(&COLLIDE.BoxSecondary, sizeof(StrAbsBoxCollision));

  0002d	6a 18		 push	 24			; 00000018H
  0002f	68 24 00 00 00	 push	 OFFSET ?COLLIDE@@3UStrCollisionLast@@A+36
  00034	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  00039	83 c4 08	 add	 esp, 8

; 2269 : 
; 2270 : 
; 2271 : 	if (IndexPrimaryItem & NGLE_INDEX) {

  0003c	8b 45 08	 mov	 eax, DWORD PTR _IndexPrimaryItem$[ebp]
  0003f	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00044	74 27		 je	 SHORT $LN10@IsCollideW

; 2272 : 		Index = IndexPrimaryItem & MASK_NGLE_INDEX;

  00046	8b 45 08	 mov	 eax, DWORD PTR _IndexPrimaryItem$[ebp]
  00049	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0004e	89 45 c8	 mov	 DWORD PTR _Index$[ebp], eax

; 2273 : 		IndexPrimaryItem = FromNgleIndexToTomb4Index(Index);

  00051	8b 45 c8	 mov	 eax, DWORD PTR _Index$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 08	 mov	 DWORD PTR _IndexPrimaryItem$[ebp], eax

; 2274 : 		if (IndexPrimaryItem==-1) return false;

  00060	83 7d 08 ff	 cmp	 DWORD PTR _IndexPrimaryItem$[ebp], -1
  00064	75 07		 jne	 SHORT $LN10@IsCollideW
  00066	32 c0		 xor	 al, al
  00068	e9 f9 01 00 00	 jmp	 $LN11@IsCollideW
$LN10@IsCollideW:

; 2275 : 	}
; 2276 : 
; 2277 : 
; 2278 : 	if (IndexSecondaryItem & NGLE_INDEX) {

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _IndexSecondaryItem$[ebp]
  00070	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00075	74 27		 je	 SHORT $LN8@IsCollideW

; 2279 : 		Index = IndexSecondaryItem & MASK_NGLE_INDEX;

  00077	8b 45 0c	 mov	 eax, DWORD PTR _IndexSecondaryItem$[ebp]
  0007a	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0007f	89 45 c8	 mov	 DWORD PTR _Index$[ebp], eax

; 2280 : 		IndexSecondaryItem = FromNgleIndexToTomb4Index(Index);

  00082	8b 45 c8	 mov	 eax, DWORD PTR _Index$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0008b	83 c4 04	 add	 esp, 4
  0008e	89 45 0c	 mov	 DWORD PTR _IndexSecondaryItem$[ebp], eax

; 2281 : 		if (IndexSecondaryItem==-1) return false;

  00091	83 7d 0c ff	 cmp	 DWORD PTR _IndexSecondaryItem$[ebp], -1
  00095	75 07		 jne	 SHORT $LN8@IsCollideW
  00097	32 c0		 xor	 al, al
  00099	e9 c8 01 00 00	 jmp	 $LN11@IsCollideW
$LN8@IsCollideW:

; 2282 : 	}
; 2283 : 
; 2284 : 
; 2285 : 	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexSecondaryItem];

  0009e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000a3	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000a9	8b 55 0c	 mov	 edx, DWORD PTR _IndexSecondaryItem$[ebp]
  000ac	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  000b2	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  000b5	89 55 d4	 mov	 DWORD PTR _pItem$[ebp], edx

; 2286 : 
; 2287 : 	pSlot= &Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID];

  000b8	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000bd	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000c3	8b 55 d4	 mov	 edx, DWORD PTR _pItem$[ebp]
  000c6	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000ca	c1 e0 06	 shl	 eax, 6
  000cd	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  000d0	89 45 a4	 mov	 DWORD PTR _pSlot$[ebp], eax

; 2288 : 
; 2289 : 	if (pSlot->pProcCollision == NULL) {

  000d3	8b 45 a4	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000d6	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000da	75 07		 jne	 SHORT $LN6@IsCollideW

; 2290 : 		// Collision disabled for it: no collision
; 2291 : 		return false;

  000dc	32 c0		 xor	 al, al
  000de	e9 83 01 00 00	 jmp	 $LN11@IsCollideW
$LN6@IsCollideW:

; 2292 : 	}
; 2293 : 
; 2294 : 	if (pSlot->Flags & 0x02) {

  000e3	8b 45 a4	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000e6	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  000ea	83 e1 02	 and	 ecx, 2
  000ed	74 26		 je	 SHORT $LN5@IsCollideW

; 2295 : 		// it is a creature
; 2296 : 		// if it has not been yet enabled: no collision
; 2297 : 		if (pItem->FlagsMain & 0x20) {

  000ef	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  000f2	8b 88 ea 15 00
	00		 mov	 ecx, DWORD PTR [eax+5610]
  000f8	83 e1 20	 and	 ecx, 32			; 00000020H
  000fb	74 18		 je	 SHORT $LN5@IsCollideW

; 2298 : 			if ((pItem->FlagsMain & 06)==6) {

  000fd	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00100	8b 88 ea 15 00
	00		 mov	 ecx, DWORD PTR [eax+5610]
  00106	83 e1 06	 and	 ecx, 6
  00109	83 f9 06	 cmp	 ecx, 6
  0010c	75 07		 jne	 SHORT $LN5@IsCollideW

; 2299 : 				
; 2300 : 				return false;

  0010e	32 c0		 xor	 al, al
  00110	e9 51 01 00 00	 jmp	 $LN11@IsCollideW
$LN5@IsCollideW:

; 2301 : 			}
; 2302 : 		}
; 2303 : 	}
; 2304 : 	pPrimary = &Trng.pGlobTomb4->pAdr->pVetItems[IndexPrimaryItem];

  00115	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0011a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00120	8b 55 08	 mov	 edx, DWORD PTR _IndexPrimaryItem$[ebp]
  00123	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00129	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  0012c	89 55 b0	 mov	 DWORD PTR _pPrimary$[ebp], edx

; 2305 : 
; 2306 : 	// cut-off, if distance > 3 sectors: no collision
; 2307 : 	if (GetMaxDistance(&pItem->CordX, &pPrimary->CordX, false) > 1024*3 ) return false;

  0012f	6a 00		 push	 0
  00131	8b 45 b0	 mov	 eax, DWORD PTR _pPrimary$[ebp]
  00134	83 c0 40	 add	 eax, 64			; 00000040H
  00137	50		 push	 eax
  00138	8b 4d d4	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0013b	83 c1 40	 add	 ecx, 64			; 00000040H
  0013e	51		 push	 ecx
  0013f	e8 00 00 00 00	 call	 ?GetMaxDistance@@YAHPAK0_N@Z ; GetMaxDistance
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH
  00147	3d 00 0c 00 00	 cmp	 eax, 3072		; 00000c00H
  0014c	7e 07		 jle	 SHORT $LN2@IsCollideW
  0014e	32 c0		 xor	 al, al
  00150	e9 11 01 00 00	 jmp	 $LN11@IsCollideW
$LN2@IsCollideW:

; 2308 : 
; 2309 : 	pColl = GetBestFrame(pItem);

  00155	8b f4		 mov	 esi, esp
  00157	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  0015a	50		 push	 eax
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA ; GetBestFrame
  00161	83 c4 04	 add	 esp, 4
  00164	3b f4		 cmp	 esi, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	89 45 bc	 mov	 DWORD PTR _pColl$[ebp], eax

; 2310 : 
; 2311 : 	CustomItem.CordX = pItem->CordX;

  0016e	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00171	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00174	89 4d e0	 mov	 DWORD PTR _CustomItem$[ebp], ecx

; 2312 : 	CustomItem.CordY = pItem->CordY;

  00177	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  0017a	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0017d	89 4d e4	 mov	 DWORD PTR _CustomItem$[ebp+4], ecx

; 2313 : 	CustomItem.CordZ = pItem->CordZ;

  00180	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00183	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00186	89 4d e8	 mov	 DWORD PTR _CustomItem$[ebp+8], ecx

; 2314 : 	CustomItem.hOrient = pItem->OrientationH;

  00189	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  0018c	66 8b 48 4e	 mov	 cx, WORD PTR [eax+78]
  00190	66 89 4d f4	 mov	 WORD PTR _CustomItem$[ebp+20], cx

; 2315 : 	CustomItem.hOrient = IndexPrimaryItem;

  00194	66 8b 45 08	 mov	 ax, WORD PTR _IndexPrimaryItem$[ebp]
  00198	66 89 45 f4	 mov	 WORD PTR _CustomItem$[ebp+20], ax

; 2316 : 	CustomItem.MaxY = pColl->MaxY;

  0019c	8b 45 bc	 mov	 eax, DWORD PTR _pColl$[ebp]
  0019f	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  001a3	66 89 4d ee	 mov	 WORD PTR _CustomItem$[ebp+14], cx

; 2317 : 	CustomItem.MinY = pColl->MinY;

  001a7	8b 45 bc	 mov	 eax, DWORD PTR _pColl$[ebp]
  001aa	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  001ae	66 89 4d ec	 mov	 WORD PTR _CustomItem$[ebp+12], cx

; 2318 : 	CustomItem.pBoxRel = pColl;

  001b2	8b 45 bc	 mov	 eax, DWORD PTR _pColl$[ebp]
  001b5	89 45 f0	 mov	 DWORD PTR _CustomItem$[ebp+16], eax

; 2319 : 	CustomItem.Slot = pItem->SlotID;

  001b8	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  001bb	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  001bf	66 89 4d fa	 mov	 WORD PTR _CustomItem$[ebp+26], cx

; 2320 : 
; 2321 : 	if (Service(SRV_F_CollideItemConCustom, pPrimary, &CustomItem, Tollerance) == 0) return false;

  001c3	8b 45 10	 mov	 eax, DWORD PTR _Tollerance$[ebp]
  001c6	50		 push	 eax
  001c7	8d 4d e0	 lea	 ecx, DWORD PTR _CustomItem$[ebp]
  001ca	51		 push	 ecx
  001cb	8b 55 b0	 mov	 edx, DWORD PTR _pPrimary$[ebp]
  001ce	52		 push	 edx
  001cf	6a 16		 push	 22			; 00000016H
  001d1	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  001d6	83 c4 10	 add	 esp, 16			; 00000010H
  001d9	85 c0		 test	 eax, eax
  001db	75 07		 jne	 SHORT $LN1@IsCollideW
  001dd	32 c0		 xor	 al, al
  001df	e9 82 00 00 00	 jmp	 $LN11@IsCollideW
$LN1@IsCollideW:

; 2322 : 
; 2323 : 
; 2324 : 	COLLIDE.BoxItem = Trng.pGlobTomb4->pMisc->CollisionLast.BoxItem;

  001e4	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  001e9	8b 88 a4 5e 21
	00		 mov	 ecx, DWORD PTR [eax+2186916]
  001ef	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001f2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f4	89 15 0c 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+12, edx
  001fa	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  001fd	a3 10 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+16, eax
  00202	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00205	89 15 14 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+20, edx
  0020b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0020e	a3 18 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+24, eax
  00213	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00216	89 15 1c 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+28, edx
  0021c	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0021f	a3 20 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+32, eax

; 2325 : 	COLLIDE.BoxSecondary = Trng.pGlobTomb4->pMisc->CollisionLast.BoxSecondary;

  00224	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00229	8b 88 a4 5e 21
	00		 mov	 ecx, DWORD PTR [eax+2186916]
  0022f	83 c1 24	 add	 ecx, 36			; 00000024H
  00232	8b 11		 mov	 edx, DWORD PTR [ecx]
  00234	89 15 24 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+36, edx
  0023a	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0023d	a3 28 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+40, eax
  00242	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00245	89 15 2c 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+44, edx
  0024b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0024e	a3 30 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+48, eax
  00253	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00256	89 15 34 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+52, edx
  0025c	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0025f	a3 38 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+56, eax

; 2326 : 
; 2327 : 	return true;

  00264	b0 01		 mov	 al, 1
$LN11@IsCollideW:

; 2328 : 
; 2329 : 
; 2330 : 
; 2331 : }

  00266	52		 push	 edx
  00267	8b cd		 mov	 ecx, ebp
  00269	50		 push	 eax
  0026a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@IsCollideW
  00270	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00275	58		 pop	 eax
  00276	5a		 pop	 edx
  00277	5f		 pop	 edi
  00278	5e		 pop	 esi
  00279	5b		 pop	 ebx
  0027a	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  00280	3b ec		 cmp	 ebp, esp
  00282	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00287	8b e5		 mov	 esp, ebp
  00289	5d		 pop	 ebp
  0028a	c3		 ret	 0
  0028b	90		 npad	 1
$LN15@IsCollideW:
  0028c	01 00 00 00	 DD	 1
  00290	00 00 00 00	 DD	 $LN14@IsCollideW
$LN14@IsCollideW:
  00294	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00298	1c 00 00 00	 DD	 28			; 0000001cH
  0029c	00 00 00 00	 DD	 $LN13@IsCollideW
$LN13@IsCollideW:
  002a0	43		 DB	 67			; 00000043H
  002a1	75		 DB	 117			; 00000075H
  002a2	73		 DB	 115			; 00000073H
  002a3	74		 DB	 116			; 00000074H
  002a4	6f		 DB	 111			; 0000006fH
  002a5	6d		 DB	 109			; 0000006dH
  002a6	49		 DB	 73			; 00000049H
  002a7	74		 DB	 116			; 00000074H
  002a8	65		 DB	 101			; 00000065H
  002a9	6d		 DB	 109			; 0000006dH
  002aa	00		 DB	 0
?IsCollideWithMoveable@@YA_NHHH@Z ENDP			; IsCollideWithMoveable
_TEXT	ENDS
PUBLIC	??_C@_0DK@IAPOPOKF@ERROR?3?5static?5ngle?5index?5?$DN?5?$CFd?5is@ ; `string'
PUBLIC	?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z	; FromNgleStaticIndexToTomb4Indices
;	COMDAT ??_C@_0DK@IAPOPOKF@ERROR?3?5static?5ngle?5index?5?$DN?5?$CFd?5is@
CONST	SEGMENT
??_C@_0DK@IAPOPOKF@ERROR?3?5static?5ngle?5index?5?$DN?5?$CFd?5is@ DB 'ERR'
	DB	'OR: static ngle index = %d is not a valid static index', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z
_TEXT	SEGMENT
_StaticIndex$ = -20					; size = 4
_RoomIndex$ = -8					; size = 4
_IndiceNgle$ = 8					; size = 4
_pRoomIndex$ = 12					; size = 4
_pStaticIndex$ = 16					; size = 4
?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z PROC	; FromNgleStaticIndexToTomb4Indices, COMDAT

; 2335 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2336 : 	int RoomIndex;
; 2337 : 	int StaticIndex;
; 2338 : 
; 2339 : 	RoomIndex=Trng.pGlobTomb4->VetRemapStatics[IndiceNgle].IndiceRoom;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IndiceNgle$[ebp]
  00021	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00027	0f b7 94 81 96
	66 09 00	 movzx	 edx, WORD PTR [ecx+eax*4+616086]
  0002f	89 55 f8	 mov	 DWORD PTR _RoomIndex$[ebp], edx

; 2340 : 	StaticIndex= Trng.pGlobTomb4->VetRemapStatics[IndiceNgle].IndiceStatic;

  00032	8b 45 08	 mov	 eax, DWORD PTR _IndiceNgle$[ebp]
  00035	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0003b	0f bf 94 81 98
	66 09 00	 movsx	 edx, WORD PTR [ecx+eax*4+616088]
  00043	89 55 ec	 mov	 DWORD PTR _StaticIndex$[ebp], edx

; 2341 : 
; 2342 : 	if (RoomIndex == -1 || StaticIndex==-1) {

  00046	83 7d f8 ff	 cmp	 DWORD PTR _RoomIndex$[ebp], -1
  0004a	74 06		 je	 SHORT $LN1@FromNgleSt
  0004c	83 7d ec ff	 cmp	 DWORD PTR _StaticIndex$[ebp], -1
  00050	75 15		 jne	 SHORT $LN2@FromNgleSt
$LN1@FromNgleSt:

; 2343 : 		SendToLog("ERROR: static ngle index = %d is not a valid static index", IndiceNgle);

  00052	8b 45 08	 mov	 eax, DWORD PTR _IndiceNgle$[ebp]
  00055	50		 push	 eax
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@IAPOPOKF@ERROR?3?5static?5ngle?5index?5?$DN?5?$CFd?5is@
  0005b	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00060	83 c4 08	 add	 esp, 8

; 2344 : 		return false;

  00063	32 c0		 xor	 al, al
  00065	eb 12		 jmp	 SHORT $LN3@FromNgleSt
$LN2@FromNgleSt:

; 2345 : 	}
; 2346 : 	*pRoomIndex = RoomIndex;

  00067	8b 45 0c	 mov	 eax, DWORD PTR _pRoomIndex$[ebp]
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _RoomIndex$[ebp]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx

; 2347 : 	*pStaticIndex = StaticIndex;

  0006f	8b 45 10	 mov	 eax, DWORD PTR _pStaticIndex$[ebp]
  00072	8b 4d ec	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  00075	89 08		 mov	 DWORD PTR [eax], ecx

; 2348 : 	return true;

  00077	b0 01		 mov	 al, 1
$LN3@FromNgleSt:

; 2349 : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z ENDP	; FromNgleStaticIndexToTomb4Indices
_TEXT	ENDS
PUBLIC	?IsCollidingWithSomeItem@@YA_NHKHKHHHHH@Z	; IsCollidingWithSomeItem
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsCollidingWithSomeItem@@YA_NHKHKHHHHH@Z
_TEXT	SEGMENT
_Index$ = -32						; size = 4
_pItem$ = -20						; size = 4
_TestIgnoreLara$ = -5					; size = 1
_ItemIndex$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_RoomIndex$ = 24					; size = 4
_MaxDistance$ = 28					; size = 4
_MinLargerSide$ = 32					; size = 4
_MinHeight$ = 36					; size = 4
_Tollerance$ = 40					; size = 4
?IsCollidingWithSomeItem@@YA_NHKHKHHHHH@Z PROC		; IsCollidingWithSomeItem, COMDAT

; 2356 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2357 : 	bool TestIgnoreLara;
; 2358 : 	StrItemTr4 *pItem;
; 2359 : 	int Index;
; 2360 : 
; 2361 : 	COLLIDE.ItemIndex=-1;

  0001e	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A, -1

; 2362 : 	COLLIDE.StaticIndex=-1;

  00028	c7 05 04 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+4, -1

; 2363 : 	COLLIDE.StaticIndexRoom=-1;

  00032	c7 05 08 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+8, -1

; 2364 : 
; 2365 : 	if (ItemIndex & NGLE_INDEX) {

  0003c	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  0003f	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00044	74 27		 je	 SHORT $LN5@IsCollidin

; 2366 : 		Index = ItemIndex & MASK_NGLE_INDEX;

  00046	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  00049	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0004e	89 45 e0	 mov	 DWORD PTR _Index$[ebp], eax

; 2367 : 		ItemIndex = FromNgleIndexToTomb4Index(Index);

  00051	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 08	 mov	 DWORD PTR _ItemIndex$[ebp], eax

; 2368 : 		if (ItemIndex==-1) return false;

  00060	83 7d 08 ff	 cmp	 DWORD PTR _ItemIndex$[ebp], -1
  00064	75 07		 jne	 SHORT $LN5@IsCollidin
  00066	32 c0		 xor	 al, al
  00068	e9 83 00 00 00	 jmp	 $LN6@IsCollidin
$LN5@IsCollidin:

; 2369 : 	}
; 2370 : 
; 2371 : 	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

  0006d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00072	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00078	8b 55 08	 mov	 edx, DWORD PTR _ItemIndex$[ebp]
  0007b	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00081	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00084	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 2372 : 
; 2373 : 	if (pItem->SlotID==0) {

  00087	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  0008a	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0008e	85 c9		 test	 ecx, ecx
  00090	75 06		 jne	 SHORT $LN3@IsCollidin

; 2374 : 		TestIgnoreLara=true;

  00092	c6 45 fb 01	 mov	 BYTE PTR _TestIgnoreLara$[ebp], 1

; 2375 : 	}else {

  00096	eb 04		 jmp	 SHORT $LN2@IsCollidin
$LN3@IsCollidin:

; 2376 : 		TestIgnoreLara=false;

  00098	c6 45 fb 00	 mov	 BYTE PTR _TestIgnoreLara$[ebp], 0
$LN2@IsCollidin:

; 2377 : 	}
; 2378 : 	
; 2379 : 	if (Service(SRV_F_IsCollisioneConItems, pItem, TestIgnoreLara, x,y,z, RoomIndex, 
; 2380 : 								MaxDistance, MinLargerSide, MinHeight, Tollerance)==0) return false;

  0009c	8b 45 28	 mov	 eax, DWORD PTR _Tollerance$[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d 24	 mov	 ecx, DWORD PTR _MinHeight$[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 20	 mov	 edx, DWORD PTR _MinLargerSide$[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 1c	 mov	 eax, DWORD PTR _MaxDistance$[ebp]
  000ab	50		 push	 eax
  000ac	8b 4d 18	 mov	 ecx, DWORD PTR _RoomIndex$[ebp]
  000af	51		 push	 ecx
  000b0	8b 55 14	 mov	 edx, DWORD PTR _z$[ebp]
  000b3	52		 push	 edx
  000b4	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _x$[ebp]
  000bb	51		 push	 ecx
  000bc	0f b6 55 fb	 movzx	 edx, BYTE PTR _TestIgnoreLara$[ebp]
  000c0	52		 push	 edx
  000c1	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  000c4	50		 push	 eax
  000c5	6a 17		 push	 23			; 00000017H
  000c7	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  000cc	83 c4 2c	 add	 esp, 44			; 0000002cH
  000cf	85 c0		 test	 eax, eax
  000d1	75 04		 jne	 SHORT $LN1@IsCollidin
  000d3	32 c0		 xor	 al, al
  000d5	eb 19		 jmp	 SHORT $LN6@IsCollidin
$LN1@IsCollidin:

; 2381 : 
; 2382 : 	COLLIDE = Trng.pGlobTomb4->pMisc->CollisionLast;

  000d7	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000dc	8b b0 a4 5e 21
	00		 mov	 esi, DWORD PTR [eax+2186916]
  000e2	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  000e7	bf 00 00 00 00	 mov	 edi, OFFSET ?COLLIDE@@3UStrCollisionLast@@A ; COLLIDE
  000ec	f3 a5		 rep movsd

; 2383 : 
; 2384 : 	return true;

  000ee	b0 01		 mov	 al, 1
$LN6@IsCollidin:

; 2385 : 
; 2386 : }

  000f0	5f		 pop	 edi
  000f1	5e		 pop	 esi
  000f2	5b		 pop	 ebx
  000f3	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000f9	3b ec		 cmp	 ebp, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
?IsCollidingWithSomeItem@@YA_NHKHKHHHHH@Z ENDP		; IsCollidingWithSomeItem
_TEXT	ENDS
PUBLIC	?IsCollideWithStatic@@YA_NHHHH@Z		; IsCollideWithStatic
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsCollideWithStatic@@YA_NHHHH@Z
_TEXT	SEGMENT
_pStatic$ = -104					; size = 4
_Custom$ = -92						; size = 28
_pRoom$ = -56						; size = 4
_Index$ = -44						; size = 4
_pCollStatic$ = -32					; size = 4
_pEdit$ = -20						; size = 4
_pItem$ = -8						; size = 4
_IndexItem$ = 8						; size = 4
_StaticIndex$ = 12					; size = 4
_StaticRoomIndex$ = 16					; size = 4
_Tollerance$ = 20					; size = 4
?IsCollideWithStatic@@YA_NHHHH@Z PROC			; IsCollideWithStatic, COMDAT

; 2389 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd d4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-300]
  00012	b9 4b 00 00 00	 mov	 ecx, 75			; 0000004bH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2390 : 	StrItemTr4 *pItem;
; 2391 : 	StrStaticSlot *pEdit;
; 2392 : 	StrBoxCollisione *pCollStatic;
; 2393 : 	int Index;
; 2394 : 	StrRoomTr4 *pRoom;
; 2395 : 	StrCustomItem Custom;
; 2396 : 	StrMeshInfo *pStatic;
; 2397 : 
; 2398 : 	ClearMemory(&COLLIDE.BoxItem, sizeof(StrAbsBoxCollision));

  0001e	6a 18		 push	 24			; 00000018H
  00020	68 0c 00 00 00	 push	 OFFSET ?COLLIDE@@3UStrCollisionLast@@A+12
  00025	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  0002a	83 c4 08	 add	 esp, 8

; 2399 : 	ClearMemory(&COLLIDE.BoxSecondary, sizeof(StrAbsBoxCollision));

  0002d	6a 18		 push	 24			; 00000018H
  0002f	68 24 00 00 00	 push	 OFFSET ?COLLIDE@@3UStrCollisionLast@@A+36
  00034	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  00039	83 c4 08	 add	 esp, 8

; 2400 : 
; 2401 : 	if (StaticIndex & NGLE_INDEX) {

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  0003f	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00044	74 2d		 je	 SHORT $LN10@IsCollideW@2

; 2402 : 		Index = StaticIndex & MASK_NGLE_INDEX;

  00046	8b 45 0c	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  00049	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0004e	89 45 d4	 mov	 DWORD PTR _Index$[ebp], eax

; 2403 : 		if (FromNgleStaticIndexToTomb4Indices(Index, &StaticRoomIndex, &StaticIndex)==false) return false;

  00051	8d 45 0c	 lea	 eax, DWORD PTR _StaticIndex$[ebp]
  00054	50		 push	 eax
  00055	8d 4d 10	 lea	 ecx, DWORD PTR _StaticRoomIndex$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 d4	 mov	 edx, DWORD PTR _Index$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z ; FromNgleStaticIndexToTomb4Indices
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	0f b6 c0	 movzx	 eax, al
  00068	85 c0		 test	 eax, eax
  0006a	75 07		 jne	 SHORT $LN10@IsCollideW@2
  0006c	32 c0		 xor	 al, al
  0006e	e9 11 02 00 00	 jmp	 $LN11@IsCollideW@2
$LN10@IsCollideW@2:

; 2404 : 	}
; 2405 : 
; 2406 : 	pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[StaticRoomIndex];

  00073	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00078	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0007e	8b 55 10	 mov	 edx, DWORD PTR _StaticRoomIndex$[ebp]
  00081	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00087	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008a	89 55 c8	 mov	 DWORD PTR _pRoom$[ebp], edx

; 2407 : 
; 2408 : 	pStatic = &pRoom->Ptr_StaticMesh[StaticIndex];

  0008d	8b 45 0c	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  00090	6b c0 14	 imul	 eax, 20			; 00000014H
  00093	8b 4d c8	 mov	 ecx, DWORD PTR _pRoom$[ebp]
  00096	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00099	89 45 98	 mov	 DWORD PTR _pStatic$[ebp], eax

; 2409 : 
; 2410 : 	// check if collision are disabled for this static
; 2411 : 	if ((pStatic->OCB & OCBS_SCALABLE)==0) {

  0009c	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  0009f	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  000a3	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  000a9	75 13		 jne	 SHORT $LN8@IsCollideW@2

; 2412 : 		if (pStatic->OCB & OCBS_NO_COLLISIONI) return false;

  000ab	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  000ae	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  000b2	83 e1 04	 and	 ecx, 4
  000b5	74 07		 je	 SHORT $LN8@IsCollideW@2
  000b7	32 c0		 xor	 al, al
  000b9	e9 c6 01 00 00	 jmp	 $LN11@IsCollideW@2
$LN8@IsCollideW@2:

; 2413 : 	}
; 2414 : 
; 2415 : 	pEdit = &Trng.pGlobTomb4->pAdr->pVetEditObjects[pStatic->SlotId];

  000be	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000c3	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000c9	8b 55 98	 mov	 edx, DWORD PTR _pStatic$[ebp]
  000cc	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  000d0	6b c0 1c	 imul	 eax, 28			; 0000001cH
  000d3	03 41 38	 add	 eax, DWORD PTR [ecx+56]
  000d6	89 45 ec	 mov	 DWORD PTR _pEdit$[ebp], eax

; 2416 : 	// if has no collision box: no collision
; 2417 : 	if (pEdit->CollisionBox.MinY == 0 &&
; 2418 : 		pEdit->CollisionBox.MaxY == 0) {

  000d9	8b 45 ec	 mov	 eax, DWORD PTR _pEdit$[ebp]
  000dc	0f bf 48 14	 movsx	 ecx, WORD PTR [eax+20]
  000e0	85 c9		 test	 ecx, ecx
  000e2	75 12		 jne	 SHORT $LN6@IsCollideW@2
  000e4	8b 45 ec	 mov	 eax, DWORD PTR _pEdit$[ebp]
  000e7	0f bf 48 16	 movsx	 ecx, WORD PTR [eax+22]
  000eb	85 c9		 test	 ecx, ecx
  000ed	75 07		 jne	 SHORT $LN6@IsCollideW@2

; 2419 : 		return false;

  000ef	32 c0		 xor	 al, al
  000f1	e9 8e 01 00 00	 jmp	 $LN11@IsCollideW@2
$LN6@IsCollideW@2:

; 2420 : 	}
; 2421 : 
; 2422 : 	if (IndexItem & NGLE_INDEX) {

  000f6	8b 45 08	 mov	 eax, DWORD PTR _IndexItem$[ebp]
  000f9	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  000fe	74 27		 je	 SHORT $LN5@IsCollideW@2

; 2423 : 		Index = IndexItem & MASK_NGLE_INDEX;

  00100	8b 45 08	 mov	 eax, DWORD PTR _IndexItem$[ebp]
  00103	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00108	89 45 d4	 mov	 DWORD PTR _Index$[ebp], eax

; 2424 : 		IndexItem = FromNgleIndexToTomb4Index(Index);

  0010b	8b 45 d4	 mov	 eax, DWORD PTR _Index$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  00114	83 c4 04	 add	 esp, 4
  00117	89 45 08	 mov	 DWORD PTR _IndexItem$[ebp], eax

; 2425 : 		if (IndexItem==-1) return false;

  0011a	83 7d 08 ff	 cmp	 DWORD PTR _IndexItem$[ebp], -1
  0011e	75 07		 jne	 SHORT $LN5@IsCollideW@2
  00120	32 c0		 xor	 al, al
  00122	e9 5d 01 00 00	 jmp	 $LN11@IsCollideW@2
$LN5@IsCollideW@2:

; 2426 : 	}
; 2427 : 
; 2428 : 	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexItem];

  00127	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0012c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00132	8b 55 08	 mov	 edx, DWORD PTR _IndexItem$[ebp]
  00135	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  0013b	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  0013e	89 55 f8	 mov	 DWORD PTR _pItem$[ebp], edx

; 2429 : 
; 2430 : 	// if it is not scalable or huge, to do check for distance
; 2431 : 	if ((pStatic->OCB & (OCBS_HUGE_COLLISION | OCBS_SCALABLE))==0) {

  00141	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  00144	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00148	81 e1 00 12 00
	00		 and	 ecx, 4608		; 00001200H
  0014e	75 23		 jne	 SHORT $LN3@IsCollideW@2

; 2432 : 		// normal static
; 2433 : 		if (GetMaxDistance(&pStatic->x, &pItem->CordX, false) >= 3072) {

  00150	6a 00		 push	 0
  00152	8b 45 f8	 mov	 eax, DWORD PTR _pItem$[ebp]
  00155	83 c0 40	 add	 eax, 64			; 00000040H
  00158	50		 push	 eax
  00159	8b 4d 98	 mov	 ecx, DWORD PTR _pStatic$[ebp]
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?GetMaxDistance@@YAHPAK0_N@Z ; GetMaxDistance
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH
  00165	3d 00 0c 00 00	 cmp	 eax, 3072		; 00000c00H
  0016a	7c 07		 jl	 SHORT $LN3@IsCollideW@2

; 2434 : 			// too far: no collision
; 2435 : 			return false;

  0016c	32 c0		 xor	 al, al
  0016e	e9 11 01 00 00	 jmp	 $LN11@IsCollideW@2
$LN3@IsCollideW@2:

; 2436 : 		}
; 2437 : 	}
; 2438 : 
; 2439 : 	// perform comparison for collision
; 2440 : 
; 2441 : 	pCollStatic = &Trng.pGlobTomb4->pAdr->pVetEditObjects[pStatic->SlotId].CollisionBox;

  00173	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00178	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0017e	8b 55 98	 mov	 edx, DWORD PTR _pStatic$[ebp]
  00181	0f b7 42 12	 movzx	 eax, WORD PTR [edx+18]
  00185	6b c0 1c	 imul	 eax, 28			; 0000001cH
  00188	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  0018b	8d 54 01 10	 lea	 edx, DWORD PTR [ecx+eax+16]
  0018f	89 55 e0	 mov	 DWORD PTR _pCollStatic$[ebp], edx

; 2442 : 	Custom.CordX = pStatic->x;

  00192	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  00195	8b 08		 mov	 ecx, DWORD PTR [eax]
  00197	89 4d a4	 mov	 DWORD PTR _Custom$[ebp], ecx

; 2443 : 	Custom.CordY = pStatic->y;

  0019a	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  0019d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001a0	89 4d a8	 mov	 DWORD PTR _Custom$[ebp+4], ecx

; 2444 : 	Custom.CordZ = pStatic->z;

  001a3	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  001a6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001a9	89 4d ac	 mov	 DWORD PTR _Custom$[ebp+8], ecx

; 2445 : 	Custom.MaxY = pCollStatic->MaxY;

  001ac	8b 45 e0	 mov	 eax, DWORD PTR _pCollStatic$[ebp]
  001af	66 8b 48 06	 mov	 cx, WORD PTR [eax+6]
  001b3	66 89 4d b2	 mov	 WORD PTR _Custom$[ebp+14], cx

; 2446 : 	Custom.MinY = pCollStatic->MinY;

  001b7	8b 45 e0	 mov	 eax, DWORD PTR _pCollStatic$[ebp]
  001ba	66 8b 48 04	 mov	 cx, WORD PTR [eax+4]
  001be	66 89 4d b0	 mov	 WORD PTR _Custom$[ebp+12], cx

; 2447 : 	Custom.hOrient = pStatic->Orient;

  001c2	8b 45 98	 mov	 eax, DWORD PTR _pStatic$[ebp]
  001c5	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  001c9	66 89 4d b8	 mov	 WORD PTR _Custom$[ebp+20], cx

; 2448 : 	Custom.pBoxRel = pCollStatic;

  001cd	8b 45 e0	 mov	 eax, DWORD PTR _pCollStatic$[ebp]
  001d0	89 45 b4	 mov	 DWORD PTR _Custom$[ebp+16], eax

; 2449 : 	Custom.ItemIndex=-1;

  001d3	c7 45 ba ff ff
	ff ff		 mov	 DWORD PTR _Custom$[ebp+22], -1

; 2450 : 	Custom.Slot = -1;

  001da	83 c8 ff	 or	 eax, -1
  001dd	66 89 45 be	 mov	 WORD PTR _Custom$[ebp+26], ax

; 2451 : 
; 2452 : 	if (Service(SRV_F_CollideItemConCustom, pItem, &Custom, Tollerance)==0) return false;

  001e1	8b 45 14	 mov	 eax, DWORD PTR _Tollerance$[ebp]
  001e4	50		 push	 eax
  001e5	8d 4d a4	 lea	 ecx, DWORD PTR _Custom$[ebp]
  001e8	51		 push	 ecx
  001e9	8b 55 f8	 mov	 edx, DWORD PTR _pItem$[ebp]
  001ec	52		 push	 edx
  001ed	6a 16		 push	 22			; 00000016H
  001ef	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  001f4	83 c4 10	 add	 esp, 16			; 00000010H
  001f7	85 c0		 test	 eax, eax
  001f9	75 07		 jne	 SHORT $LN1@IsCollideW@2
  001fb	32 c0		 xor	 al, al
  001fd	e9 82 00 00 00	 jmp	 $LN11@IsCollideW@2
$LN1@IsCollideW@2:

; 2453 : 
; 2454 : 	COLLIDE.BoxItem = Trng.pGlobTomb4->pMisc->CollisionLast.BoxItem;

  00202	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00207	8b 88 a4 5e 21
	00		 mov	 ecx, DWORD PTR [eax+2186916]
  0020d	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00210	8b 11		 mov	 edx, DWORD PTR [ecx]
  00212	89 15 0c 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+12, edx
  00218	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0021b	a3 10 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+16, eax
  00220	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00223	89 15 14 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+20, edx
  00229	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0022c	a3 18 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+24, eax
  00231	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00234	89 15 1c 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+28, edx
  0023a	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0023d	a3 20 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+32, eax

; 2455 : 	COLLIDE.BoxSecondary = Trng.pGlobTomb4->pMisc->CollisionLast.BoxSecondary;

  00242	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00247	8b 88 a4 5e 21
	00		 mov	 ecx, DWORD PTR [eax+2186916]
  0024d	83 c1 24	 add	 ecx, 36			; 00000024H
  00250	8b 11		 mov	 edx, DWORD PTR [ecx]
  00252	89 15 24 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+36, edx
  00258	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0025b	a3 28 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+40, eax
  00260	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00263	89 15 2c 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+44, edx
  00269	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0026c	a3 30 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+48, eax
  00271	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00274	89 15 34 00 00
	00		 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+52, edx
  0027a	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0027d	a3 38 00 00 00	 mov	 DWORD PTR ?COLLIDE@@3UStrCollisionLast@@A+56, eax

; 2456 : 
; 2457 : 	return true;

  00282	b0 01		 mov	 al, 1
$LN11@IsCollideW@2:

; 2458 : 
; 2459 : }

  00284	52		 push	 edx
  00285	8b cd		 mov	 ecx, ebp
  00287	50		 push	 eax
  00288	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@IsCollideW@2
  0028e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00293	58		 pop	 eax
  00294	5a		 pop	 edx
  00295	5f		 pop	 edi
  00296	5e		 pop	 esi
  00297	5b		 pop	 ebx
  00298	81 c4 2c 01 00
	00		 add	 esp, 300		; 0000012cH
  0029e	3b ec		 cmp	 ebp, esp
  002a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a5	8b e5		 mov	 esp, ebp
  002a7	5d		 pop	 ebp
  002a8	c3		 ret	 0
  002a9	8d 49 00	 npad	 3
$LN15@IsCollideW@2:
  002ac	01 00 00 00	 DD	 1
  002b0	00 00 00 00	 DD	 $LN14@IsCollideW@2
$LN14@IsCollideW@2:
  002b4	a4 ff ff ff	 DD	 -92			; ffffffa4H
  002b8	1c 00 00 00	 DD	 28			; 0000001cH
  002bc	00 00 00 00	 DD	 $LN13@IsCollideW@2
$LN13@IsCollideW@2:
  002c0	43		 DB	 67			; 00000043H
  002c1	75		 DB	 117			; 00000075H
  002c2	73		 DB	 115			; 00000073H
  002c3	74		 DB	 116			; 00000074H
  002c4	6f		 DB	 111			; 0000006fH
  002c5	6d		 DB	 109			; 0000006dH
  002c6	00		 DB	 0
?IsCollideWithStatic@@YA_NHHHH@Z ENDP			; IsCollideWithStatic
_TEXT	ENDS
PUBLIC	??_C@_0EK@GFPCLJHC@ERROR?3?5GetAlignedOrient?$CI?$CJ?3?5no?5al@ ; `string'
PUBLIC	?GetAlignedOrient@@YAFF_NPAH@Z			; GetAlignedOrient
;	COMDAT ??_C@_0EK@GFPCLJHC@ERROR?3?5GetAlignedOrient?$CI?$CJ?3?5no?5al@
CONST	SEGMENT
??_C@_0EK@GFPCLJHC@ERROR?3?5GetAlignedOrient?$CI?$CJ?3?5no?5al@ DB 'ERROR'
	DB	': GetAlignedOrient(): no aligned orient found for source orie'
	DB	'nt 0x%X', 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?GetAlignedOrient@@YAFF_NPAH@Z
_TEXT	SEGMENT
_MinDiff$ = -8						; size = 4
_Orient$ = 8						; size = 2
_TestForceHortogonal$ = 12				; size = 1
_pGap$ = 16						; size = 4
?GetAlignedOrient@@YAFF_NPAH@Z PROC			; GetAlignedOrient, COMDAT

; 2466 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2467 : 	int MinDiff;
; 2468 : 
; 2469 : 	if (TestForceHortogonal==false) {

  0001e	0f b6 45 0c	 movzx	 eax, BYTE PTR _TestForceHortogonal$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	0f 85 c4 00 00
	00		 jne	 $LN9@GetAligned

; 2470 : 		// verify if perfect direction more closed is one on diagonal direction
; 2471 : 		// try south-east (ngle) direction
; 2472 : 		MinDiff = AbsDiffO(Orient, 0x2000);

  0002a	68 00 20 00 00	 push	 8192			; 00002000H
  0002f	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2473 : 		if (MinDiff <= 0x1000) {

  0003f	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 4096 ; 00001000H
  00046	7f 13		 jg	 SHORT $LN8@GetAligned

; 2474 : 			*pGap=MinDiff;

  00048	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  0004e	89 08		 mov	 DWORD PTR [eax], ecx

; 2475 : 			return enumORIENT.SOUTH_EAST;

  00050	66 a1 10 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+16
  00056	e9 6b 01 00 00	 jmp	 $LN10@GetAligned
$LN8@GetAligned:

; 2476 : 		}
; 2477 : 
; 2478 : 		// try south-west direction
; 2479 : 		MinDiff= AbsDiffO(Orient, 0x6000);

  0005b	68 00 60 00 00	 push	 24576			; 00006000H
  00060	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  0006a	83 c4 08	 add	 esp, 8
  0006d	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2480 : 		if (MinDiff <= 0x1000) {

  00070	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 4096 ; 00001000H
  00077	7f 13		 jg	 SHORT $LN7@GetAligned

; 2481 : 			*pGap =MinDiff;

  00079	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  0007f	89 08		 mov	 DWORD PTR [eax], ecx

; 2482 : 			return enumORIENT.SOUTH_WEST;

  00081	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+24
  00087	e9 3a 01 00 00	 jmp	 $LN10@GetAligned
$LN7@GetAligned:

; 2483 : 		}
; 2484 : 
; 2485 : 
; 2486 : 		MinDiff = AbsDiffO(Orient, (short) 0xA000);

  0008c	68 00 a0 ff ff	 push	 -24576			; ffffa000H
  00091	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  0009b	83 c4 08	 add	 esp, 8
  0009e	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2487 : 
; 2488 : 		if (MinDiff <= 0x1000) {

  000a1	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 4096 ; 00001000H
  000a8	7f 13		 jg	 SHORT $LN6@GetAligned

; 2489 : 			*pGap =MinDiff;

  000aa	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  000b0	89 08		 mov	 DWORD PTR [eax], ecx

; 2490 : 			return enumORIENT.NORTH_WEST;

  000b2	66 a1 1c 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+28
  000b8	e9 09 01 00 00	 jmp	 $LN10@GetAligned
$LN6@GetAligned:

; 2491 : 		}
; 2492 : 
; 2493 : 		// try north-east directio
; 2494 : 
; 2495 : 		MinDiff = AbsDiffO(Orient, (short) 0xE000);

  000bd	68 00 e0 ff ff	 push	 -8192			; ffffe000H
  000c2	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  000cc	83 c4 08	 add	 esp, 8
  000cf	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2496 : 		
; 2497 : 		if (MinDiff <= 0x1000) {

  000d2	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 4096 ; 00001000H
  000d9	7f 13		 jg	 SHORT $LN9@GetAligned

; 2498 : 			*pGap = MinDiff;

  000db	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  000de	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  000e1	89 08		 mov	 DWORD PTR [eax], ecx

; 2499 : 			return enumORIENT.NORTH_EAST;

  000e3	66 a1 14 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+20
  000e9	e9 d8 00 00 00	 jmp	 $LN10@GetAligned
$LN9@GetAligned:

; 2500 : 		}
; 2501 : 	}
; 2502 : 
; 2503 : 	// try with hortogonal directions
; 2504 : 	// try with east (ngle)
; 2505 : 	MinDiff = AbsDiffO(Orient, 0x0000);

  000ee	6a 00		 push	 0
  000f0	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  000fa	83 c4 08	 add	 esp, 8
  000fd	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2506 : 	if (MinDiff <= 0x2000) {

  00100	81 7d f8 00 20
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 8192 ; 00002000H
  00107	7f 13		 jg	 SHORT $LN4@GetAligned

; 2507 : 		*pGap = MinDiff;

  00109	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  0010c	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  0010f	89 08		 mov	 DWORD PTR [eax], ecx

; 2508 : 		return enumORIENT.EAST;

  00111	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+8
  00117	e9 aa 00 00 00	 jmp	 $LN10@GetAligned
$LN4@GetAligned:

; 2509 : 	}
; 2510 : 
; 2511 : 	// try with south
; 2512 : 	MinDiff = AbsDiffO(Orient, 0x4000);

  0011c	68 00 40 00 00	 push	 16384			; 00004000H
  00121	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  0012b	83 c4 08	 add	 esp, 8
  0012e	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2513 : 	if (MinDiff <= 0x2000) {

  00131	81 7d f8 00 20
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 8192 ; 00002000H
  00138	7f 10		 jg	 SHORT $LN3@GetAligned

; 2514 : 		*pGap = MinDiff;

  0013a	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  0013d	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  00140	89 08		 mov	 DWORD PTR [eax], ecx

; 2515 : 		return enumORIENT.SOUTH;

  00142	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+4
  00148	eb 7c		 jmp	 SHORT $LN10@GetAligned
$LN3@GetAligned:

; 2516 : 	}
; 2517 : 	// try with west
; 2518 : 
; 2519 : 	MinDiff = AbsDiffO(Orient, (short) 0x8000);

  0014a	68 00 80 ff ff	 push	 -32768			; ffff8000H
  0014f	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  00159	83 c4 08	 add	 esp, 8
  0015c	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2520 : 	
; 2521 : 
; 2522 : 	if (MinDiff <= 0x2000) {

  0015f	81 7d f8 00 20
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 8192 ; 00002000H
  00166	7f 10		 jg	 SHORT $LN2@GetAligned

; 2523 : 		*pGap = MinDiff;

  00168	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  0016e	89 08		 mov	 DWORD PTR [eax], ecx

; 2524 : 		return enumORIENT.WEST;

  00170	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+12
  00176	eb 4e		 jmp	 SHORT $LN10@GetAligned
$LN2@GetAligned:

; 2525 : 	}
; 2526 : 
; 2527 : 	// try with north
; 2528 : 
; 2529 : 	MinDiff = AbsDiffO(Orient, (short) 0xc000);

  00178	68 00 c0 ff ff	 push	 -16384			; ffffc000H
  0017d	0f b7 45 08	 movzx	 eax, WORD PTR _Orient$[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  00187	83 c4 08	 add	 esp, 8
  0018a	89 45 f8	 mov	 DWORD PTR _MinDiff$[ebp], eax

; 2530 : 	
; 2531 : 	if (MinDiff <= 0x2000) {

  0018d	81 7d f8 00 20
	00 00		 cmp	 DWORD PTR _MinDiff$[ebp], 8192 ; 00002000H
  00194	7f 10		 jg	 SHORT $LN1@GetAligned

; 2532 : 		*pGap = MinDiff;

  00196	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  00199	8b 4d f8	 mov	 ecx, DWORD PTR _MinDiff$[ebp]
  0019c	89 08		 mov	 DWORD PTR [eax], ecx

; 2533 : 		return enumORIENT.NORTH;

  0019e	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A
  001a4	eb 20		 jmp	 SHORT $LN10@GetAligned
$LN1@GetAligned:

; 2534 : 	}
; 2535 : 	// it's not possible reaching this point of the code
; 2536 : 	SendToLog("ERROR: GetAlignedOrient(): no aligned orient found for source orient 0x%X", Orient);

  001a6	0f bf 45 08	 movsx	 eax, WORD PTR _Orient$[ebp]
  001aa	50		 push	 eax
  001ab	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@GFPCLJHC@ERROR?3?5GetAlignedOrient?$CI?$CJ?3?5no?5al@
  001b0	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  001b5	83 c4 08	 add	 esp, 8

; 2537 : 	*pGap= 0x7000;

  001b8	8b 45 10	 mov	 eax, DWORD PTR _pGap$[ebp]
  001bb	c7 00 00 70 00
	00		 mov	 DWORD PTR [eax], 28672	; 00007000H

; 2538 : 	return 9999;

  001c1	b8 0f 27 00 00	 mov	 eax, 9999		; 0000270fH
$LN10@GetAligned:

; 2539 : 
; 2540 : 	
; 2541 : }

  001c6	5f		 pop	 edi
  001c7	5e		 pop	 esi
  001c8	5b		 pop	 ebx
  001c9	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  001cf	3b ec		 cmp	 ebp, esp
  001d1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d6	8b e5		 mov	 esp, ebp
  001d8	5d		 pop	 ebp
  001d9	c3		 ret	 0
?GetAlignedOrient@@YAFF_NPAH@Z ENDP			; GetAlignedOrient
_TEXT	ENDS
PUBLIC	?GetIncrements@@YAXGPAH0H@Z			; GetIncrements
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetIncrements@@YAXGPAH0H@Z
_TEXT	SEGMENT
_pOrientMatrix$ = -44					; size = 4
_Index$ = -32						; size = 4
_IncZ$ = -20						; size = 4
_IncX$ = -8						; size = 4
_Facing$ = 8						; size = 2
_pIncX$ = 12						; size = 4
_pIncZ$ = 16						; size = 4
_Distance$ = 20						; size = 4
?GetIncrements@@YAXGPAH0H@Z PROC			; GetIncrements, COMDAT

; 2545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2546 : 	int IncX, IncZ;
; 2547 : 	int Index;
; 2548 : 	short * pOrientMatrix = (short *) 0x4B34D0;

  0001e	c7 45 d4 d0 34
	4b 00		 mov	 DWORD PTR _pOrientMatrix$[ebp], 4928720 ; 004b34d0H

; 2549 : 
; 2550 : 	if (Distance == 0) {

  00025	83 7d 14 00	 cmp	 DWORD PTR _Distance$[ebp], 0
  00029	75 17		 jne	 SHORT $LN2@GetIncreme

; 2551 : 		*pIncX = 0;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _pIncX$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2552 : 		*pIncZ = 0;

  00034	8b 45 10	 mov	 eax, DWORD PTR _pIncZ$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2553 : 		return;

  0003d	e9 87 00 00 00	 jmp	 $LN3@GetIncreme
$LN2@GetIncreme:

; 2554 : 	}
; 2555 : 
; 2556 : 	Index = Facing >> 3;

  00042	0f b7 45 08	 movzx	 eax, WORD PTR _Facing$[ebp]
  00046	c1 f8 03	 sar	 eax, 3
  00049	89 45 e0	 mov	 DWORD PTR _Index$[ebp], eax

; 2557 : 	Index &= 0x1FFE;

  0004c	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  0004f	25 fe 1f 00 00	 and	 eax, 8190		; 00001ffeH
  00054	89 45 e0	 mov	 DWORD PTR _Index$[ebp], eax

; 2558 : 	
; 2559 : 	IncX = pOrientMatrix[Index] <<	12;

  00057	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  0005a	8b 4d d4	 mov	 ecx, DWORD PTR _pOrientMatrix$[ebp]
  0005d	0f bf 14 41	 movsx	 edx, WORD PTR [ecx+eax*2]
  00061	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00064	89 55 f8	 mov	 DWORD PTR _IncX$[ebp], edx

; 2560 : 	IncZ = pOrientMatrix[Index+1] << 12;

  00067	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  0006a	8b 4d d4	 mov	 ecx, DWORD PTR _pOrientMatrix$[ebp]
  0006d	0f bf 54 41 02	 movsx	 edx, WORD PTR [ecx+eax*2+2]
  00072	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  00075	89 55 ec	 mov	 DWORD PTR _IncZ$[ebp], edx

; 2561 : 	IncX = IncX >> 14;

  00078	8b 45 f8	 mov	 eax, DWORD PTR _IncX$[ebp]
  0007b	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  0007e	89 45 f8	 mov	 DWORD PTR _IncX$[ebp], eax

; 2562 : 	IncZ = IncZ >> 14;

  00081	8b 45 ec	 mov	 eax, DWORD PTR _IncZ$[ebp]
  00084	c1 f8 0e	 sar	 eax, 14			; 0000000eH
  00087	89 45 ec	 mov	 DWORD PTR _IncZ$[ebp], eax

; 2563 : 	// modificarli sulla base di distanza richiesta
; 2564 : 	if (Distance != 1024) {

  0008a	81 7d 14 00 04
	00 00		 cmp	 DWORD PTR _Distance$[ebp], 1024 ; 00000400H
  00091	74 26		 je	 SHORT $LN1@GetIncreme

; 2565 : 		IncX = DistanceProp(IncX, Distance);

  00093	8b 45 14	 mov	 eax, DWORD PTR _Distance$[ebp]
  00096	50		 push	 eax
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _IncX$[ebp]
  0009a	51		 push	 ecx
  0009b	e8 00 00 00 00	 call	 ?DistanceProp@@YAHHH@Z	; DistanceProp
  000a0	83 c4 08	 add	 esp, 8
  000a3	89 45 f8	 mov	 DWORD PTR _IncX$[ebp], eax

; 2566 : 		IncZ = DistanceProp(IncZ, Distance);

  000a6	8b 45 14	 mov	 eax, DWORD PTR _Distance$[ebp]
  000a9	50		 push	 eax
  000aa	8b 4d ec	 mov	 ecx, DWORD PTR _IncZ$[ebp]
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ?DistanceProp@@YAHHH@Z	; DistanceProp
  000b3	83 c4 08	 add	 esp, 8
  000b6	89 45 ec	 mov	 DWORD PTR _IncZ$[ebp], eax
$LN1@GetIncreme:

; 2567 : 	}
; 2568 : 
; 2569 : 	*pIncX = IncX;

  000b9	8b 45 0c	 mov	 eax, DWORD PTR _pIncX$[ebp]
  000bc	8b 4d f8	 mov	 ecx, DWORD PTR _IncX$[ebp]
  000bf	89 08		 mov	 DWORD PTR [eax], ecx

; 2570 : 	*pIncZ = IncZ;

  000c1	8b 45 10	 mov	 eax, DWORD PTR _pIncZ$[ebp]
  000c4	8b 4d ec	 mov	 ecx, DWORD PTR _IncZ$[ebp]
  000c7	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@GetIncreme:

; 2571 : 
; 2572 : 
; 2573 : }

  000c9	5f		 pop	 edi
  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?GetIncrements@@YAXGPAH0H@Z ENDP			; GetIncrements
_TEXT	ENDS
PUBLIC	?PerformTriggerGroup@@YAHH@Z			; PerformTriggerGroup
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PerformTriggerGroup@@YAHH@Z
_TEXT	SEGMENT
_IdOfTriggerGroup$ = 8					; size = 4
?PerformTriggerGroup@@YAHH@Z PROC			; PerformTriggerGroup, COMDAT

; 2576 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2577 : 
; 2578 : 	return Service(SRV_F_EseguiTriggerGroup, IdOfTriggerGroup);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _IdOfTriggerGroup$[ebp]
  00021	50		 push	 eax
  00022	6a 0f		 push	 15			; 0000000fH
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 2579 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?PerformTriggerGroup@@YAHH@Z ENDP			; PerformTriggerGroup
_TEXT	ENDS
PUBLIC	?GetCurrentFrame@@YAHPAUStrItemTr4@@@Z		; GetCurrentFrame
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetCurrentFrame@@YAHPAUStrItemTr4@@@Z
_TEXT	SEGMENT
_StartFrame$ = -8					; size = 4
_pItem$ = 8						; size = 4
?GetCurrentFrame@@YAHPAUStrItemTr4@@@Z PROC		; GetCurrentFrame, COMDAT

; 2582 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2583 : 
; 2584 : 	DWORD StartFrame;
; 2585 : 
; 2586 : 	StartFrame = Trng.pGlobTomb4->pAdr->pVetAnimations[pItem->AnimationNow].FrameStart;

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0002c	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  00030	6b c0 28	 imul	 eax, 40			; 00000028H
  00033	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00036	0f b7 54 01 18	 movzx	 edx, WORD PTR [ecx+eax+24]
  0003b	89 55 f8	 mov	 DWORD PTR _StartFrame$[ebp], edx

; 2587 : 
; 2588 : 	return (int) pItem->FrameNow - StartFrame;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00041	0f b7 40 16	 movzx	 eax, WORD PTR [eax+22]
  00045	2b 45 f8	 sub	 eax, DWORD PTR _StartFrame$[ebp]

; 2589 : 
; 2590 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?GetCurrentFrame@@YAHPAUStrItemTr4@@@Z ENDP		; GetCurrentFrame
_TEXT	ENDS
PUBLIC	?SetCurrentFrame@@YAXPAUStrItemTr4@@H@Z		; SetCurrentFrame
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetCurrentFrame@@YAXPAUStrItemTr4@@H@Z
_TEXT	SEGMENT
_StartFrame$ = -8					; size = 4
_pItem$ = 8						; size = 4
_Frame$ = 12						; size = 4
?SetCurrentFrame@@YAXPAUStrItemTr4@@H@Z PROC		; SetCurrentFrame, COMDAT

; 2593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2594 : 
; 2595 : 	DWORD StartFrame;
; 2596 : 	
; 2597 : 	StartFrame = Trng.pGlobTomb4->pAdr->pVetAnimations[pItem->AnimationNow].FrameStart;

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0002c	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  00030	6b c0 28	 imul	 eax, 40			; 00000028H
  00033	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00036	0f b7 54 01 18	 movzx	 edx, WORD PTR [ecx+eax+24]
  0003b	89 55 f8	 mov	 DWORD PTR _StartFrame$[ebp], edx

; 2598 : 	
; 2599 : 	pItem->FrameNow = (WORD) StartFrame + Frame;

  0003e	0f b7 45 f8	 movzx	 eax, WORD PTR _StartFrame$[ebp]
  00042	03 45 0c	 add	 eax, DWORD PTR _Frame$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00048	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 2600 : 
; 2601 : 
; 2602 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?SetCurrentFrame@@YAXPAUStrItemTr4@@H@Z ENDP		; SetCurrentFrame
_TEXT	ENDS
PUBLIC	?SetCamera@@YAXHHHH@Z				; SetCamera
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetCamera@@YAXHHHH@Z
_TEXT	SEGMENT
_ValShort$ = -20					; size = 2
_TestChange$ = -5					; size = 1
_Distance$ = 8						; size = 4
_HOrient$ = 12						; size = 4
_VOrient$ = 16						; size = 4
_Speed$ = 20						; size = 4
?SetCamera@@YAXHHHH@Z PROC				; SetCamera, COMDAT

; 2606 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2607 : 	bool TestChange;
; 2608 : 	short ValShort;
; 2609 : 
; 2610 : 	if (Speed < 1) Speed=1;

  0001e	83 7d 14 01	 cmp	 DWORD PTR _Speed$[ebp], 1
  00022	7d 07		 jge	 SHORT $LN8@SetCamera
  00024	c7 45 14 01 00
	00 00		 mov	 DWORD PTR _Speed$[ebp], 1
$LN8@SetCamera:

; 2611 : 
; 2612 : 	TestChange=false;

  0002b	c6 45 fb 00	 mov	 BYTE PTR _TestChange$[ebp], 0

; 2613 : 
; 2614 : 	if (Distance != -1) {

  0002f	83 7d 08 ff	 cmp	 DWORD PTR _Distance$[ebp], -1
  00033	74 35		 je	 SHORT $LN7@SetCamera

; 2615 : 		if (*Trng.pGlobTomb4->pAdr->pSetCameraDistance != Distance) {

  00035	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0003a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00040	8b 91 a4 01 00
	00		 mov	 edx, DWORD PTR [ecx+420]
  00046	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00049	3b 45 08	 cmp	 eax, DWORD PTR _Distance$[ebp]
  0004c	74 1c		 je	 SHORT $LN7@SetCamera

; 2616 : 			TestChange=true;

  0004e	c6 45 fb 01	 mov	 BYTE PTR _TestChange$[ebp], 1

; 2617 : 			*Trng.pGlobTomb4->pAdr->pSetCameraDistance = Distance;

  00052	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00057	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0005d	8b 91 a4 01 00
	00		 mov	 edx, DWORD PTR [ecx+420]
  00063	66 8b 45 08	 mov	 ax, WORD PTR _Distance$[ebp]
  00067	66 89 02	 mov	 WORD PTR [edx], ax
$LN7@SetCamera:

; 2618 : 		}
; 2619 : 	}
; 2620 : 
; 2621 : 	if (HOrient != -1) {

  0006a	83 7d 0c ff	 cmp	 DWORD PTR _HOrient$[ebp], -1
  0006e	74 40		 je	 SHORT $LN5@SetCamera

; 2622 : 		ValShort= (short) HOrient;

  00070	66 8b 45 0c	 mov	 ax, WORD PTR _HOrient$[ebp]
  00074	66 89 45 ec	 mov	 WORD PTR _ValShort$[ebp], ax

; 2623 : 
; 2624 : 		if (*Trng.pGlobTomb4->pAdr->pSetCameraHOrient != ValShort) {

  00078	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0007d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00083	8b 91 9c 01 00
	00		 mov	 edx, DWORD PTR [ecx+412]
  00089	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0008c	0f bf 4d ec	 movsx	 ecx, WORD PTR _ValShort$[ebp]
  00090	3b c1		 cmp	 eax, ecx
  00092	74 1c		 je	 SHORT $LN5@SetCamera

; 2625 : 			TestChange=true;

  00094	c6 45 fb 01	 mov	 BYTE PTR _TestChange$[ebp], 1

; 2626 : 			*Trng.pGlobTomb4->pAdr->pSetCameraHOrient = ValShort;

  00098	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0009d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000a3	8b 91 9c 01 00
	00		 mov	 edx, DWORD PTR [ecx+412]
  000a9	66 8b 45 ec	 mov	 ax, WORD PTR _ValShort$[ebp]
  000ad	66 89 02	 mov	 WORD PTR [edx], ax
$LN5@SetCamera:

; 2627 : 		}
; 2628 : 	}
; 2629 : 
; 2630 : 	if (VOrient != -1) {

  000b0	83 7d 10 ff	 cmp	 DWORD PTR _VOrient$[ebp], -1
  000b4	74 40		 je	 SHORT $LN3@SetCamera

; 2631 : 		ValShort = (short) VOrient;

  000b6	66 8b 45 10	 mov	 ax, WORD PTR _VOrient$[ebp]
  000ba	66 89 45 ec	 mov	 WORD PTR _ValShort$[ebp], ax

; 2632 : 
; 2633 : 		if (*Trng.pGlobTomb4->pAdr->pSetCameraVOrient != ValShort) {

  000be	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000c3	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000c9	8b 91 a0 01 00
	00		 mov	 edx, DWORD PTR [ecx+416]
  000cf	0f bf 02	 movsx	 eax, WORD PTR [edx]
  000d2	0f bf 4d ec	 movsx	 ecx, WORD PTR _ValShort$[ebp]
  000d6	3b c1		 cmp	 eax, ecx
  000d8	74 1c		 je	 SHORT $LN3@SetCamera

; 2634 : 			TestChange=true;

  000da	c6 45 fb 01	 mov	 BYTE PTR _TestChange$[ebp], 1

; 2635 : 			*Trng.pGlobTomb4->pAdr->pSetCameraVOrient = ValShort;

  000de	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000e3	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000e9	8b 91 a0 01 00
	00		 mov	 edx, DWORD PTR [ecx+416]
  000ef	66 8b 45 ec	 mov	 ax, WORD PTR _ValShort$[ebp]
  000f3	66 89 02	 mov	 WORD PTR [edx], ax
$LN3@SetCamera:

; 2636 : 		}
; 2637 : 	}
; 2638 : 
; 2639 : 	if (TestChange==true) {

  000f6	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestChange$[ebp]
  000fa	83 f8 01	 cmp	 eax, 1
  000fd	75 2f		 jne	 SHORT $LN9@SetCamera

; 2640 : 		*Trng.pGlobTomb4->pAdr->pSetCameraSpeed =(WORD) Speed;

  000ff	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00104	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0010a	8b 91 a8 01 00
	00		 mov	 edx, DWORD PTR [ecx+424]
  00110	66 8b 45 14	 mov	 ax, WORD PTR _Speed$[ebp]
  00114	66 89 02	 mov	 WORD PTR [edx], ax

; 2641 : 		*Trng.pGlobTomb4->pAdr->Camera.pTargetCameraNow = 0;

  00117	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0011c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00122	8b 91 e4 00 00
	00		 mov	 edx, DWORD PTR [ecx+228]
  00128	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN9@SetCamera:

; 2642 : 	}
; 2643 : }

  0012e	5f		 pop	 edi
  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c3		 ret	 0
?SetCamera@@YAXHHHH@Z ENDP				; SetCamera
_TEXT	ENDS
PUBLIC	?TestEnvCondition@@YA_NHHHHH@Z			; TestEnvCondition
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?TestEnvCondition@@YA_NHHHHH@Z
_TEXT	SEGMENT
$T47077 = -257						; size = 1
_pBox$ = -56						; size = 4
_FirstAnim$ = -44					; size = 4
_pEnemy$ = -32						; size = 4
_pItem$ = -20						; size = 4
_TestLara$ = -5						; size = 1
_ItemIndex$ = 8						; size = 4
_EnvCondition$ = 12					; size = 4
_EnvPosFlags$ = 16					; size = 4
_DistanceEnv$ = 20					; size = 4
_Extra$ = 24						; size = 4
?TestEnvCondition@@YA_NHHHHH@Z PROC			; TestEnvCondition, COMDAT

; 2646 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 ff fe ff
	ff 00		 mov	 BYTE PTR $T47077[ebp], 0

; 2647 : 	bool TestLara;
; 2648 : 	StrItemTr4 *pItem;
; 2649 : 	StrEnvForEnemy *pEnemy;
; 2650 : 	DWORD FirstAnim;
; 2651 : 	StrBoxCollisione *pBox;
; 2652 : 
; 2653 : 	TestLara=false;

  00025	c6 45 fb 00	 mov	 BYTE PTR _TestLara$[ebp], 0

; 2654 : 	if (ItemIndex == -1) {

  00029	83 7d 08 ff	 cmp	 DWORD PTR _ItemIndex$[ebp], -1
  0002d	75 06		 jne	 SHORT $LN5@TestEnvCon

; 2655 : 		TestLara=true;

  0002f	c6 45 fb 01	 mov	 BYTE PTR _TestLara$[ebp], 1

; 2656 : 	}else {

  00033	eb 46		 jmp	 SHORT $LN4@TestEnvCon
$LN5@TestEnvCon:

; 2657 : 		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

  00035	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0003a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00040	8b 55 08	 mov	 edx, DWORD PTR _ItemIndex$[ebp]
  00043	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00049	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  0004c	c6 85 ff fe ff
	ff 01		 mov	 BYTE PTR $T47077[ebp], 1
  00053	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 2658 : 		if (pItem->SlotID == 0) {

  00056	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR $T47077[ebp], 0
  0005d	75 0d		 jne	 SHORT $LN8@TestEnvCon
  0005f	68 00 00 00 00	 push	 OFFSET $LN9@TestEnvCon
  00064	e8 00 00 00 00	 call	 __RTC_UninitUse
  00069	83 c4 04	 add	 esp, 4
$LN8@TestEnvCon:
  0006c	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  0006f	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00073	85 c9		 test	 ecx, ecx
  00075	75 04		 jne	 SHORT $LN4@TestEnvCon

; 2659 : 			TestLara=true;

  00077	c6 45 fb 01	 mov	 BYTE PTR _TestLara$[ebp], 1
$LN4@TestEnvCon:

; 2660 : 		}
; 2661 : 	}
; 2662 : 
; 2663 : 	pEnemy= &Trng.pGlobTomb4->BaseEnvEnemy;

  0007b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00080	05 49 ce 20 00	 add	 eax, 2149961		; 0020ce49H
  00085	89 45 e0	 mov	 DWORD PTR _pEnemy$[ebp], eax

; 2664 : 
; 2665 : 	pEnemy->TestLara= TestLara;

  00088	8b 45 e0	 mov	 eax, DWORD PTR _pEnemy$[ebp]
  0008b	8a 4d fb	 mov	 cl, BYTE PTR _TestLara$[ebp]
  0008e	88 08		 mov	 BYTE PTR [eax], cl

; 2666 : 	if (TestLara == false) {

  00090	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestLara$[ebp]
  00094	85 c0		 test	 eax, eax
  00096	0f 85 af 00 00
	00		 jne	 $LN2@TestEnvCon

; 2667 : 		pEnemy->IndiceOggetto = ItemIndex;

  0009c	8b 45 e0	 mov	 eax, DWORD PTR _pEnemy$[ebp]
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR _ItemIndex$[ebp]
  000a2	89 48 11	 mov	 DWORD PTR [eax+17], ecx

; 2668 : 		pEnemy->pOggetto = pItem;

  000a5	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR $T47077[ebp], 0
  000ac	75 0d		 jne	 SHORT $LN10@TestEnvCon
  000ae	68 00 00 00 00	 push	 OFFSET $LN9@TestEnvCon
  000b3	e8 00 00 00 00	 call	 __RTC_UninitUse
  000b8	83 c4 04	 add	 esp, 4
$LN10@TestEnvCon:
  000bb	8b 45 e0	 mov	 eax, DWORD PTR _pEnemy$[ebp]
  000be	8b 4d ec	 mov	 ecx, DWORD PTR _pItem$[ebp]
  000c1	89 48 0d	 mov	 DWORD PTR [eax+13], ecx

; 2669 : 		FirstAnim = Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID].IndexFirstAnim;

  000c4	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR $T47077[ebp], 0
  000cb	75 0d		 jne	 SHORT $LN11@TestEnvCon
  000cd	68 00 00 00 00	 push	 OFFSET $LN9@TestEnvCon
  000d2	e8 00 00 00 00	 call	 __RTC_UninitUse
  000d7	83 c4 04	 add	 esp, 4
$LN11@TestEnvCon:
  000da	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000df	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000e5	8b 55 ec	 mov	 edx, DWORD PTR _pItem$[ebp]
  000e8	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  000ec	c1 e0 06	 shl	 eax, 6
  000ef	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  000f2	0f b7 54 01 26	 movzx	 edx, WORD PTR [ecx+eax+38]
  000f7	89 55 d4	 mov	 DWORD PTR _FirstAnim$[ebp], edx

; 2670 : 
; 2671 : 		pEnemy->FirstAnim = FirstAnim;

  000fa	8b 45 e0	 mov	 eax, DWORD PTR _pEnemy$[ebp]
  000fd	8b 4d d4	 mov	 ecx, DWORD PTR _FirstAnim$[ebp]
  00100	89 48 15	 mov	 DWORD PTR [eax+21], ecx

; 2672 : 		pBox=GetBestFrame(pItem);

  00103	80 bd ff fe ff
	ff 00		 cmp	 BYTE PTR $T47077[ebp], 0
  0010a	75 0d		 jne	 SHORT $LN12@TestEnvCon
  0010c	68 00 00 00 00	 push	 OFFSET $LN9@TestEnvCon
  00111	e8 00 00 00 00	 call	 __RTC_UninitUse
  00116	83 c4 04	 add	 esp, 4
$LN12@TestEnvCon:
  00119	8b f4		 mov	 esi, esp
  0011b	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  0011e	50		 push	 eax
  0011f	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA ; GetBestFrame
  00125	83 c4 04	 add	 esp, 4
  00128	3b f4		 cmp	 esi, esp
  0012a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012f	89 45 c8	 mov	 DWORD PTR _pBox$[ebp], eax

; 2673 : 		pEnemy->EnemyBox = *pBox;

  00132	8b 45 c8	 mov	 eax, DWORD PTR _pBox$[ebp]
  00135	8b 4d e0	 mov	 ecx, DWORD PTR _pEnemy$[ebp]
  00138	83 c1 01	 add	 ecx, 1
  0013b	8b 10		 mov	 edx, DWORD PTR [eax]
  0013d	89 11		 mov	 DWORD PTR [ecx], edx
  0013f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00142	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00145	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00148	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN2@TestEnvCon:

; 2674 : 	}
; 2675 : 
; 2676 : 	if (Service(SRV_F_TestEnvCondition, EnvCondition, EnvPosFlags, DistanceEnv, Extra) ==0) return false;

  0014b	8b 45 18	 mov	 eax, DWORD PTR _Extra$[ebp]
  0014e	50		 push	 eax
  0014f	8b 4d 14	 mov	 ecx, DWORD PTR _DistanceEnv$[ebp]
  00152	51		 push	 ecx
  00153	8b 55 10	 mov	 edx, DWORD PTR _EnvPosFlags$[ebp]
  00156	52		 push	 edx
  00157	8b 45 0c	 mov	 eax, DWORD PTR _EnvCondition$[ebp]
  0015a	50		 push	 eax
  0015b	6a 13		 push	 19			; 00000013H
  0015d	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00162	83 c4 14	 add	 esp, 20			; 00000014H
  00165	85 c0		 test	 eax, eax
  00167	75 04		 jne	 SHORT $LN1@TestEnvCon
  00169	32 c0		 xor	 al, al
  0016b	eb 02		 jmp	 SHORT $LN6@TestEnvCon
$LN1@TestEnvCon:

; 2677 : 
; 2678 : 	return true;

  0016d	b0 01		 mov	 al, 1
$LN6@TestEnvCon:

; 2679 : 
; 2680 : }

  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx
  00172	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  00178	3b ec		 cmp	 ebp, esp
  0017a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c3		 ret	 0
$LN13@TestEnvCon:
$LN9@TestEnvCon:
  00183	70		 DB	 112			; 00000070H
  00184	49		 DB	 73			; 00000049H
  00185	74		 DB	 116			; 00000074H
  00186	65		 DB	 101			; 00000065H
  00187	6d		 DB	 109			; 0000006dH
  00188	00		 DB	 0
?TestEnvCondition@@YA_NHHHHH@Z ENDP			; TestEnvCondition
_TEXT	ENDS
PUBLIC	?IsGraySector@@YA_NPAX@Z			; IsGraySector
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsGraySector@@YA_NPAX@Z
_TEXT	SEGMENT
_pFloor$ = 8						; size = 4
?IsGraySector@@YA_NPAX@Z PROC				; IsGraySector, COMDAT

; 2683 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2684 : 	if (Service(SRV_F_IsBoxSettore, pFloor) == 0) return false;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pFloor$[ebp]
  00021	50		 push	 eax
  00022	6a 14		 push	 20			; 00000014H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8
  0002c	85 c0		 test	 eax, eax
  0002e	75 04		 jne	 SHORT $LN1@IsGraySect
  00030	32 c0		 xor	 al, al
  00032	eb 02		 jmp	 SHORT $LN2@IsGraySect
$LN1@IsGraySect:

; 2685 : 	return true;

  00034	b0 01		 mov	 al, 1
$LN2@IsGraySect:

; 2686 : 
; 2687 : 
; 2688 : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003f	3b ec		 cmp	 ebp, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?IsGraySector@@YA_NPAX@Z ENDP				; IsGraySector
_TEXT	ENDS
PUBLIC	?FindClimbStatus@@YAGPAG@Z			; FindClimbStatus
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FindClimbStatus@@YAGPAG@Z
_TEXT	SEGMENT
_Status$ = -44						; size = 2
_ptr_FloorData$ = -32					; size = 4
_ptr2_FloorData$ = -20					; size = 4
_Index$ = -8						; size = 4
_pFloor$ = 8						; size = 4
?FindClimbStatus@@YAGPAG@Z PROC				; FindClimbStatus, COMDAT

; 2693 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2694 : 	int Index;
; 2695 : 	WORD **ptr2_FloorData = (WORD **) 0x533948;

  0001e	c7 45 ec 48 39
	53 00		 mov	 DWORD PTR _ptr2_FloorData$[ebp], 5454152 ; 00533948H

; 2696 : 	WORD *ptr_FloorData;
; 2697 : 	WORD Status;
; 2698 : 
; 2699 : 	// indice data floor
; 2700 : 	Index = pFloor[0];

  00025	8b 45 08	 mov	 eax, DWORD PTR _pFloor$[ebp]
  00028	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0002b	89 4d f8	 mov	 DWORD PTR _Index$[ebp], ecx

; 2701 : 	if (Index == 0) return 0;

  0002e	83 7d f8 00	 cmp	 DWORD PTR _Index$[ebp], 0
  00032	75 04		 jne	 SHORT $LN4@FindClimbS
  00034	33 c0		 xor	 eax, eax
  00036	eb 62		 jmp	 SHORT $LN5@FindClimbS
$LN4@FindClimbS:

; 2702 : 
; 2703 : 	ptr_FloorData = *ptr2_FloorData;

  00038	8b 45 ec	 mov	 eax, DWORD PTR _ptr2_FloorData$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	89 4d e0	 mov	 DWORD PTR _ptr_FloorData$[ebp], ecx

; 2704 : 	Status = ptr_FloorData[Index];

  00040	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00043	8b 4d e0	 mov	 ecx, DWORD PTR _ptr_FloorData$[ebp]
  00046	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0004a	66 89 55 d4	 mov	 WORD PTR _Status$[ebp], dx

; 2705 : 
; 2706 : 	if ((Status & 0x1f) == 6) {

  0004e	0f b7 45 d4	 movzx	 eax, WORD PTR _Status$[ebp]
  00052	83 e0 1f	 and	 eax, 31			; 0000001fH
  00055	83 f8 06	 cmp	 eax, 6
  00058	75 06		 jne	 SHORT $LN3@FindClimbS

; 2707 : 		// valore climb)
; 2708 : 		return Status;

  0005a	66 8b 45 d4	 mov	 ax, WORD PTR _Status$[ebp]
  0005e	eb 3a		 jmp	 SHORT $LN5@FindClimbS
$LN3@FindClimbS:

; 2709 : 	}
; 2710 : 	if (Status & 0x8000) return 0;

  00060	0f b7 45 d4	 movzx	 eax, WORD PTR _Status$[ebp]
  00064	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00069	74 04		 je	 SHORT $LN2@FindClimbS
  0006b	33 c0		 xor	 eax, eax
  0006d	eb 2b		 jmp	 SHORT $LN5@FindClimbS
$LN2@FindClimbS:

; 2711 : 	Index++;

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00072	83 c0 01	 add	 eax, 1
  00075	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 2712 : 	// provare il successivo
; 2713 : 	Status = ptr_FloorData[Index];

  00078	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0007b	8b 4d e0	 mov	 ecx, DWORD PTR _ptr_FloorData$[ebp]
  0007e	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00082	66 89 55 d4	 mov	 WORD PTR _Status$[ebp], dx

; 2714 : 	if ((Status & 0x1f) == 6) return Status;

  00086	0f b7 45 d4	 movzx	 eax, WORD PTR _Status$[ebp]
  0008a	83 e0 1f	 and	 eax, 31			; 0000001fH
  0008d	83 f8 06	 cmp	 eax, 6
  00090	75 06		 jne	 SHORT $LN1@FindClimbS
  00092	66 8b 45 d4	 mov	 ax, WORD PTR _Status$[ebp]
  00096	eb 02		 jmp	 SHORT $LN5@FindClimbS
$LN1@FindClimbS:

; 2715 : 
; 2716 : 	return 0;

  00098	33 c0		 xor	 eax, eax
$LN5@FindClimbS:

; 2717 : 
; 2718 : }

  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	5b		 pop	 ebx
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
?FindClimbStatus@@YAGPAG@Z ENDP				; FindClimbStatus
_TEXT	ENDS
PUBLIC	?FindFloorType@@YA_NPAGG@Z			; FindFloorType
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FindFloorType@@YA_NPAGG@Z
_TEXT	SEGMENT
_Status$ = -44						; size = 2
_Index$ = -32						; size = 4
_ptr_FloorData$ = -20					; size = 4
_ptr2_FloorData$ = -8					; size = 4
_pFloor$ = 8						; size = 4
_Type$ = 12						; size = 2
?FindFloorType@@YA_NPAGG@Z PROC				; FindFloorType, COMDAT

; 2721 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2722 : 	WORD **ptr2_FloorData = (WORD **) 0x533948;

  0001e	c7 45 f8 48 39
	53 00		 mov	 DWORD PTR _ptr2_FloorData$[ebp], 5454152 ; 00533948H

; 2723 : 	WORD *ptr_FloorData;
; 2724 : 	int Index;
; 2725 : 	WORD Status;
; 2726 : 
; 2727 : 	Index=pFloor[0];

  00025	8b 45 08	 mov	 eax, DWORD PTR _pFloor$[ebp]
  00028	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0002b	89 4d e0	 mov	 DWORD PTR _Index$[ebp], ecx

; 2728 : 
; 2729 : 	if (Index ==0) return false;

  0002e	83 7d e0 00	 cmp	 DWORD PTR _Index$[ebp], 0
  00032	75 04		 jne	 SHORT $LN5@FindFloorT
  00034	32 c0		 xor	 al, al
  00036	eb 3f		 jmp	 SHORT $LN6@FindFloorT
$LN5@FindFloorT:

; 2730 : 
; 2731 : 	ptr_FloorData = *ptr2_FloorData;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _ptr2_FloorData$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	89 4d ec	 mov	 DWORD PTR _ptr_FloorData$[ebp], ecx
$LN4@FindFloorT:

; 2732 : 
; 2733 : 	do {
; 2734 : 		Status = ptr_FloorData[Index];

  00040	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _ptr_FloorData$[ebp]
  00046	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  0004a	66 89 55 d4	 mov	 WORD PTR _Status$[ebp], dx

; 2735 : 		if ((Status & 0x1f) == Type) return true;

  0004e	0f b7 45 d4	 movzx	 eax, WORD PTR _Status$[ebp]
  00052	83 e0 1f	 and	 eax, 31			; 0000001fH
  00055	0f b7 4d 0c	 movzx	 ecx, WORD PTR _Type$[ebp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	75 04		 jne	 SHORT $LN1@FindFloorT
  0005d	b0 01		 mov	 al, 1
  0005f	eb 16		 jmp	 SHORT $LN6@FindFloorT
$LN1@FindFloorT:

; 2736 : 		Index++;

  00061	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 45 e0	 mov	 DWORD PTR _Index$[ebp], eax

; 2737 : 	}while ((Status & 0x8000)==0);

  0006a	0f b7 45 d4	 movzx	 eax, WORD PTR _Status$[ebp]
  0006e	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00073	74 cb		 je	 SHORT $LN4@FindFloorT

; 2738 : 
; 2739 : 	return false;

  00075	32 c0		 xor	 al, al
$LN6@FindFloorT:

; 2740 : 
; 2741 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
?FindFloorType@@YA_NPAGG@Z ENDP				; FindFloorType
_TEXT	ENDS
PUBLIC	?FormatText@@YAPADPADZZ				; FormatText
_BSS	SEGMENT
?InternalBuffer@?1??FormatText@@YAPADPADZZ@4PADA DB 0200H DUP (?) ; `FormatText'::`2'::InternalBuffer
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT ?FormatText@@YAPADPADZZ
_TEXT	SEGMENT
_pArgs$ = -8						; size = 4
_szFormat$ = 8						; size = 4
?FormatText@@YAPADPADZZ PROC				; FormatText, COMDAT

; 2745 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2746 : 	static char InternalBuffer[512];
; 2747 : 
; 2748 :     va_list pArgs;
; 2749 :     va_start(pArgs, szFormat);

  0001e	8d 45 0c	 lea	 eax, DWORD PTR _szFormat$[ebp+4]
  00021	89 45 f8	 mov	 DWORD PTR _pArgs$[ebp], eax

; 2750 :     vsprintf(InternalBuffer, szFormat, pArgs);

  00024	8b f4		 mov	 esi, esp
  00026	8b 45 f8	 mov	 eax, DWORD PTR _pArgs$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _szFormat$[ebp]
  0002d	51		 push	 ecx
  0002e	68 00 00 00 00	 push	 OFFSET ?InternalBuffer@?1??FormatText@@YAPADPADZZ@4PADA
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vsprintf
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003c	3b f4		 cmp	 esi, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2751 :     va_end(pArgs);

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pArgs$[ebp], 0

; 2752 : 
; 2753 : 	return InternalBuffer;

  0004a	b8 00 00 00 00	 mov	 eax, OFFSET ?InternalBuffer@?1??FormatText@@YAPADPADZZ@4PADA

; 2754 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?FormatText@@YAPADPADZZ ENDP				; FormatText
_TEXT	ENDS
PUBLIC	?MyMessageBox@@YAXPAD0@Z			; MyMessageBox
EXTRN	__imp__MessageBoxA@16:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?MyMessageBox@@YAXPAD0@Z
_TEXT	SEGMENT
_pMessaggio$ = 8					; size = 4
_pTitolo$ = 12						; size = 4
?MyMessageBox@@YAXPAD0@Z PROC				; MyMessageBox, COMDAT

; 2757 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2758 : 	static HWND* pTombWind4 = (HWND*) 0x75385C;  //  ;HandleWindowMain
; 2759 : 					
; 2760 : 	MessageBox(*pTombWind4,pMessaggio,pTitolo,MB_APPLMODAL);

  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	8b 45 0c	 mov	 eax, DWORD PTR _pTitolo$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pMessaggio$[ebp]
  00029	51		 push	 ecx
  0002a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pTombWind4@?1??MyMessageBox@@YAXPAD0@Z@4PAPAUHWND__@@A
  00030	8b 02		 mov	 eax, DWORD PTR [edx]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MessageBoxA@16
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2761 : 
; 2762 : 
; 2763 : 
; 2764 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?MyMessageBox@@YAXPAD0@Z ENDP				; MyMessageBox
_TEXT	ENDS
PUBLIC	?TryMessageBox@@YA_NPAD@Z			; TryMessageBox
EXTRN	?TexMyPluginName@@3PADA:BYTE			; TexMyPluginName
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?TryMessageBox@@YA_NPAD@Z
_TEXT	SEGMENT
_pMessage$ = 8						; size = 4
?TryMessageBox@@YA_NPAD@Z PROC				; TryMessageBox, COMDAT

; 2771 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2772 : 	static DWORD* pTombWind4 = (DWORD*) 0x75385C;  //  ;HandleWindowMai
; 2773 : 
; 2774 : 
; 2775 : 
; 2776 : 	SendToLog(pMessage);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pMessage$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00027	83 c4 04	 add	 esp, 4

; 2777 : 	if (*pTombWind4 == 0 ) {

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pTombWind4@?1??TryMessageBox@@YA_NPAD@Z@4PAKA
  0002f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00032	75 15		 jne	 SHORT $LN1@TryMessage

; 2778 : 		MyMessageBox(pMessage, TexMyPluginName);

  00034	68 00 00 00 00	 push	 OFFSET ?TexMyPluginName@@3PADA ; TexMyPluginName
  00039	8b 45 08	 mov	 eax, DWORD PTR _pMessage$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ?MyMessageBox@@YAXPAD0@Z ; MyMessageBox
  00042	83 c4 08	 add	 esp, 8

; 2779 : 		return true;

  00045	b0 01		 mov	 al, 1
  00047	eb 02		 jmp	 SHORT $LN2@TryMessage
$LN1@TryMessage:

; 2780 : 	}
; 2781 : 	return false;

  00049	32 c0		 xor	 al, al
$LN2@TryMessage:

; 2782 : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?TryMessageBox@@YA_NPAD@Z ENDP				; TryMessageBox
_TEXT	ENDS
PUBLIC	?IsFullScreenMode@@YA_NXZ			; IsFullScreenMode
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsFullScreenMode@@YA_NXZ
_TEXT	SEGMENT
_pBaseGlobale$ = -20					; size = 4
_p2_BaseGlobale$ = -8					; size = 4
?IsFullScreenMode@@YA_NXZ PROC				; IsFullScreenMode, COMDAT

; 2788 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2789 : 	BYTE **p2_BaseGlobale = (BYTE **) 0x754468;

  0001e	c7 45 f8 68 44
	75 00		 mov	 DWORD PTR _p2_BaseGlobale$[ebp], 7685224 ; 00754468H

; 2790 : 	BYTE *pBaseGlobale;
; 2791 : 
; 2792 : 	pBaseGlobale = *p2_BaseGlobale;

  00025	8b 45 f8	 mov	 eax, DWORD PTR _p2_BaseGlobale$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d ec	 mov	 DWORD PTR _pBaseGlobale$[ebp], ecx

; 2793 : 
; 2794 : 	if (pBaseGlobale==NULL) return false;

  0002d	83 7d ec 00	 cmp	 DWORD PTR _pBaseGlobale$[ebp], 0
  00031	75 04		 jne	 SHORT $LN2@IsFullScre
  00033	32 c0		 xor	 al, al
  00035	eb 12		 jmp	 SHORT $LN3@IsFullScre
$LN2@IsFullScre:

; 2795 : 
; 2796 : 	if (pBaseGlobale[0x4c] & 0x02)  return false;

  00037	8b 45 ec	 mov	 eax, DWORD PTR _pBaseGlobale$[ebp]
  0003a	0f b6 48 4c	 movzx	 ecx, BYTE PTR [eax+76]
  0003e	83 e1 02	 and	 ecx, 2
  00041	74 04		 je	 SHORT $LN1@IsFullScre
  00043	32 c0		 xor	 al, al
  00045	eb 02		 jmp	 SHORT $LN3@IsFullScre
$LN1@IsFullScre:

; 2797 : 	return true;

  00047	b0 01		 mov	 al, 1
$LN3@IsFullScre:

; 2798 : 
; 2799 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?IsFullScreenMode@@YA_NXZ ENDP				; IsFullScreenMode
_TEXT	ENDS
PUBLIC	?ApplyCodePatch@@YAHKPAEH@Z			; ApplyCodePatch
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ApplyCodePatch@@YAHKPAEH@Z
_TEXT	SEGMENT
_DataPatch$ = -52					; size = 36
_TestWarnings$ = -5					; size = 1
_Offset$ = 8						; size = 4
_pVetBytes$ = 12					; size = 4
_TotBytes$ = 16						; size = 4
?ApplyCodePatch@@YAHKPAEH@Z PROC			; ApplyCodePatch, COMDAT

; 2807 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2808 : 	bool TestWarnings;
; 2809 : 	StrPatchInfo DataPatch;
; 2810 : 
; 2811 : 	DataPatch.pVetItems = pVetBytes;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pVetBytes$[ebp]
  00021	89 45 e0	 mov	 DWORD PTR _DataPatch$[ebp+20], eax

; 2812 : 	DataPatch.ErrorCode=0;

  00024	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+28], 0

; 2813 : 	DataPatch.NewValue=0;

  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+32], 0

; 2814 : 	DataPatch.PatchType = TYPP_CONTIGUOUS_BYTES;

  00032	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+24], 1

; 2815 : 	DataPatch.PluginId = Trng.IdMyPlugin;

  00039	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  0003e	89 45 cc	 mov	 DWORD PTR _DataPatch$[ebp], eax

; 2816 : 	DataPatch.StartOffset = Offset;

  00041	8b 45 08	 mov	 eax, DWORD PTR _Offset$[ebp]
  00044	89 45 d0	 mov	 DWORD PTR _DataPatch$[ebp+4], eax

; 2817 : 	DataPatch.TotItems = TotBytes;

  00047	8b 45 10	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR _DataPatch$[ebp+16], eax

; 2818 : 
; 2819 : #ifdef DEBUG_ON
; 2820 : 	TestWarnings=true;
; 2821 : #else
; 2822 : 	TestWarnings=false;

  0004d	c6 45 fb 00	 mov	 BYTE PTR _TestWarnings$[ebp], 0

; 2823 : #endif
; 2824 : 
; 2825 : 	return Trng.SetNewPatch(&DataPatch, TestWarnings);

  00051	8b f4		 mov	 esi, esp
  00053	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestWarnings$[ebp]
  00057	50		 push	 eax
  00058	8d 4d cc	 lea	 ecx, DWORD PTR _DataPatch$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 0c 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+12
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2826 : 
; 2827 : }

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@ApplyCodeP
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
  0008e	8b ff		 npad	 2
$LN5@ApplyCodeP:
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN4@ApplyCodeP
$LN4@ApplyCodeP:
  00098	cc ff ff ff	 DD	 -52			; ffffffccH
  0009c	24 00 00 00	 DD	 36			; 00000024H
  000a0	00 00 00 00	 DD	 $LN3@ApplyCodeP
$LN3@ApplyCodeP:
  000a4	44		 DB	 68			; 00000044H
  000a5	61		 DB	 97			; 00000061H
  000a6	74		 DB	 116			; 00000074H
  000a7	61		 DB	 97			; 00000061H
  000a8	50		 DB	 80			; 00000050H
  000a9	61		 DB	 97			; 00000061H
  000aa	74		 DB	 116			; 00000074H
  000ab	63		 DB	 99			; 00000063H
  000ac	68		 DB	 104			; 00000068H
  000ad	00		 DB	 0
?ApplyCodePatch@@YAHKPAEH@Z ENDP			; ApplyCodePatch
_TEXT	ENDS
PUBLIC	?ApplyRelocatorPatch@@YAHKPAEHKK@Z		; ApplyRelocatorPatch
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ApplyRelocatorPatch@@YAHKPAEHKK@Z
_TEXT	SEGMENT
_DataPatch$ = -52					; size = 36
_TestWarnings$ = -5					; size = 1
_Offset$ = 8						; size = 4
_pVetBytes$ = 12					; size = 4
_TotBytes$ = 16						; size = 4
_ProcStart$ = 20					; size = 4
_ProcEnd$ = 24						; size = 4
?ApplyRelocatorPatch@@YAHKPAEHKK@Z PROC			; ApplyRelocatorPatch, COMDAT

; 2835 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2836 : 	bool TestWarnings;
; 2837 : 	StrPatchInfo DataPatch;
; 2838 : 
; 2839 : 	DataPatch.ErrorCode=0;

  0001e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+28], 0

; 2840 : 	DataPatch.NewValue=0;

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+32], 0

; 2841 : 	DataPatch.PatchType = TYPP_CONTIGUOUS_BYTES | TYPP_RILOCATOR;

  0002c	c7 45 e4 09 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+24], 9

; 2842 : 	DataPatch.PluginId = Trng.IdMyPlugin;

  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00038	89 45 cc	 mov	 DWORD PTR _DataPatch$[ebp], eax

; 2843 : 	DataPatch.StartOffset = Offset;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _Offset$[ebp]
  0003e	89 45 d0	 mov	 DWORD PTR _DataPatch$[ebp+4], eax

; 2844 : 	DataPatch.TotItems = TotBytes;

  00041	8b 45 10	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00044	89 45 dc	 mov	 DWORD PTR _DataPatch$[ebp+16], eax

; 2845 : 	DataPatch.pVetItems = pVetBytes;

  00047	8b 45 0c	 mov	 eax, DWORD PTR _pVetBytes$[ebp]
  0004a	89 45 e0	 mov	 DWORD PTR _DataPatch$[ebp+20], eax

; 2846 : 	DataPatch.ProcStart = ProcStart;

  0004d	8b 45 14	 mov	 eax, DWORD PTR _ProcStart$[ebp]
  00050	89 45 d4	 mov	 DWORD PTR _DataPatch$[ebp+8], eax

; 2847 : 	DataPatch.ProcEnd = ProcEnd;

  00053	8b 45 18	 mov	 eax, DWORD PTR _ProcEnd$[ebp]
  00056	89 45 d8	 mov	 DWORD PTR _DataPatch$[ebp+12], eax

; 2848 : 
; 2849 : #ifdef DEBUG_ON
; 2850 : 	TestWarnings=true;
; 2851 : #else
; 2852 : 	TestWarnings=false;

  00059	c6 45 fb 00	 mov	 BYTE PTR _TestWarnings$[ebp], 0

; 2853 : #endif
; 2854 : 
; 2855 : 	return Trng.SetNewPatch(&DataPatch, TestWarnings);

  0005d	8b f4		 mov	 esi, esp
  0005f	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestWarnings$[ebp]
  00063	50		 push	 eax
  00064	8d 4d cc	 lea	 ecx, DWORD PTR _DataPatch$[ebp]
  00067	51		 push	 ecx
  00068	ff 15 0c 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+12
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2856 : }

  00075	52		 push	 edx
  00076	8b cd		 mov	 ecx, ebp
  00078	50		 push	 eax
  00079	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@ApplyReloc
  0007f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00084	58		 pop	 eax
  00085	5a		 pop	 edx
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx
  00089	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
  0009a	8b ff		 npad	 2
$LN5@ApplyReloc:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@ApplyReloc
$LN4@ApplyReloc:
  000a4	cc ff ff ff	 DD	 -52			; ffffffccH
  000a8	24 00 00 00	 DD	 36			; 00000024H
  000ac	00 00 00 00	 DD	 $LN3@ApplyReloc
$LN3@ApplyReloc:
  000b0	44		 DB	 68			; 00000044H
  000b1	61		 DB	 97			; 00000061H
  000b2	74		 DB	 116			; 00000074H
  000b3	61		 DB	 97			; 00000061H
  000b4	50		 DB	 80			; 00000050H
  000b5	61		 DB	 97			; 00000061H
  000b6	74		 DB	 116			; 00000074H
  000b7	63		 DB	 99			; 00000063H
  000b8	68		 DB	 104			; 00000068H
  000b9	00		 DB	 0
?ApplyRelocatorPatch@@YAHKPAEHKK@Z ENDP			; ApplyRelocatorPatch
_TEXT	ENDS
PUBLIC	?ApplyCallPatch@@YAHPAKHK@Z			; ApplyCallPatch
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ApplyCallPatch@@YAHPAKHK@Z
_TEXT	SEGMENT
_DataPatch$ = -52					; size = 36
_TestWarnings$ = -5					; size = 1
_pVetOffsets$ = 8					; size = 4
_TotOffsets$ = 12					; size = 4
_NewDestAddress$ = 16					; size = 4
?ApplyCallPatch@@YAHPAKHK@Z PROC			; ApplyCallPatch, COMDAT

; 2870 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2871 : 
; 2872 : 	bool TestWarnings;
; 2873 : 	StrPatchInfo DataPatch;
; 2874 : 
; 2875 : 	DataPatch.ErrorCode=0;

  0001e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+28], 0

; 2876 : 	DataPatch.NewValue = NewDestAddress;

  00025	8b 45 10	 mov	 eax, DWORD PTR _NewDestAddress$[ebp]
  00028	89 45 ec	 mov	 DWORD PTR _DataPatch$[ebp+32], eax

; 2877 : 	DataPatch.PatchType = TYPP_PARAMETRIC | TYPP_PARAMETRIC_CALL;

  0002b	c7 45 e4 12 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+24], 18 ; 00000012H

; 2878 : 	DataPatch.pVetItems = pVetOffsets;

  00032	8b 45 08	 mov	 eax, DWORD PTR _pVetOffsets$[ebp]
  00035	89 45 e0	 mov	 DWORD PTR _DataPatch$[ebp+20], eax

; 2879 : 	DataPatch.TotItems = TotOffsets;

  00038	8b 45 0c	 mov	 eax, DWORD PTR _TotOffsets$[ebp]
  0003b	89 45 dc	 mov	 DWORD PTR _DataPatch$[ebp+16], eax

; 2880 : 	DataPatch.PluginId = Trng.IdMyPlugin;

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00043	89 45 cc	 mov	 DWORD PTR _DataPatch$[ebp], eax

; 2881 : 
; 2882 : 
; 2883 : #ifdef DEBUG_ON
; 2884 : 	TestWarnings=true;
; 2885 : #else
; 2886 : 	TestWarnings=false;

  00046	c6 45 fb 00	 mov	 BYTE PTR _TestWarnings$[ebp], 0

; 2887 : #endif
; 2888 : 
; 2889 : 	return Trng.SetNewPatch(&DataPatch, TestWarnings);

  0004a	8b f4		 mov	 esi, esp
  0004c	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestWarnings$[ebp]
  00050	50		 push	 eax
  00051	8d 4d cc	 lea	 ecx, DWORD PTR _DataPatch$[ebp]
  00054	51		 push	 ecx
  00055	ff 15 0c 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+12
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2890 : }

  00062	52		 push	 edx
  00063	8b cd		 mov	 ecx, ebp
  00065	50		 push	 eax
  00066	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@ApplyCallP
  0006c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00071	58		 pop	 eax
  00072	5a		 pop	 edx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
  00087	90		 npad	 1
$LN5@ApplyCallP:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@ApplyCallP
$LN4@ApplyCallP:
  00090	cc ff ff ff	 DD	 -52			; ffffffccH
  00094	24 00 00 00	 DD	 36			; 00000024H
  00098	00 00 00 00	 DD	 $LN3@ApplyCallP
$LN3@ApplyCallP:
  0009c	44		 DB	 68			; 00000044H
  0009d	61		 DB	 97			; 00000061H
  0009e	74		 DB	 116			; 00000074H
  0009f	61		 DB	 97			; 00000061H
  000a0	50		 DB	 80			; 00000050H
  000a1	61		 DB	 97			; 00000061H
  000a2	74		 DB	 116			; 00000074H
  000a3	63		 DB	 99			; 00000063H
  000a4	68		 DB	 104			; 00000068H
  000a5	00		 DB	 0
?ApplyCallPatch@@YAHPAKHK@Z ENDP			; ApplyCallPatch
_TEXT	ENDS
PUBLIC	?ApplyParametricPatch@@YAHPAUStrParamPatch@@HH@Z ; ApplyParametricPatch
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ApplyParametricPatch@@YAHPAUStrParamPatch@@HH@Z
_TEXT	SEGMENT
_DataPatch$ = -52					; size = 36
_TestWarnings$ = -5					; size = 1
_pVetParamList$ = 8					; size = 4
_TotParamList$ = 12					; size = 4
_NewValue$ = 16						; size = 4
?ApplyParametricPatch@@YAHPAUStrParamPatch@@HH@Z PROC	; ApplyParametricPatch, COMDAT

; 2895 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2896 : 	bool TestWarnings;
; 2897 : 	StrPatchInfo DataPatch;
; 2898 : 
; 2899 : 	DataPatch.ErrorCode =0;

  0001e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+28], 0

; 2900 : 	DataPatch.NewValue = NewValue;

  00025	8b 45 10	 mov	 eax, DWORD PTR _NewValue$[ebp]
  00028	89 45 ec	 mov	 DWORD PTR _DataPatch$[ebp+32], eax

; 2901 : 	DataPatch.PatchType = TYPP_PARAMETRIC | TYPP_PARAMETRIC_CONST;

  0002b	c7 45 e4 22 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+24], 34 ; 00000022H

; 2902 : 	DataPatch.PluginId =  Trng.IdMyPlugin;

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00037	89 45 cc	 mov	 DWORD PTR _DataPatch$[ebp], eax

; 2903 : 	DataPatch.pVetItems = pVetParamList;

  0003a	8b 45 08	 mov	 eax, DWORD PTR _pVetParamList$[ebp]
  0003d	89 45 e0	 mov	 DWORD PTR _DataPatch$[ebp+20], eax

; 2904 : 	DataPatch.TotItems = TotParamList;

  00040	8b 45 0c	 mov	 eax, DWORD PTR _TotParamList$[ebp]
  00043	89 45 dc	 mov	 DWORD PTR _DataPatch$[ebp+16], eax

; 2905 : 
; 2906 : #ifdef DEBUG_ON
; 2907 : 	TestWarnings=true;
; 2908 : #else
; 2909 : 	TestWarnings=false;

  00046	c6 45 fb 00	 mov	 BYTE PTR _TestWarnings$[ebp], 0

; 2910 : #endif
; 2911 : 	return Trng.SetNewPatch(&DataPatch, TestWarnings);

  0004a	8b f4		 mov	 esi, esp
  0004c	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestWarnings$[ebp]
  00050	50		 push	 eax
  00051	8d 4d cc	 lea	 ecx, DWORD PTR _DataPatch$[ebp]
  00054	51		 push	 ecx
  00055	ff 15 0c 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+12
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2912 : }

  00062	52		 push	 edx
  00063	8b cd		 mov	 ecx, ebp
  00065	50		 push	 eax
  00066	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@ApplyParam
  0006c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00071	58		 pop	 eax
  00072	5a		 pop	 edx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
  00087	90		 npad	 1
$LN5@ApplyParam:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN4@ApplyParam
$LN4@ApplyParam:
  00090	cc ff ff ff	 DD	 -52			; ffffffccH
  00094	24 00 00 00	 DD	 36			; 00000024H
  00098	00 00 00 00	 DD	 $LN3@ApplyParam
$LN3@ApplyParam:
  0009c	44		 DB	 68			; 00000044H
  0009d	61		 DB	 97			; 00000061H
  0009e	74		 DB	 116			; 00000074H
  0009f	61		 DB	 97			; 00000061H
  000a0	50		 DB	 80			; 00000050H
  000a1	61		 DB	 97			; 00000061H
  000a2	74		 DB	 116			; 00000074H
  000a3	63		 DB	 99			; 00000063H
  000a4	68		 DB	 104			; 00000068H
  000a5	00		 DB	 0
?ApplyParametricPatch@@YAHPAUStrParamPatch@@HH@Z ENDP	; ApplyParametricPatch
_TEXT	ENDS
PUBLIC	?ApplyRestoreCodePatch@@YAHKK@Z			; ApplyRestoreCodePatch
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ApplyRestoreCodePatch@@YAHKK@Z
_TEXT	SEGMENT
_DataPatch$ = -52					; size = 36
_TestWarnings$ = -5					; size = 1
_StartOffset$ = 8					; size = 4
_EndOffset$ = 12					; size = 4
?ApplyRestoreCodePatch@@YAHKK@Z PROC			; ApplyRestoreCodePatch, COMDAT

; 2917 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 08 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-248]
  00012	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2918 : 	bool TestWarnings;
; 2919 : 	StrPatchInfo DataPatch;
; 2920 : 	
; 2921 : 	DataPatch.ErrorCode=0;

  0001e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+28], 0

; 2922 : 	DataPatch.StartOffset = StartOffset;

  00025	8b 45 08	 mov	 eax, DWORD PTR _StartOffset$[ebp]
  00028	89 45 d0	 mov	 DWORD PTR _DataPatch$[ebp+4], eax

; 2923 : 	DataPatch.PatchType = TYPP_CONTIGUOUS_BYTES | TYPP_RESTORE;

  0002b	c7 45 e4 81 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+24], 129 ; 00000081H

; 2924 : 	DataPatch.TotItems = EndOffset - StartOffset +1;

  00032	8b 45 0c	 mov	 eax, DWORD PTR _EndOffset$[ebp]
  00035	2b 45 08	 sub	 eax, DWORD PTR _StartOffset$[ebp]
  00038	83 c0 01	 add	 eax, 1
  0003b	89 45 dc	 mov	 DWORD PTR _DataPatch$[ebp+16], eax

; 2925 : 	DataPatch.PluginId = Trng.IdMyPlugin;

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00043	89 45 cc	 mov	 DWORD PTR _DataPatch$[ebp], eax

; 2926 : 	DataPatch.pVetItems=NULL;

  00046	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _DataPatch$[ebp+20], 0

; 2927 : #ifdef DEBUG_ON
; 2928 : 	TestWarnings=true;
; 2929 : #else
; 2930 : 	TestWarnings=false;

  0004d	c6 45 fb 00	 mov	 BYTE PTR _TestWarnings$[ebp], 0

; 2931 : #endif
; 2932 : 	return Trng.SetNewPatch(&DataPatch, TestWarnings);

  00051	8b f4		 mov	 esi, esp
  00053	0f b6 45 fb	 movzx	 eax, BYTE PTR _TestWarnings$[ebp]
  00057	50		 push	 eax
  00058	8d 4d cc	 lea	 ecx, DWORD PTR _DataPatch$[ebp]
  0005b	51		 push	 ecx
  0005c	ff 15 0c 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+12
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 2933 : }

  00069	52		 push	 edx
  0006a	8b cd		 mov	 ecx, ebp
  0006c	50		 push	 eax
  0006d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@ApplyResto
  00073	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00078	58		 pop	 eax
  00079	5a		 pop	 edx
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 f8 00 00
	00		 add	 esp, 248		; 000000f8H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
  0008e	8b ff		 npad	 2
$LN5@ApplyResto:
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN4@ApplyResto
$LN4@ApplyResto:
  00098	cc ff ff ff	 DD	 -52			; ffffffccH
  0009c	24 00 00 00	 DD	 36			; 00000024H
  000a0	00 00 00 00	 DD	 $LN3@ApplyResto
$LN3@ApplyResto:
  000a4	44		 DB	 68			; 00000044H
  000a5	61		 DB	 97			; 00000061H
  000a6	74		 DB	 116			; 00000074H
  000a7	61		 DB	 97			; 00000061H
  000a8	50		 DB	 80			; 00000050H
  000a9	61		 DB	 97			; 00000061H
  000aa	74		 DB	 116			; 00000074H
  000ab	63		 DB	 99			; 00000063H
  000ac	68		 DB	 104			; 00000068H
  000ad	00		 DB	 0
?ApplyRestoreCodePatch@@YAHKK@Z ENDP			; ApplyRestoreCodePatch
_TEXT	ENDS
PUBLIC	?SetReservedDataZone@@YA_NKK@Z			; SetReservedDataZone
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SetReservedDataZone@@YA_NKK@Z
_TEXT	SEGMENT
_Result$ = -8						; size = 4
_StartOffset$ = 8					; size = 4
_NBytes$ = 12						; size = 4
?SetReservedDataZone@@YA_NKK@Z PROC			; SetReservedDataZone, COMDAT

; 2937 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2938 : 	int Result;
; 2939 : 
; 2940 : 
; 2941 : 	Result = Service( SRV_SetReservedDataZone, StartOffset, NBytes);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _NBytes$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _StartOffset$[ebp]
  00025	51		 push	 ecx
  00026	6a 0d		 push	 13			; 0000000dH
  00028	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	89 45 f8	 mov	 DWORD PTR _Result$[ebp], eax

; 2942 : 	if (Result == 1) return true;

  00033	83 7d f8 01	 cmp	 DWORD PTR _Result$[ebp], 1
  00037	75 04		 jne	 SHORT $LN1@SetReserve
  00039	b0 01		 mov	 al, 1
  0003b	eb 02		 jmp	 SHORT $LN2@SetReserve
$LN1@SetReserve:

; 2943 : 	return false;

  0003d	32 c0		 xor	 al, al
$LN2@SetReserve:

; 2944 : 
; 2945 : 
; 2946 : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?SetReservedDataZone@@YA_NKK@Z ENDP			; SetReservedDataZone
_TEXT	ENDS
PUBLIC	?CompareTrngVersion@@YAHQAG@Z			; CompareTrngVersion
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CompareTrngVersion@@YAHQAG@Z
_TEXT	SEGMENT
_n$ = -32						; size = 4
_pTrngVer$ = -20					; size = 4
_i$ = -8						; size = 4
_VetVersion$ = 8					; size = 4
?CompareTrngVersion@@YAHQAG@Z PROC			; CompareTrngVersion, COMDAT

; 2954 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2955 : 	int i;
; 2956 : 	WORD *pTrngVer;
; 2957 : 	int n;
; 2958 : 
; 2959 : 	pTrngVer = Trng.pGlobTomb4->BaseVersione.VetVersione;

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	05 60 1f 07 00	 add	 eax, 466784		; 00071f60H
  00028	89 45 ec	 mov	 DWORD PTR _pTrngVer$[ebp], eax

; 2960 : 
; 2961 : 	n=0;

  0002b	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0

; 2962 : 	
; 2963 : 	for (i=0;i<4;i++) {

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00039	eb 09		 jmp	 SHORT $LN5@CompareTrn
$LN4@CompareTrn:
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN5@CompareTrn:
  00044	83 7d f8 04	 cmp	 DWORD PTR _i$[ebp], 4
  00048	7d 44		 jge	 SHORT $LN3@CompareTrn

; 2964 : 		if (pTrngVer[i] > VetVersion[i]) {

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _pTrngVer$[ebp]
  00050	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00054	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00057	8b 4d 08	 mov	 ecx, DWORD PTR _VetVersion$[ebp]
  0005a	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  0005e	3b d0		 cmp	 edx, eax
  00060	7e 09		 jle	 SHORT $LN2@CompareTrn

; 2965 : 			n = 1;

  00062	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _n$[ebp], 1

; 2966 : 			break;

  00069	eb 23		 jmp	 SHORT $LN3@CompareTrn
$LN2@CompareTrn:

; 2967 : 		}
; 2968 : 		if (pTrngVer[i] < VetVersion[i]) {

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR _pTrngVer$[ebp]
  00071	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00075	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00078	8b 4d 08	 mov	 ecx, DWORD PTR _VetVersion$[ebp]
  0007b	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  0007f	3b d0		 cmp	 edx, eax
  00081	7d 09		 jge	 SHORT $LN1@CompareTrn

; 2969 : 			n = -1;

  00083	c7 45 e0 ff ff
	ff ff		 mov	 DWORD PTR _n$[ebp], -1

; 2970 : 			break;

  0008a	eb 02		 jmp	 SHORT $LN3@CompareTrn
$LN1@CompareTrn:

; 2971 : 		}
; 2972 : 	}

  0008c	eb ad		 jmp	 SHORT $LN4@CompareTrn
$LN3@CompareTrn:

; 2973 : 
; 2974 : 	return n;

  0008e	8b 45 e0	 mov	 eax, DWORD PTR _n$[ebp]

; 2975 : 
; 2976 : }

  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?CompareTrngVersion@@YAHQAG@Z ENDP			; CompareTrngVersion
_TEXT	ENDS
PUBLIC	?FindSkipPhase@@YAKXZ				; FindSkipPhase
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FindSkipPhase@@YAKXZ
_TEXT	SEGMENT
_FlagsSkip$ = -8					; size = 4
?FindSkipPhase@@YAKXZ PROC				; FindSkipPhase, COMDAT

; 2981 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 2982 : 	DWORD FlagsSkip;
; 2983 : 
; 2984 : 
; 2985 : 	FlagsSkip= SKIP_NONE;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _FlagsSkip$[ebp], 0

; 2986 : 
; 2987 : 	if (*Trng.pGlobTomb4->pAdr->pFadeScreen) FlagsSkip |= SKIP_FADE;

  00025	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0002a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00030	8b 91 c4 01 00
	00		 mov	 edx, DWORD PTR [ecx+452]
  00036	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00039	85 c0		 test	 eax, eax
  0003b	74 09		 je	 SHORT $LN10@FindSkipPh
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  00040	83 c8 08	 or	 eax, 8
  00043	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN10@FindSkipPh:

; 2988 : 
; 2989 : 	if (*Trng.pGlobTomb4->pAdr->pTestLoading) FlagsSkip |= SKIP_LOADING_LEVEL;

  00046	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0004b	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00051	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [ecx+448]
  00057	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0005a	85 c0		 test	 eax, eax
  0005c	74 09		 je	 SHORT $LN9@FindSkipPh
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  00061	83 c8 04	 or	 eax, 4
  00064	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN9@FindSkipPh:

; 2990 :   
; 2991 : 	if (*Trng.pGlobTomb4->pAdr->Camera.pModeCameraNow  == 1) FlagsSkip |= SKIP_FIXED_CAMERA;	

  00067	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0006c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00072	8b 91 fc 00 00
	00		 mov	 edx, DWORD PTR [ecx+252]
  00078	83 3a 01	 cmp	 DWORD PTR [edx], 1
  0007b	75 09		 jne	 SHORT $LN8@FindSkipPh
  0007d	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  00080	83 c8 01	 or	 eax, 1
  00083	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN8@FindSkipPh:

; 2992 : 
; 2993 : 	if (*Trng.pGlobTomb4->pAdr->pTestFlybyInProgress) FlagsSkip |= SKIP_FLY_CAMERA;

  00086	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0008b	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00091	8b 91 14 01 00
	00		 mov	 edx, DWORD PTR [ecx+276]
  00097	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0009a	74 09		 je	 SHORT $LN7@FindSkipPh
  0009c	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  0009f	83 c8 02	 or	 eax, 2
  000a2	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN7@FindSkipPh:

; 2994 : 
; 2995 : 	if (*Trng.pGlobTomb4->pAdr->pLevelNow == 0 &&
; 2996 : 		(*Trng.pGlobTomb4->pAdr->pScriptMainFlags & 0x04)) FlagsSkip |= SKIP_TITLE_LEVEL;

  000a5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000aa	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000b0	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  000b6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000b9	85 c0		 test	 eax, eax
  000bb	75 22		 jne	 SHORT $LN6@FindSkipPh
  000bd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000c2	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000c8	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  000ce	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000d1	83 e0 04	 and	 eax, 4
  000d4	74 09		 je	 SHORT $LN6@FindSkipPh
  000d6	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  000d9	83 c8 10	 or	 eax, 16			; 00000010H
  000dc	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN6@FindSkipPh:

; 2997 : 
; 2998 : 	if (*Trng.pGlobTomb4->pAdr->pTestGrayScreen) FlagsSkip |= SKIP_GRAY_SCREEN;

  000df	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000e4	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000ea	8b 91 bc 01 00
	00		 mov	 edx, DWORD PTR [ecx+444]
  000f0	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f3	85 c0		 test	 eax, eax
  000f5	74 09		 je	 SHORT $LN5@FindSkipPh
  000f7	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  000fa	83 c8 20	 or	 eax, 32			; 00000020H
  000fd	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN5@FindSkipPh:

; 2999 : 
; 3000 : 	if (Trng.pGlobTomb4->TestSuspendObjectShowing == true) FlagsSkip |= SKIP_NO_VIEW_OGGETTI;

  00100	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00105	0f b6 88 3a 22
	20 00		 movzx	 ecx, BYTE PTR [eax+2105914]
  0010c	83 f9 01	 cmp	 ecx, 1
  0010f	75 09		 jne	 SHORT $LN4@FindSkipPh
  00111	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  00114	83 c8 40	 or	 eax, 64			; 00000040H
  00117	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN4@FindSkipPh:

; 3001 : 
; 3002 : 	if (*Trng.pGlobTomb4->pAdr->pZoomFactor != 0 && *Trng.pGlobTomb4->pAdr->pTestLaserSight ==0) FlagsSkip |= SKIP_BINOCULARS;

  0011a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0011f	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00125	8b 91 b8 01 00
	00		 mov	 edx, DWORD PTR [ecx+440]
  0012b	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0012e	74 23		 je	 SHORT $LN3@FindSkipPh
  00130	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00135	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0013b	8b 91 b4 01 00
	00		 mov	 edx, DWORD PTR [ecx+436]
  00141	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00144	85 c0		 test	 eax, eax
  00146	75 0b		 jne	 SHORT $LN3@FindSkipPh
  00148	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  0014b	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  00150	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN3@FindSkipPh:

; 3003 : 
; 3004 : 	if (*Trng.pGlobTomb4->pAdr->pTestLaserSight && (*Trng.pGlobTomb4->pAdr->pInputExtGameCommands & 0x200) != 0) FlagsSkip |= SKIP_LASER_SIGHT;

  00153	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00158	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0015e	8b 91 b4 01 00
	00		 mov	 edx, DWORD PTR [ecx+436]
  00164	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00167	85 c0		 test	 eax, eax
  00169	74 22		 je	 SHORT $LN2@FindSkipPh
  0016b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00170	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00176	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  00179	8b 02		 mov	 eax, DWORD PTR [edx]
  0017b	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00180	74 0b		 je	 SHORT $LN2@FindSkipPh
  00182	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  00185	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  0018a	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN2@FindSkipPh:

; 3005 : 
; 3006 : 	if (Trng.pGlobTomb4->TestOverlapImage==true) FlagsSkip |= SKIP_FULL_IMAGE;

  0018d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00192	0f b6 88 9e 50
	21 00		 movzx	 ecx, BYTE PTR [eax+2183326]
  00199	83 f9 01	 cmp	 ecx, 1
  0019c	75 0b		 jne	 SHORT $LN1@FindSkipPh
  0019e	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]
  001a1	0d 00 02 00 00	 or	 eax, 512		; 00000200H
  001a6	89 45 f8	 mov	 DWORD PTR _FlagsSkip$[ebp], eax
$LN1@FindSkipPh:

; 3007 : 
; 3008 : 	return FlagsSkip;

  001a9	8b 45 f8	 mov	 eax, DWORD PTR _FlagsSkip$[ebp]

; 3009 : 
; 3010 : }

  001ac	5f		 pop	 edi
  001ad	5e		 pop	 esi
  001ae	5b		 pop	 ebx
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
?FindSkipPhase@@YAKXZ ENDP				; FindSkipPhase
_TEXT	ENDS
PUBLIC	??_C@_0CC@BEHLMMOJ@ERROR?3?5cann?8t?5locate?5plugin?3?5?$CC?$CFs@ ; `string'
PUBLIC	?FindPluginID@@YAHQAD@Z				; FindPluginID
EXTRN	__imp__strcmpi:PROC
;	COMDAT ??_C@_0CC@BEHLMMOJ@ERROR?3?5cann?8t?5locate?5plugin?3?5?$CC?$CFs@
CONST	SEGMENT
??_C@_0CC@BEHLMMOJ@ERROR?3?5cann?8t?5locate?5plugin?3?5?$CC?$CFs@ DB 'ERR'
	DB	'OR: cann''t locate plugin: "%s"', 00H	; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?FindPluginID@@YAHQAD@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_PluginName$ = 8					; size = 4
?FindPluginID@@YAHQAD@Z PROC				; FindPluginID, COMDAT

; 3017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3018 : 	int i;
; 3019 : 
; 3020 : 	for (i=0;i<Trng.TotPlugins;i++) {

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@FindPlugin
$LN3@FindPlugin:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FindPlugin:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 05 28 00 00
	00		 cmp	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+40
  00039	7d 2e		 jge	 SHORT $LN2@FindPlugin

; 3021 : 		if (strcmpi(PluginName, Trng.pVetPluginNames[i])==0) {

  0003b	8b f4		 mov	 esi, esp
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00040	8b 0d 2c 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+44
  00046	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  00049	52		 push	 edx
  0004a	8b 45 08	 mov	 eax, DWORD PTR _PluginName$[ebp]
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strcmpi
  00054	83 c4 08	 add	 esp, 8
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	85 c0		 test	 eax, eax
  00060	75 05		 jne	 SHORT $LN1@FindPlugin

; 3022 : 			return i;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00065	eb 16		 jmp	 SHORT $LN5@FindPlugin
$LN1@FindPlugin:

; 3023 : 		}
; 3024 : 	}

  00067	eb be		 jmp	 SHORT $LN3@FindPlugin
$LN2@FindPlugin:

; 3025 : 
; 3026 : 	SendToLog("ERROR: cann't locate plugin: \"%s\"", PluginName);

  00069	8b 45 08	 mov	 eax, DWORD PTR _PluginName$[ebp]
  0006c	50		 push	 eax
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@BEHLMMOJ@ERROR?3?5cann?8t?5locate?5plugin?3?5?$CC?$CFs@
  00072	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00077	83 c4 08	 add	 esp, 8

; 3027 : 
; 3028 : 
; 3029 : 	return -1;

  0007a	83 c8 ff	 or	 eax, -1
$LN5@FindPlugin:

; 3030 : 
; 3031 : 	
; 3032 : }

  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?FindPluginID@@YAHQAD@Z ENDP				; FindPluginID
_TEXT	ENDS
PUBLIC	?PerformExportedTrigger@@YA_NPADHHH@Z		; PerformExportedTrigger
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PerformExportedTrigger@@YA_NPADHHH@Z
_TEXT	SEGMENT
_PluginId$ = -8						; size = 4
_pPluginName$ = 8					; size = 4
_Arg1$ = 12						; size = 4
_Arg2$ = 16						; size = 4
_Arg3$ = 20						; size = 4
?PerformExportedTrigger@@YA_NPADHHH@Z PROC		; PerformExportedTrigger, COMDAT

; 3036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3037 : 	int PluginId;
; 3038 : 
; 3039 : 	if (pPluginName==NULL) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pPluginName$[ebp], 0
  00022	75 09		 jne	 SHORT $LN4@PerformExp

; 3040 : 		PluginId=0;

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _PluginId$[ebp], 0

; 3041 : 	}else {

  0002b	eb 0f		 jmp	 SHORT $LN3@PerformExp
$LN4@PerformExp:

; 3042 : 		// ora dovrei usarre id di script		
; 3043 : 		PluginId=FindPluginID(pPluginName);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pPluginName$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?FindPluginID@@YAHQAD@Z	; FindPluginID
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR _PluginId$[ebp], eax
$LN3@PerformExp:

; 3044 : 	}
; 3045 : 	if (PluginId == -1) return false;

  0003c	83 7d f8 ff	 cmp	 DWORD PTR _PluginId$[ebp], -1
  00040	75 04		 jne	 SHORT $LN2@PerformExp
  00042	32 c0		 xor	 al, al
  00044	eb 2f		 jmp	 SHORT $LN5@PerformExp
$LN2@PerformExp:

; 3046 : 
; 3047 : 	Arg1 &= 0xFFFF;

  00046	8b 45 0c	 mov	 eax, DWORD PTR _Arg1$[ebp]
  00049	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0004e	89 45 0c	 mov	 DWORD PTR _Arg1$[ebp], eax

; 3048 : 
; 3049 : 	if (Service(SRV_PERFORM_EXPORTED_TRIGGER, PluginId, Arg1, Arg2, Arg3)>0) return true;

  00051	8b 45 14	 mov	 eax, DWORD PTR _Arg3$[ebp]
  00054	50		 push	 eax
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _Arg2$[ebp]
  00058	51		 push	 ecx
  00059	8b 55 0c	 mov	 edx, DWORD PTR _Arg1$[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 f8	 mov	 eax, DWORD PTR _PluginId$[ebp]
  00060	50		 push	 eax
  00061	6a 04		 push	 4
  00063	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00068	83 c4 14	 add	 esp, 20			; 00000014H
  0006b	85 c0		 test	 eax, eax
  0006d	7e 04		 jle	 SHORT $LN1@PerformExp
  0006f	b0 01		 mov	 al, 1
  00071	eb 02		 jmp	 SHORT $LN5@PerformExp
$LN1@PerformExp:

; 3050 : 	return false;

  00073	32 c0		 xor	 al, al
$LN5@PerformExp:

; 3051 : 
; 3052 : 
; 3053 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?PerformExportedTrigger@@YA_NPADHHH@Z ENDP		; PerformExportedTrigger
_TEXT	ENDS
PUBLIC	?PerformFlipeffect@@YA_NPADHHH@Z		; PerformFlipeffect
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PerformFlipeffect@@YA_NPADHHH@Z
_TEXT	SEGMENT
_PluginId$ = -20					; size = 4
_TimerField$ = -8					; size = 4
_pPluginName$ = 8					; size = 4
_FlipNumber$ = 12					; size = 4
_Arg1$ = 16						; size = 4
_Arg2$ = 20						; size = 4
?PerformFlipeffect@@YA_NPADHHH@Z PROC			; PerformFlipeffect, COMDAT

; 3059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3060 : 	int TimerField;
; 3061 : 	int PluginId;
; 3062 : 
; 3063 : 	if (Arg2==0) {

  0001e	83 7d 14 00	 cmp	 DWORD PTR _Arg2$[ebp], 0
  00022	75 08		 jne	 SHORT $LN5@PerformFli

; 3064 : 		TimerField=Arg1;

  00024	8b 45 10	 mov	 eax, DWORD PTR _Arg1$[ebp]
  00027	89 45 f8	 mov	 DWORD PTR _TimerField$[ebp], eax

; 3065 : 	}else {

  0002a	eb 0c		 jmp	 SHORT $LN4@PerformFli
$LN5@PerformFli:

; 3066 : 		TimerField = Arg1 | (Arg2 << 8);

  0002c	8b 45 14	 mov	 eax, DWORD PTR _Arg2$[ebp]
  0002f	c1 e0 08	 shl	 eax, 8
  00032	0b 45 10	 or	 eax, DWORD PTR _Arg1$[ebp]
  00035	89 45 f8	 mov	 DWORD PTR _TimerField$[ebp], eax
$LN4@PerformFli:

; 3067 : 	}
; 3068 : 	if (pPluginName==NULL) {

  00038	83 7d 08 00	 cmp	 DWORD PTR _pPluginName$[ebp], 0
  0003c	75 09		 jne	 SHORT $LN3@PerformFli

; 3069 : 		PluginId=0;

  0003e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _PluginId$[ebp], 0

; 3070 : 	}else {

  00045	eb 0f		 jmp	 SHORT $LN2@PerformFli
$LN3@PerformFli:

; 3071 : 		PluginId=FindPluginID(pPluginName);

  00047	8b 45 08	 mov	 eax, DWORD PTR _pPluginName$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?FindPluginID@@YAHQAD@Z	; FindPluginID
  00050	83 c4 04	 add	 esp, 4
  00053	89 45 ec	 mov	 DWORD PTR _PluginId$[ebp], eax
$LN2@PerformFli:

; 3072 : 	}
; 3073 : 	if (PluginId == -1) return false;

  00056	83 7d ec ff	 cmp	 DWORD PTR _PluginId$[ebp], -1
  0005a	75 04		 jne	 SHORT $LN1@PerformFli
  0005c	32 c0		 xor	 al, al
  0005e	eb 18		 jmp	 SHORT $LN6@PerformFli
$LN1@PerformFli:

; 3074 : 	
; 3075 : 	Service(SRV_PERFORM_FLIPEFFECT, PluginId, FlipNumber, TimerField);

  00060	8b 45 f8	 mov	 eax, DWORD PTR _TimerField$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _FlipNumber$[ebp]
  00067	51		 push	 ecx
  00068	8b 55 ec	 mov	 edx, DWORD PTR _PluginId$[ebp]
  0006b	52		 push	 edx
  0006c	6a 00		 push	 0
  0006e	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00073	83 c4 10	 add	 esp, 16			; 00000010H

; 3076 : 	return true;

  00076	b0 01		 mov	 al, 1
$LN6@PerformFli:

; 3077 : 
; 3078 : }

  00078	5f		 pop	 edi
  00079	5e		 pop	 esi
  0007a	5b		 pop	 ebx
  0007b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00081	3b ec		 cmp	 ebp, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
?PerformFlipeffect@@YA_NPADHHH@Z ENDP			; PerformFlipeffect
_TEXT	ENDS
PUBLIC	?PerformActionTrigger@@YAXPADHHH@Z		; PerformActionTrigger
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PerformActionTrigger@@YAXPADHHH@Z
_TEXT	SEGMENT
_Index$ = -20						; size = 4
_PluginId$ = -8						; size = 4
_pPluginName$ = 8					; size = 4
_ActionNumber$ = 12					; size = 4
_ObjectIndex$ = 16					; size = 4
_ExtraTimer$ = 20					; size = 4
?PerformActionTrigger@@YAXPADHHH@Z PROC			; PerformActionTrigger, COMDAT

; 3084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3085 : 	int PluginId;
; 3086 : 	int Index;
; 3087 : 
; 3088 : 	if (pPluginName==NULL) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pPluginName$[ebp], 0
  00022	75 09		 jne	 SHORT $LN4@PerformAct

; 3089 : 		PluginId=0;

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _PluginId$[ebp], 0

; 3090 : 	}else {

  0002b	eb 17		 jmp	 SHORT $LN3@PerformAct
$LN4@PerformAct:

; 3091 : 		PluginId=FindPluginID(pPluginName);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pPluginName$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?FindPluginID@@YAHQAD@Z	; FindPluginID
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR _PluginId$[ebp], eax

; 3092 : 		if (PluginId==-1) return;

  0003c	83 7d f8 ff	 cmp	 DWORD PTR _PluginId$[ebp], -1
  00040	75 02		 jne	 SHORT $LN3@PerformAct
  00042	eb 3e		 jmp	 SHORT $LN5@PerformAct
$LN3@PerformAct:

; 3093 : 	}
; 3094 : 
; 3095 : 	if (ObjectIndex & NGLE_INDEX) {

  00044	8b 45 10	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  00047	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0004c	74 1a		 je	 SHORT $LN1@PerformAct

; 3096 : 		Index = ObjectIndex & MASK_NGLE_INDEX;

  0004e	8b 45 10	 mov	 eax, DWORD PTR _ObjectIndex$[ebp]
  00051	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00056	89 45 ec	 mov	 DWORD PTR _Index$[ebp], eax

; 3097 : 		ObjectIndex = FromNgleIndexToTomb4Index(Index);

  00059	8b 45 ec	 mov	 eax, DWORD PTR _Index$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  00062	83 c4 04	 add	 esp, 4
  00065	89 45 10	 mov	 DWORD PTR _ObjectIndex$[ebp], eax
$LN1@PerformAct:

; 3098 : 	}
; 3099 : 	
; 3100 : 	Service(SRV_PERFORM_ACTION, PluginId, ActionNumber, ObjectIndex, ExtraTimer);

  00068	8b 45 14	 mov	 eax, DWORD PTR _ExtraTimer$[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 10	 mov	 ecx, DWORD PTR _ObjectIndex$[ebp]
  0006f	51		 push	 ecx
  00070	8b 55 0c	 mov	 edx, DWORD PTR _ActionNumber$[ebp]
  00073	52		 push	 edx
  00074	8b 45 f8	 mov	 eax, DWORD PTR _PluginId$[ebp]
  00077	50		 push	 eax
  00078	6a 01		 push	 1
  0007a	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0007f	83 c4 14	 add	 esp, 20			; 00000014H
$LN5@PerformAct:

; 3101 : 
; 3102 : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008b	3b ec		 cmp	 ebp, esp
  0008d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00092	8b e5		 mov	 esp, ebp
  00094	5d		 pop	 ebp
  00095	c3		 ret	 0
?PerformActionTrigger@@YAXPADHHH@Z ENDP			; PerformActionTrigger
_TEXT	ENDS
PUBLIC	?PerformConditionTrigger@@YA_NPADHHH@Z		; PerformConditionTrigger
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PerformConditionTrigger@@YA_NPADHHH@Z
_TEXT	SEGMENT
_Index$ = -20						; size = 4
_PluginId$ = -8						; size = 4
_pPluginName$ = 8					; size = 4
_ConditionNumber$ = 12					; size = 4
_ObjectField$ = 16					; size = 4
_Extra$ = 20						; size = 4
?PerformConditionTrigger@@YA_NPADHHH@Z PROC		; PerformConditionTrigger, COMDAT

; 3110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3111 : 
; 3112 : 	int PluginId;
; 3113 : 	int Index;
; 3114 : 
; 3115 : 	if (pPluginName==NULL) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pPluginName$[ebp], 0
  00022	75 09		 jne	 SHORT $LN5@PerformCon

; 3116 : 		PluginId=0;

  00024	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _PluginId$[ebp], 0

; 3117 : 	}else {

  0002b	eb 19		 jmp	 SHORT $LN4@PerformCon
$LN5@PerformCon:

; 3118 : 		PluginId=FindPluginID(pPluginName);

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pPluginName$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?FindPluginID@@YAHQAD@Z	; FindPluginID
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR _PluginId$[ebp], eax

; 3119 : 		if (PluginId==-1) return false;

  0003c	83 7d f8 ff	 cmp	 DWORD PTR _PluginId$[ebp], -1
  00040	75 04		 jne	 SHORT $LN4@PerformCon
  00042	32 c0		 xor	 al, al
  00044	eb 48		 jmp	 SHORT $LN6@PerformCon
$LN4@PerformCon:

; 3120 : 	}
; 3121 : 	if (ObjectField & NGLE_INDEX) {

  00046	8b 45 10	 mov	 eax, DWORD PTR _ObjectField$[ebp]
  00049	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0004e	74 1a		 je	 SHORT $LN2@PerformCon

; 3122 : 		Index = ObjectField & MASK_NGLE_INDEX;

  00050	8b 45 10	 mov	 eax, DWORD PTR _ObjectField$[ebp]
  00053	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00058	89 45 ec	 mov	 DWORD PTR _Index$[ebp], eax

; 3123 : 		ObjectField = FromNgleIndexToTomb4Index(Index);

  0005b	8b 45 ec	 mov	 eax, DWORD PTR _Index$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  00064	83 c4 04	 add	 esp, 4
  00067	89 45 10	 mov	 DWORD PTR _ObjectField$[ebp], eax
$LN2@PerformCon:

; 3124 : 	}
; 3125 : 
; 3126 : 	if (Service(SRV_PERFORM_CONDITION, PluginId, ConditionNumber, ObjectField, Extra)!=0) return true;

  0006a	8b 45 14	 mov	 eax, DWORD PTR _Extra$[ebp]
  0006d	50		 push	 eax
  0006e	8b 4d 10	 mov	 ecx, DWORD PTR _ObjectField$[ebp]
  00071	51		 push	 ecx
  00072	8b 55 0c	 mov	 edx, DWORD PTR _ConditionNumber$[ebp]
  00075	52		 push	 edx
  00076	8b 45 f8	 mov	 eax, DWORD PTR _PluginId$[ebp]
  00079	50		 push	 eax
  0007a	6a 02		 push	 2
  0007c	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	85 c0		 test	 eax, eax
  00086	74 04		 je	 SHORT $LN1@PerformCon
  00088	b0 01		 mov	 al, 1
  0008a	eb 02		 jmp	 SHORT $LN6@PerformCon
$LN1@PerformCon:

; 3127 : 
; 3128 : 	return false;

  0008c	32 c0		 xor	 al, al
$LN6@PerformCon:

; 3129 : 
; 3130 : }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
?PerformConditionTrigger@@YA_NPADHHH@Z ENDP		; PerformConditionTrigger
_TEXT	ENDS
PUBLIC	?ReadDxInput@@YAKXZ				; ReadDxInput
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ReadDxInput@@YAKXZ
_TEXT	SEGMENT
?ReadDxInput@@YAKXZ PROC				; ReadDxInput, COMDAT

; 3135 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3136 : 	
; 3137 : 	return Service(SRV_F_ReadDxInput);

  0001e	6a 33		 push	 51			; 00000033H
  00020	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00025	83 c4 04	 add	 esp, 4

; 3138 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?ReadDxInput@@YAKXZ ENDP				; ReadDxInput
_TEXT	ENDS
PUBLIC	?ReadInputBox@@YAHPAUHDC__@@PAUtagRECT@@QADKGH@Z ; ReadInputBox
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ReadInputBox@@YAHPAUHDC__@@PAUtagRECT@@QADKGH@Z
_TEXT	SEGMENT
_hDC$ = 8						; size = 4
_pRect$ = 12						; size = 4
_Buffer$ = 16						; size = 4
_MaxChars$ = 20						; size = 4
_RIB_Flags$ = 24					; size = 2
_SfxSound$ = 28						; size = 4
?ReadInputBox@@YAHPAUHDC__@@PAUtagRECT@@QADKGH@Z PROC	; ReadInputBox, COMDAT

; 3154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3155 : 	return Service(SRV_F_ReadInputBox, hDC, pRect, Buffer, MaxChars, RIB_Flags, SfxSound);

  0001e	8b 45 1c	 mov	 eax, DWORD PTR _SfxSound$[ebp]
  00021	50		 push	 eax
  00022	0f b7 4d 18	 movzx	 ecx, WORD PTR _RIB_Flags$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 14	 mov	 edx, DWORD PTR _MaxChars$[ebp]
  0002a	52		 push	 edx
  0002b	8b 45 10	 mov	 eax, DWORD PTR _Buffer$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pRect$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR _hDC$[ebp]
  00036	52		 push	 edx
  00037	6a 38		 push	 56			; 00000038H
  00039	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0003e	83 c4 1c	 add	 esp, 28			; 0000001cH

; 3156 : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?ReadInputBox@@YAHPAUHDC__@@PAUtagRECT@@QADKGH@Z ENDP	; ReadInputBox
_TEXT	ENDS
PUBLIC	?SuspendAudioTrack@@YAXH_N@Z			; SuspendAudioTrack
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SuspendAudioTrack@@YAXH_N@Z
_TEXT	SEGMENT
_NewAudioTrack$ = 8					; size = 4
_TestLoop$ = 12						; size = 1
?SuspendAudioTrack@@YAXH_N@Z PROC			; SuspendAudioTrack, COMDAT

; 3169 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3170 : 
; 3171 : 	Service(SRV_F_SuspendAudioTrack, NewAudioTrack,TestLoop);

  0001e	0f b6 45 0c	 movzx	 eax, BYTE PTR _TestLoop$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _NewAudioTrack$[ebp]
  00026	51		 push	 ecx
  00027	6a 34		 push	 52			; 00000034H
  00029	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3172 : 
; 3173 : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?SuspendAudioTrack@@YAXH_N@Z ENDP			; SuspendAudioTrack
_TEXT	ENDS
PUBLIC	?ResumeAudioTrack@@YAXXZ			; ResumeAudioTrack
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ResumeAudioTrack@@YAXXZ
_TEXT	SEGMENT
?ResumeAudioTrack@@YAXXZ PROC				; ResumeAudioTrack, COMDAT

; 3179 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3180 : 	Service(SRV_F_ResumeAudioTrack);	

  0001e	6a 35		 push	 53			; 00000035H
  00020	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00025	83 c4 04	 add	 esp, 4

; 3181 : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?ResumeAudioTrack@@YAXXZ ENDP				; ResumeAudioTrack
_TEXT	ENDS
PUBLIC	?CreateWindowsFont@@YAPAUHFONT__@@PAUStrWindowsFont@@_N@Z ; CreateWindowsFont
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CreateWindowsFont@@YAPAUHFONT__@@PAUStrWindowsFont@@_N@Z
_TEXT	SEGMENT
_pFont$ = 8						; size = 4
_TestNoResize$ = 12					; size = 1
?CreateWindowsFont@@YAPAUHFONT__@@PAUStrWindowsFont@@_N@Z PROC ; CreateWindowsFont, COMDAT

; 3190 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3191 : 	return (HFONT) Service(SRV_F_CreateWindowsFont, pFont, TestNoResize);

  0001e	0f b6 45 0c	 movzx	 eax, BYTE PTR _TestNoResize$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pFont$[ebp]
  00026	51		 push	 ecx
  00027	6a 36		 push	 54			; 00000036H
  00029	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3192 : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?CreateWindowsFont@@YAPAUHFONT__@@PAUStrWindowsFont@@_N@Z ENDP ; CreateWindowsFont
_TEXT	ENDS
PUBLIC	?FreeWindowsFont@@YAXPAUStrWindowsFont@@@Z	; FreeWindowsFont
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeWindowsFont@@YAXPAUStrWindowsFont@@@Z
_TEXT	SEGMENT
_pFont$ = 8						; size = 4
?FreeWindowsFont@@YAXPAUStrWindowsFont@@@Z PROC		; FreeWindowsFont, COMDAT

; 3198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3199 : 	Service(SRV_F_FreeWindowsFont, pFont);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pFont$[ebp]
  00021	50		 push	 eax
  00022	6a 37		 push	 55			; 00000037H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 3200 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?FreeWindowsFont@@YAXPAUStrWindowsFont@@@Z ENDP		; FreeWindowsFont
_TEXT	ENDS
PUBLIC	?CallFromTrng@@YAHXZ				; CallFromTrng
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CallFromTrng@@YAHXZ
_TEXT	SEGMENT
?CallFromTrng@@YAHXZ PROC				; CallFromTrng, COMDAT

; 3207 : 	xor eax, eax

  00000	33 c0		 xor	 eax, eax

; 3208 : 	retn

  00002	c3		 ret	 0
?CallFromTrng@@YAHXZ ENDP				; CallFromTrng
_TEXT	ENDS
PUBLIC	?GetTrngInfo@@YAXXZ				; GetTrngInfo
EXTRN	_strcpy:PROC
EXTRN	?MyTomb4PatcherAddress@@3KA:DWORD		; MyTomb4PatcherAddress
EXTRN	?MainPatcher@@YAHXZ:PROC			; MainPatcher
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetTrngInfo@@YAXXZ
_TEXT	SEGMENT
_pSrcInfo$ = -8						; size = 4
?GetTrngInfo@@YAXXZ PROC				; GetTrngInfo, COMDAT

; 3219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3220 : 
; 3221 : 	StrTrngInfos *pSrcInfo = (StrTrngInfos *) 0x4A6E70;

  0001e	c7 45 f8 70 6e
	4a 00		 mov	 DWORD PTR _pSrcInfo$[ebp], 4877936 ; 004a6e70H

; 3222 : 
; 3223 : 	Trng = *pSrcInfo;

  00025	8b 75 f8	 mov	 esi, DWORD PTR _pSrcInfo$[ebp]
  00028	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  0002d	bf 00 00 00 00	 mov	 edi, OFFSET ?Trng@@3UStrTrngInfos@@A ; Trng
  00032	f3 a5		 rep movsd

; 3224 : 	// the plugin returns the setting about the address of MainPatcher function:
; 3225 : 	pSrcInfo->pAdrDllPatcher = &MainPatcher;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _pSrcInfo$[ebp]
  00037	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET ?MainPatcher@@YAHXZ ; MainPatcher

; 3226 : 	// and the address in tomb4 code where this address will be saved: 
; 3227 : 	pSrcInfo->AdrTomb4Patcher = MyTomb4PatcherAddress; 

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _pSrcInfo$[ebp]
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?MyTomb4PatcherAddress@@3KA ; MyTomb4PatcherAddress
  00047	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 3228 : 	// and the address for directcall from trng to plugin code
; 3229 : 	pSrcInfo->pDirectCallBack = &CallFromTrng;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _pSrcInfo$[ebp]
  0004d	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], OFFSET ?CallFromTrng@@YAHXZ ; CallFromTrng

; 3230 : 
; 3231 : 	// copy current plugin name
; 3232 : 	strcpy(TexMyPluginName, pSrcInfo->pMyPluginName);

  00054	8b 45 f8	 mov	 eax, DWORD PTR _pSrcInfo$[ebp]
  00057	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0005a	51		 push	 ecx
  0005b	68 00 00 00 00	 push	 OFFSET ?TexMyPluginName@@3PADA ; TexMyPluginName
  00060	e8 00 00 00 00	 call	 _strcpy
  00065	83 c4 08	 add	 esp, 8

; 3233 : 	
; 3234 : 	// initialise auto-enumerator for some mnemonic constants
; 3235 : 	InitialiseEnums();

  00068	e8 00 00 00 00	 call	 ?InitialiseEnums@@YAXXZ	; InitialiseEnums

; 3236 : 
; 3237 : 	// and the current version (debug or release)
; 3238 : #ifdef DEBUG_ON
; 3239 : 	pSrcInfo->TestDebugMode = 1;
; 3240 : #else
; 3241 : 	pSrcInfo->TestDebugMode = 0;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _pSrcInfo$[ebp]
  00070	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 3242 : #endif
; 3243 : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?GetTrngInfo@@YAXXZ ENDP				; GetTrngInfo
_TEXT	ENDS
PUBLIC	?GetMemory@@YAPAXK@Z				; GetMemory
EXTRN	__imp__malloc:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetMemory@@YAPAXK@Z
_TEXT	SEGMENT
_pMem$ = -8						; size = 4
_SizeOfMemory$ = 8					; size = 4
?GetMemory@@YAPAXK@Z PROC				; GetMemory, COMDAT

; 3256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3257 : 	void *pMem;
; 3258 : 
; 3259 : 	pMem = malloc(SizeOfMemory);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _SizeOfMemory$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	89 45 f8	 mov	 DWORD PTR _pMem$[ebp], eax

; 3260 : 	
; 3261 : #ifdef DEBUG_ON
; 3262 : 	if (pMem == NULL) {
; 3263 : 		SendToLog("ERROR: failed the attempt to get dynamic free memory of %d bytes",SizeOfMemory);
; 3264 : 		
; 3265 : 	}
; 3266 : #endif
; 3267 : return pMem;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _pMem$[ebp]

; 3268 : 
; 3269 : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetMemory@@YAPAXK@Z ENDP				; GetMemory
_TEXT	ENDS
PUBLIC	?ResizeMemory@@YAPAXPAXK@Z			; ResizeMemory
EXTRN	__imp__realloc:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ResizeMemory@@YAPAXPAXK@Z
_TEXT	SEGMENT
_pOldMemory$ = 8					; size = 4
_NewSize$ = 12						; size = 4
?ResizeMemory@@YAPAXPAXK@Z PROC				; ResizeMemory, COMDAT

; 3275 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3276 : 	if (pOldMemory==NULL) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pOldMemory$[ebp], 0
  00022	75 0e		 jne	 SHORT $LN1@ResizeMemo

; 3277 : 		return GetMemory(NewSize);

  00024	8b 45 0c	 mov	 eax, DWORD PTR _NewSize$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  0002d	83 c4 04	 add	 esp, 4
  00030	eb 1a		 jmp	 SHORT $LN2@ResizeMemo
$LN1@ResizeMemo:

; 3278 : 	}
; 3279 : 
; 3280 : 	return realloc(pOldMemory, NewSize);

  00032	8b f4		 mov	 esi, esp
  00034	8b 45 0c	 mov	 eax, DWORD PTR _NewSize$[ebp]
  00037	50		 push	 eax
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _pOldMemory$[ebp]
  0003b	51		 push	 ecx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  00042	83 c4 08	 add	 esp, 8
  00045	3b f4		 cmp	 esi, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN2@ResizeMemo:

; 3281 : 
; 3282 : 
; 3283 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?ResizeMemory@@YAPAXPAXK@Z ENDP				; ResizeMemory
_TEXT	ENDS
PUBLIC	??_C@_0GN@CMHLICFP@WARNING?3?5in?5AddNGToken?$CI?$CJ?3?5Size?5o@ ; `string'
PUBLIC	?AddNGToken@@YAXGKKPAXPAPAGPAH@Z		; AddNGToken
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0GN@CMHLICFP@WARNING?3?5in?5AddNGToken?$CI?$CJ?3?5Size?5o@
CONST	SEGMENT
??_C@_0GN@CMHLICFP@WARNING?3?5in?5AddNGToken?$CI?$CJ?3?5Size?5o@ DB 'WARN'
	DB	'ING: in AddNGToken(): Size of structure for Tag=0x%X is not e'
	DB	'ven (%d). It has been added one extra byte.', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?AddNGToken@@YAXGKKPAXPAPAGPAH@Z
_TEXT	SEGMENT
_IndiceWords$ = -68					; size = 4
_pVetExtra$ = -56					; size = 4
_SizeMem$ = -44						; size = 4
_NumeroWords$ = -32					; size = 4
_TotBytes$ = -20					; size = 4
_TotRecord$ = -8					; size = 2
_NGTag$ = 8						; size = 2
_TotItem$ = 12						; size = 4
_SizeSingleItem$ = 16					; size = 4
_pData$ = 20						; size = 4
_p2VetExtra$ = 24					; size = 4
_pNWords$ = 28						; size = 4
?AddNGToken@@YAXGKKPAXPAPAGPAH@Z PROC			; AddNGToken, COMDAT

; 3299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-264]
  00012	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3300 : 	WORD TotRecord;
; 3301 : 	DWORD TotBytes;
; 3302 : 	DWORD NumeroWords;
; 3303 : 	DWORD SizeMem;
; 3304 : 	WORD *pVetExtra;
; 3305 : 	int IndiceWords;
; 3306 : 
; 3307 : 	pVetExtra = *p2VetExtra;

  0001e	8b 45 18	 mov	 eax, DWORD PTR _p2VetExtra$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d c8	 mov	 DWORD PTR _pVetExtra$[ebp], ecx

; 3308 : 
; 3309 : 
; 3310 : 	IndiceWords  = *pNWords;

  00026	8b 45 1c	 mov	 eax, DWORD PTR _pNWords$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d bc	 mov	 DWORD PTR _IndiceWords$[ebp], ecx

; 3311 : 	
; 3312 : 	SizeMem = IndiceWords * 2 + 100;

  0002e	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00031	8d 4c 00 64	 lea	 ecx, DWORD PTR [eax+eax+100]
  00035	89 4d d4	 mov	 DWORD PTR _SizeMem$[ebp], ecx

; 3313 : 
; 3314 : 	if (TotItem == NO_ARRAY) {

  00038	81 7d 0c 00 00
	01 00		 cmp	 DWORD PTR _TotItem$[ebp], 65536 ; 00010000H
  0003f	0f 85 3c 01 00
	00		 jne	 $LN16@AddNGToken

; 3315 : 		TotRecord=1;

  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	66 89 45 f8	 mov	 WORD PTR _TotRecord$[ebp], ax

; 3316 : 		TotBytes = SizeSingleItem;

  0004e	8b 45 10	 mov	 eax, DWORD PTR _SizeSingleItem$[ebp]
  00051	89 45 ec	 mov	 DWORD PTR _TotBytes$[ebp], eax

; 3317 : 		
; 3318 : 		NumeroWords = 2 + (TotBytes/2);

  00054	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00057	d1 e8		 shr	 eax, 1
  00059	83 c0 02	 add	 eax, 2
  0005c	89 45 e0	 mov	 DWORD PTR _NumeroWords$[ebp], eax

; 3319 : 
; 3320 : 		if (TotBytes & 1) {

  0005f	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00062	83 e0 01	 and	 eax, 1
  00065	74 25		 je	 SHORT $LN15@AddNGToken

; 3321 : 			// skip message if bytes amout is onlt = 1
; 3322 : 			if (TotBytes > 1) {

  00067	83 7d ec 01	 cmp	 DWORD PTR _TotBytes$[ebp], 1
  0006b	76 16		 jbe	 SHORT $LN14@AddNGToken

; 3323 : 				SendToLog("WARNING: in AddNGToken(): Size of structure for Tag=0x%X is not even (%d). It has been added one extra byte.",
; 3324 : 					NGTag, TotBytes);

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00070	50		 push	 eax
  00071	0f b7 4d 08	 movzx	 ecx, WORD PTR _NGTag$[ebp]
  00075	51		 push	 ecx
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0GN@CMHLICFP@WARNING?3?5in?5AddNGToken?$CI?$CJ?3?5Size?5o@
  0007b	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@AddNGToken:

; 3325 : 			}
; 3326 : 			// increase by 1 number of words to host the extra byte
; 3327 : 			NumeroWords++;

  00083	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 e0	 mov	 DWORD PTR _NumeroWords$[ebp], eax
$LN15@AddNGToken:

; 3328 : 	
; 3329 : 		}
; 3330 : 		if (NumeroWords > 0x7fff) {

  0008c	81 7d e0 ff 7f
	00 00		 cmp	 DWORD PTR _NumeroWords$[ebp], 32767 ; 00007fffH
  00093	76 09		 jbe	 SHORT $LN13@AddNGToken

; 3331 : 			// ci vorranno due words quindi aumentare di 1 le words
; 3332 : 			NumeroWords++;

  00095	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  00098	83 c0 01	 add	 eax, 1
  0009b	89 45 e0	 mov	 DWORD PTR _NumeroWords$[ebp], eax
$LN13@AddNGToken:

; 3333 : 		}
; 3334 : 
; 3335 : 		SizeMem += NumeroWords * 2;

  0009e	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  000a1	8b 4d d4	 mov	 ecx, DWORD PTR _SizeMem$[ebp]
  000a4	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000a7	89 55 d4	 mov	 DWORD PTR _SizeMem$[ebp], edx

; 3336 : 		if (IndiceWords) {

  000aa	83 7d bc 00	 cmp	 DWORD PTR _IndiceWords$[ebp], 0
  000ae	74 15		 je	 SHORT $LN12@AddNGToken

; 3337 : 			pVetExtra = (WORD *) ResizeMemory(pVetExtra, SizeMem);

  000b0	8b 45 d4	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 ?ResizeMemory@@YAPAXPAXK@Z ; ResizeMemory
  000bd	83 c4 08	 add	 esp, 8
  000c0	89 45 c8	 mov	 DWORD PTR _pVetExtra$[ebp], eax

; 3338 : 		}else {

  000c3	eb 0f		 jmp	 SHORT $LN11@AddNGToken
$LN12@AddNGToken:

; 3339 : 			// e' azzerato, allocare adesso
; 3340 : 			pVetExtra = (WORD *) GetMemory(SizeMem);

  000c5	8b 45 d4	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  000ce	83 c4 04	 add	 esp, 4
  000d1	89 45 c8	 mov	 DWORD PTR _pVetExtra$[ebp], eax
$LN11@AddNGToken:

; 3341 : 		}
; 3342 : 
; 3343 : 		if (NumeroWords > 0x7fff) {

  000d4	81 7d e0 ff 7f
	00 00		 cmp	 DWORD PTR _NumeroWords$[ebp], 32767 ; 00007fffH
  000db	76 3b		 jbe	 SHORT $LN10@AddNGToken

; 3344 : 			// e' una dword
; 3345 : 			pVetExtra[IndiceWords++] = (WORD) ((NumeroWords >> 16) | 0x8000);

  000dd	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  000e0	c1 e8 10	 shr	 eax, 16			; 00000010H
  000e3	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  000e8	8b 4d bc	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  000eb	8b 55 c8	 mov	 edx, DWORD PTR _pVetExtra$[ebp]
  000ee	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  000f2	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  000f5	83 c0 01	 add	 eax, 1
  000f8	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3346 : 			pVetExtra[IndiceWords++] = (WORD) (NumeroWords & 0xffff);

  000fb	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  000fe	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00103	8b 4d bc	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  00106	8b 55 c8	 mov	 edx, DWORD PTR _pVetExtra$[ebp]
  00109	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0010d	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00110	83 c0 01	 add	 eax, 1
  00113	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3347 : 
; 3348 : 		}else {

  00116	eb 17		 jmp	 SHORT $LN9@AddNGToken
$LN10@AddNGToken:

; 3349 : 			pVetExtra[IndiceWords++] = (WORD) NumeroWords;

  00118	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  0011b	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  0011e	66 8b 55 e0	 mov	 dx, WORD PTR _NumeroWords$[ebp]
  00122	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00126	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00129	83 c0 01	 add	 eax, 1
  0012c	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax
$LN9@AddNGToken:

; 3350 : 		}	
; 3351 : 
; 3352 : 		pVetExtra[IndiceWords++] = NGTag;

  0012f	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00132	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  00135	66 8b 55 08	 mov	 dx, WORD PTR _NGTag$[ebp]
  00139	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0013d	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00140	83 c0 01	 add	 eax, 1
  00143	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3353 : 
; 3354 : 		memcpy(&pVetExtra[IndiceWords], pData, TotBytes);

  00146	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00149	50		 push	 eax
  0014a	8b 4d 14	 mov	 ecx, DWORD PTR _pData$[ebp]
  0014d	51		 push	 ecx
  0014e	8b 55 bc	 mov	 edx, DWORD PTR _IndiceWords$[ebp]
  00151	8b 45 c8	 mov	 eax, DWORD PTR _pVetExtra$[ebp]
  00154	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00157	51		 push	 ecx
  00158	e8 00 00 00 00	 call	 _memcpy
  0015d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3355 : 
; 3356 : 		IndiceWords += (TotBytes / 2);

  00160	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00163	d1 e8		 shr	 eax, 1
  00165	03 45 bc	 add	 eax, DWORD PTR _IndiceWords$[ebp]
  00168	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3357 : 
; 3358 : 		if (TotBytes & 0x001) IndiceWords++;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  0016e	83 e0 01	 and	 eax, 1
  00171	74 09		 je	 SHORT $LN8@AddNGToken
  00173	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00176	83 c0 01	 add	 eax, 1
  00179	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax
$LN8@AddNGToken:

; 3359 : 
; 3360 : 
; 3361 : 	}else {

  0017c	e9 25 01 00 00	 jmp	 $LN7@AddNGToken
$LN16@AddNGToken:

; 3362 : 
; 3363 : 		TotRecord = (WORD) TotItem;

  00181	66 8b 45 0c	 mov	 ax, WORD PTR _TotItem$[ebp]
  00185	66 89 45 f8	 mov	 WORD PTR _TotRecord$[ebp], ax

; 3364 : 		TotBytes = SizeSingleItem * TotRecord;

  00189	0f b7 45 f8	 movzx	 eax, WORD PTR _TotRecord$[ebp]
  0018d	0f af 45 10	 imul	 eax, DWORD PTR _SizeSingleItem$[ebp]
  00191	89 45 ec	 mov	 DWORD PTR _TotBytes$[ebp], eax

; 3365 : 
; 3366 : 		if (TotBytes & 1) TotBytes++;

  00194	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00197	83 e0 01	 and	 eax, 1
  0019a	74 09		 je	 SHORT $LN6@AddNGToken
  0019c	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  0019f	83 c0 01	 add	 eax, 1
  001a2	89 45 ec	 mov	 DWORD PTR _TotBytes$[ebp], eax
$LN6@AddNGToken:

; 3367 : 
; 3368 : 		NumeroWords = 3 + (TotBytes /2);

  001a5	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  001a8	d1 e8		 shr	 eax, 1
  001aa	83 c0 03	 add	 eax, 3
  001ad	89 45 e0	 mov	 DWORD PTR _NumeroWords$[ebp], eax

; 3369 : 
; 3370 : 		if (NumeroWords > 0x7fff) {

  001b0	81 7d e0 ff 7f
	00 00		 cmp	 DWORD PTR _NumeroWords$[ebp], 32767 ; 00007fffH
  001b7	76 09		 jbe	 SHORT $LN5@AddNGToken

; 3371 : 			NumeroWords++;

  001b9	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  001bc	83 c0 01	 add	 eax, 1
  001bf	89 45 e0	 mov	 DWORD PTR _NumeroWords$[ebp], eax
$LN5@AddNGToken:

; 3372 : 		}
; 3373 : 
; 3374 : 		SizeMem += NumeroWords * 2;

  001c2	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  001c5	8b 4d d4	 mov	 ecx, DWORD PTR _SizeMem$[ebp]
  001c8	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  001cb	89 55 d4	 mov	 DWORD PTR _SizeMem$[ebp], edx

; 3375 : 
; 3376 : 		if (IndiceWords) {

  001ce	83 7d bc 00	 cmp	 DWORD PTR _IndiceWords$[ebp], 0
  001d2	74 15		 je	 SHORT $LN4@AddNGToken

; 3377 : 			pVetExtra = (WORD *) ResizeMemory(pVetExtra, SizeMem);

  001d4	8b 45 d4	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  001d7	50		 push	 eax
  001d8	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  001db	51		 push	 ecx
  001dc	e8 00 00 00 00	 call	 ?ResizeMemory@@YAPAXPAXK@Z ; ResizeMemory
  001e1	83 c4 08	 add	 esp, 8
  001e4	89 45 c8	 mov	 DWORD PTR _pVetExtra$[ebp], eax

; 3378 : 		}else {

  001e7	eb 0f		 jmp	 SHORT $LN3@AddNGToken
$LN4@AddNGToken:

; 3379 : 			// e' azzerato, allocare adesso
; 3380 : 			pVetExtra = (WORD *) GetMemory(SizeMem);

  001e9	8b 45 d4	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  001ec	50		 push	 eax
  001ed	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  001f2	83 c4 04	 add	 esp, 4
  001f5	89 45 c8	 mov	 DWORD PTR _pVetExtra$[ebp], eax
$LN3@AddNGToken:

; 3381 : 		}
; 3382 : 		if (NumeroWords > 0x7fff) {

  001f8	81 7d e0 ff 7f
	00 00		 cmp	 DWORD PTR _NumeroWords$[ebp], 32767 ; 00007fffH
  001ff	76 3b		 jbe	 SHORT $LN2@AddNGToken

; 3383 : 			pVetExtra[IndiceWords++] = (WORD) ((NumeroWords >> 16) | 0x8000);

  00201	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  00204	c1 e8 10	 shr	 eax, 16			; 00000010H
  00207	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  0020c	8b 4d bc	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  0020f	8b 55 c8	 mov	 edx, DWORD PTR _pVetExtra$[ebp]
  00212	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00216	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00219	83 c0 01	 add	 eax, 1
  0021c	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3384 : 			pVetExtra[IndiceWords++] = (WORD) (NumeroWords & 0xffff);

  0021f	8b 45 e0	 mov	 eax, DWORD PTR _NumeroWords$[ebp]
  00222	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00227	8b 4d bc	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  0022a	8b 55 c8	 mov	 edx, DWORD PTR _pVetExtra$[ebp]
  0022d	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00231	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00234	83 c0 01	 add	 eax, 1
  00237	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3385 : 		}else {

  0023a	eb 17		 jmp	 SHORT $LN1@AddNGToken
$LN2@AddNGToken:

; 3386 : 			pVetExtra[IndiceWords++] = (WORD) NumeroWords;

  0023c	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  0023f	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  00242	66 8b 55 e0	 mov	 dx, WORD PTR _NumeroWords$[ebp]
  00246	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0024a	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  0024d	83 c0 01	 add	 eax, 1
  00250	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax
$LN1@AddNGToken:

; 3387 : 		}
; 3388 : 
; 3389 : 		pVetExtra[IndiceWords++] = NGTag;

  00253	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00256	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  00259	66 8b 55 08	 mov	 dx, WORD PTR _NGTag$[ebp]
  0025d	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00261	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00264	83 c0 01	 add	 eax, 1
  00267	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3390 : 		pVetExtra[IndiceWords++] = TotRecord;

  0026a	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  0026d	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  00270	66 8b 55 f8	 mov	 dx, WORD PTR _TotRecord$[ebp]
  00274	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00278	8b 45 bc	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  0027b	83 c0 01	 add	 eax, 1
  0027e	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3391 : 
; 3392 : 		memcpy(&pVetExtra[IndiceWords], pData, TotBytes);

  00281	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  00284	50		 push	 eax
  00285	8b 4d 14	 mov	 ecx, DWORD PTR _pData$[ebp]
  00288	51		 push	 ecx
  00289	8b 55 bc	 mov	 edx, DWORD PTR _IndiceWords$[ebp]
  0028c	8b 45 c8	 mov	 eax, DWORD PTR _pVetExtra$[ebp]
  0028f	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00292	51		 push	 ecx
  00293	e8 00 00 00 00	 call	 _memcpy
  00298	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3393 : 
; 3394 : 		IndiceWords += (TotBytes / 2);

  0029b	8b 45 ec	 mov	 eax, DWORD PTR _TotBytes$[ebp]
  0029e	d1 e8		 shr	 eax, 1
  002a0	03 45 bc	 add	 eax, DWORD PTR _IndiceWords$[ebp]
  002a3	89 45 bc	 mov	 DWORD PTR _IndiceWords$[ebp], eax
$LN7@AddNGToken:

; 3395 : 	}
; 3396 : 
; 3397 : 
; 3398 : 
; 3399 : 	*pNWords = IndiceWords;

  002a6	8b 45 1c	 mov	 eax, DWORD PTR _pNWords$[ebp]
  002a9	8b 4d bc	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  002ac	89 08		 mov	 DWORD PTR [eax], ecx

; 3400 : 	*p2VetExtra = pVetExtra;

  002ae	8b 45 18	 mov	 eax, DWORD PTR _p2VetExtra$[ebp]
  002b1	8b 4d c8	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  002b4	89 08		 mov	 DWORD PTR [eax], ecx

; 3401 : }

  002b6	5f		 pop	 edi
  002b7	5e		 pop	 esi
  002b8	5b		 pop	 ebx
  002b9	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  002bf	3b ec		 cmp	 ebp, esp
  002c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c6	8b e5		 mov	 esp, ebp
  002c8	5d		 pop	 ebp
  002c9	c3		 ret	 0
?AddNGToken@@YAXGKKPAXPAPAGPAH@Z ENDP			; AddNGToken
_TEXT	ENDS
PUBLIC	?AddTokenFinalSequence@@YAXPAPAGPAH@Z		; AddTokenFinalSequence
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AddTokenFinalSequence@@YAXPAPAGPAH@Z
_TEXT	SEGMENT
_IndiceWords$ = -32					; size = 4
_pVetExtra$ = -20					; size = 4
_SizeMem$ = -8						; size = 4
_p2VetExtra$ = 8					; size = 4
_pNWords$ = 12						; size = 4
?AddTokenFinalSequence@@YAXPAPAGPAH@Z PROC		; AddTokenFinalSequence, COMDAT

; 3404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3405 : 
; 3406 : 	DWORD SizeMem;
; 3407 : 	WORD *pVetExtra;
; 3408 : 	int IndiceWords;
; 3409 : 
; 3410 : 	pVetExtra = *p2VetExtra;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _p2VetExtra$[ebp]
  00021	8b 08		 mov	 ecx, DWORD PTR [eax]
  00023	89 4d ec	 mov	 DWORD PTR _pVetExtra$[ebp], ecx

; 3411 : 	IndiceWords  = *pNWords;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _pNWords$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d e0	 mov	 DWORD PTR _IndiceWords$[ebp], ecx

; 3412 : 
; 3413 : 	SizeMem = (IndiceWords+2) * 2;

  0002e	8b 45 e0	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00031	8d 4c 00 04	 lea	 ecx, DWORD PTR [eax+eax+4]
  00035	89 4d f8	 mov	 DWORD PTR _SizeMem$[ebp], ecx

; 3414 : 
; 3415 : 	if (IndiceWords) {

  00038	83 7d e0 00	 cmp	 DWORD PTR _IndiceWords$[ebp], 0
  0003c	74 15		 je	 SHORT $LN2@AddTokenFi

; 3416 : 		pVetExtra = (WORD *) ResizeMemory(pVetExtra, SizeMem);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  00041	50		 push	 eax
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?ResizeMemory@@YAPAXPAXK@Z ; ResizeMemory
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 ec	 mov	 DWORD PTR _pVetExtra$[ebp], eax

; 3417 : 	}else {

  00051	eb 0f		 jmp	 SHORT $LN1@AddTokenFi
$LN2@AddTokenFi:

; 3418 : 		// e' azzerato, allocare adesso
; 3419 : 		pVetExtra = (WORD *) GetMemory(SizeMem);

  00053	8b 45 f8	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 45 ec	 mov	 DWORD PTR _pVetExtra$[ebp], eax
$LN1@AddTokenFi:

; 3420 : 	}	
; 3421 : 
; 3422 : 	pVetExtra[IndiceWords++]= NGTAG_END_SEQUENCE;

  00062	33 c0		 xor	 eax, eax
  00064	8b 4d e0	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  00067	8b 55 ec	 mov	 edx, DWORD PTR _pVetExtra$[ebp]
  0006a	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  0006e	8b 45 e0	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00071	83 c0 01	 add	 eax, 1
  00074	89 45 e0	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3423 : 	pVetExtra[IndiceWords++]= NGTAG_END_SEQUENCE;

  00077	33 c0		 xor	 eax, eax
  00079	8b 4d e0	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  0007c	8b 55 ec	 mov	 edx, DWORD PTR _pVetExtra$[ebp]
  0007f	66 89 04 4a	 mov	 WORD PTR [edx+ecx*2], ax
  00083	8b 45 e0	 mov	 eax, DWORD PTR _IndiceWords$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 e0	 mov	 DWORD PTR _IndiceWords$[ebp], eax

; 3424 : 	
; 3425 : 	*p2VetExtra= pVetExtra;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _p2VetExtra$[ebp]
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR _pVetExtra$[ebp]
  00092	89 08		 mov	 DWORD PTR [eax], ecx

; 3426 : 	*pNWords= IndiceWords;

  00094	8b 45 0c	 mov	 eax, DWORD PTR _pNWords$[ebp]
  00097	8b 4d e0	 mov	 ecx, DWORD PTR _IndiceWords$[ebp]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx

; 3427 : 	
; 3428 : }

  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a5	3b ec		 cmp	 ebp, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c3		 ret	 0
?AddTokenFinalSequence@@YAXPAPAGPAH@Z ENDP		; AddTokenFinalSequence
_TEXT	ENDS
PUBLIC	?ParseNgField@@YA_NPAGKPAUStrParseNGField@@@Z	; ParseNgField
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ParseNgField@@YA_NPAGKPAUStrParseNGField@@@Z
_TEXT	SEGMENT
_ExtraWords$ = -44					; size = 4
_i$ = -32						; size = 4
_NumberOfWords$ = -20					; size = 4
_Word1$ = -8						; size = 4
_pNgArray$ = 8						; size = 4
_CurrentIndex$ = 12					; size = 4
_pParseNGField$ = 16					; size = 4
?ParseNgField@@YA_NPAGKPAUStrParseNGField@@@Z PROC	; ParseNgField, COMDAT

; 3449 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3450 : 	DWORD Word1, NumberOfWords;
; 3451 : 	int i;
; 3452 : 	DWORD ExtraWords;
; 3453 : 
; 3454 : 
; 3455 : 	i = CurrentIndex;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _CurrentIndex$[ebp]
  00021	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax

; 3456 : 
; 3457 : 
; 3458 : 	if (pNgArray[i] & 0x8000) {

  00024	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pNgArray$[ebp]
  0002a	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0002e	81 e2 00 80 00
	00		 and	 edx, 32768		; 00008000H
  00034	74 43		 je	 SHORT $LN3@ParseNgFie

; 3459 : 		// size e' DWORD
; 3460 : 		Word1 = pNgArray[i++] & 0x7fff;

  00036	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00039	8b 4d 08	 mov	 ecx, DWORD PTR _pNgArray$[ebp]
  0003c	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00040	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00046	89 55 f8	 mov	 DWORD PTR _Word1$[ebp], edx
  00049	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax

; 3461 : 		NumberOfWords = Word1 * 65536 + pNgArray[i++];

  00052	8b 45 f8	 mov	 eax, DWORD PTR _Word1$[ebp]
  00055	c1 e0 10	 shl	 eax, 16			; 00000010H
  00058	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  0005b	8b 55 08	 mov	 edx, DWORD PTR _pNgArray$[ebp]
  0005e	0f b7 0c 4a	 movzx	 ecx, WORD PTR [edx+ecx*2]
  00062	03 c1		 add	 eax, ecx
  00064	89 45 ec	 mov	 DWORD PTR _NumberOfWords$[ebp], eax
  00067	8b 55 e0	 mov	 edx, DWORD PTR _i$[ebp]
  0006a	83 c2 01	 add	 edx, 1
  0006d	89 55 e0	 mov	 DWORD PTR _i$[ebp], edx

; 3462 : 		ExtraWords = 3;

  00070	c7 45 d4 03 00
	00 00		 mov	 DWORD PTR _ExtraWords$[ebp], 3

; 3463 : 	}else {

  00077	eb 1d		 jmp	 SHORT $LN2@ParseNgFie
$LN3@ParseNgFie:

; 3464 : 		// size e' WORD
; 3465 : 		NumberOfWords = pNgArray[i++];

  00079	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  0007c	8b 4d 08	 mov	 ecx, DWORD PTR _pNgArray$[ebp]
  0007f	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00083	89 55 ec	 mov	 DWORD PTR _NumberOfWords$[ebp], edx
  00086	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  00089	83 c0 01	 add	 eax, 1
  0008c	89 45 e0	 mov	 DWORD PTR _i$[ebp], eax

; 3466 : 		ExtraWords = 2;

  0008f	c7 45 d4 02 00
	00 00		 mov	 DWORD PTR _ExtraWords$[ebp], 2
$LN2@ParseNgFie:

; 3467 : 	}
; 3468 : 	
; 3469 : 	if (NumberOfWords == NGTAG_END_SEQUENCE) return false;

  00096	83 7d ec 00	 cmp	 DWORD PTR _NumberOfWords$[ebp], 0
  0009a	75 04		 jne	 SHORT $LN1@ParseNgFie
  0009c	32 c0		 xor	 al, al
  0009e	eb 4d		 jmp	 SHORT $LN4@ParseNgFie
$LN1@ParseNgFie:

; 3470 : 
; 3471 : 	pParseNGField->NextIndex = CurrentIndex + NumberOfWords;

  000a0	8b 45 0c	 mov	 eax, DWORD PTR _CurrentIndex$[ebp]
  000a3	03 45 ec	 add	 eax, DWORD PTR _NumberOfWords$[ebp]
  000a6	8b 4d 10	 mov	 ecx, DWORD PTR _pParseNGField$[ebp]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax

; 3472 : 	pParseNGField->Type = pNgArray[i++];

  000ab	8b 45 10	 mov	 eax, DWORD PTR _pParseNGField$[ebp]
  000ae	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  000b1	8b 55 08	 mov	 edx, DWORD PTR _pNgArray$[ebp]
  000b4	66 8b 0c 4a	 mov	 cx, WORD PTR [edx+ecx*2]
  000b8	66 89 48 10	 mov	 WORD PTR [eax+16], cx
  000bc	8b 55 e0	 mov	 edx, DWORD PTR _i$[ebp]
  000bf	83 c2 01	 add	 edx, 1
  000c2	89 55 e0	 mov	 DWORD PTR _i$[ebp], edx

; 3473 : 	pParseNGField->pData = &pNgArray[i];

  000c5	8b 45 e0	 mov	 eax, DWORD PTR _i$[ebp]
  000c8	8b 4d 08	 mov	 ecx, DWORD PTR _pNgArray$[ebp]
  000cb	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  000ce	8b 45 10	 mov	 eax, DWORD PTR _pParseNGField$[ebp]
  000d1	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 3474 : 	pParseNGField->StartDataIndex = i;

  000d4	8b 45 10	 mov	 eax, DWORD PTR _pParseNGField$[ebp]
  000d7	8b 4d e0	 mov	 ecx, DWORD PTR _i$[ebp]
  000da	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 3475 : 	pParseNGField->SizeData = (NumberOfWords-ExtraWords) * 2;

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _NumberOfWords$[ebp]
  000e0	2b 45 d4	 sub	 eax, DWORD PTR _ExtraWords$[ebp]
  000e3	d1 e0		 shl	 eax, 1
  000e5	8b 4d 10	 mov	 ecx, DWORD PTR _pParseNGField$[ebp]
  000e8	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3476 : 	
; 3477 : 	return true;

  000eb	b0 01		 mov	 al, 1
$LN4@ParseNgFie:

; 3478 : }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
?ParseNgField@@YA_NPAGKPAUStrParseNGField@@@Z ENDP	; ParseNgField
_TEXT	ENDS
PUBLIC	?GetString@@YAPADH@Z				; GetString
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetString@@YAPADH@Z
_TEXT	SEGMENT
_pStringheScriptDat$ = -56				; size = 4
_pIndiceStringheDat$ = -44				; size = 4
_Indice$ = -32						; size = 2
_i$ = -20						; size = 4
_pChar$ = -8						; size = 4
_StringIndex$ = 8					; size = 4
?GetString@@YAPADH@Z PROC				; GetString, COMDAT

; 3487 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3488 : 	char *pChar;
; 3489 : 	int i;
; 3490 : 	WORD Indice;
; 3491 : 	static WORD ** p2IndiciStringheDat = (WORD **) 0x7FD154;
; 3492 : 	WORD *pIndiceStringheDat;
; 3493 : 	static char **p2StringheScriptDat = (char**) 0x7FD198;
; 3494 : 	char *pStringheScriptDat;
; 3495 : 	static char MexNotFound[]= "STRING NOT FOUND";
; 3496 : 
; 3497 : 	pIndiceStringheDat = *p2IndiciStringheDat;

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?p2IndiciStringheDat@?1??GetString@@YAPADH@Z@4PAPAGA
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 4d d4	 mov	 DWORD PTR _pIndiceStringheDat$[ebp], ecx

; 3498 : 	pStringheScriptDat = *p2StringheScriptDat;

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?p2StringheScriptDat@?1??GetString@@YAPADH@Z@4PAPADA
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	89 4d c8	 mov	 DWORD PTR _pStringheScriptDat$[ebp], ecx

; 3499 : 
; 3500 : 	if (StringIndex & STRING_NG) {

  00032	8b 45 08	 mov	 eax, DWORD PTR _StringIndex$[ebp]
  00035	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  0003a	74 6e		 je	 SHORT $LN5@GetString

; 3501 : 		// extra NG string
; 3502 : 		Indice= StringIndex & MASK_STRING_INDEX;

  0003c	8b 45 08	 mov	 eax, DWORD PTR _StringIndex$[ebp]
  0003f	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH
  00044	66 89 45 e0	 mov	 WORD PTR _Indice$[ebp], ax

; 3503 : 
; 3504 : 		for (i=0;i<Trng.pGlobTomb4->TotExtraStrings;i++) {

  00048	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0004f	eb 09		 jmp	 SHORT $LN4@GetString
$LN3@GetString:
  00051	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00054	83 c0 01	 add	 eax, 1
  00057	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@GetString:
  0005a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  00062	3b 88 08 08 1b
	00		 cmp	 ecx, DWORD PTR [eax+1771528]
  00068	7d 39		 jge	 SHORT $LN2@GetString

; 3505 : 			if (Trng.pGlobTomb4->VetExtraStrings[i].Indice == Indice) {

  0006a	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0006d	6b c0 06	 imul	 eax, 6
  00070	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00076	0f b7 94 01 0c
	08 1b 00	 movzx	 edx, WORD PTR [ecx+eax+1771532]
  0007e	0f b7 45 e0	 movzx	 eax, WORD PTR _Indice$[ebp]
  00082	3b d0		 cmp	 edx, eax
  00084	75 1b		 jne	 SHORT $LN1@GetString

; 3506 : 				pChar = Trng.pGlobTomb4->VetExtraStrings[i].pTesto;

  00086	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00089	6b c0 06	 imul	 eax, 6
  0008c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00092	8b 94 01 0e 08
	1b 00		 mov	 edx, DWORD PTR [ecx+eax+1771534]
  00099	89 55 f8	 mov	 DWORD PTR _pChar$[ebp], edx

; 3507 : 
; 3508 : 				return pChar;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _pChar$[ebp]
  0009f	eb 24		 jmp	 SHORT $LN6@GetString
$LN1@GetString:

; 3509 : 			}
; 3510 : 		}

  000a1	eb ae		 jmp	 SHORT $LN3@GetString
$LN2@GetString:

; 3511 : 		// not found. if we are in debug version lets a mexage in tomb4_log
; 3512 : #ifdef DEBUG_ON
; 3513 : 		SendToLog("ERROR: cann't locate extra ng string with index = %d", StringIndex & MASK_STRING_INDEX);
; 3514 : #endif
; 3515 : 		return MexNotFound;

  000a3	b8 00 00 00 00	 mov	 eax, OFFSET ?MexNotFound@?1??GetString@@YAPADH@Z@4PADA
  000a8	eb 1b		 jmp	 SHORT $LN6@GetString
$LN5@GetString:

; 3516 : 
; 3517 : 	}
; 3518 : 	// string is not of extra ng kind
; 3519 : 	Indice = pIndiceStringheDat[StringIndex];

  000aa	8b 45 08	 mov	 eax, DWORD PTR _StringIndex$[ebp]
  000ad	8b 4d d4	 mov	 ecx, DWORD PTR _pIndiceStringheDat$[ebp]
  000b0	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000b4	66 89 55 e0	 mov	 WORD PTR _Indice$[ebp], dx

; 3520 : 	pChar = &pStringheScriptDat[Indice];

  000b8	0f b7 45 e0	 movzx	 eax, WORD PTR _Indice$[ebp]
  000bc	03 45 c8	 add	 eax, DWORD PTR _pStringheScriptDat$[ebp]
  000bf	89 45 f8	 mov	 DWORD PTR _pChar$[ebp], eax

; 3521 : 	return pChar;

  000c2	8b 45 f8	 mov	 eax, DWORD PTR _pChar$[ebp]
$LN6@GetString:

; 3522 : 
; 3523 : }

  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c3		 ret	 0
?GetString@@YAPADH@Z ENDP				; GetString
_TEXT	ENDS
PUBLIC	??_C@_0DP@MGGJAMLA@ERROR?3?5the?5tomb4?5index?5?$CFd?5doesn?8@ ; `string'
PUBLIC	?FromTomb4IndexToNgleIndex@@YAHH@Z		; FromTomb4IndexToNgleIndex
;	COMDAT ??_C@_0DP@MGGJAMLA@ERROR?3?5the?5tomb4?5index?5?$CFd?5doesn?8@
CONST	SEGMENT
??_C@_0DP@MGGJAMLA@ERROR?3?5the?5tomb4?5index?5?$CFd?5doesn?8@ DB 'ERROR:'
	DB	' the tomb4 index %d doesn''t correspond to any ngle index', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?FromTomb4IndexToNgleIndex@@YAHH@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_TombIndex$ = 8						; size = 4
?FromTomb4IndexToNgleIndex@@YAHH@Z PROC			; FromTomb4IndexToNgleIndex, COMDAT

; 3534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3535 : 	int i;
; 3536 : 
; 3537 : 	i=Trng.pGlobTomb4->VetRemapInverseObjects[TombIndex];

  0001e	8b 45 08	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  00021	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00027	0f bf 94 41 54
	5b 1a 00	 movsx	 edx, WORD PTR [ecx+eax*2+1727316]
  0002f	89 55 f8	 mov	 DWORD PTR _i$[ebp], edx

; 3538 : 
; 3539 : 	if (i == -1) {

  00032	83 7d f8 ff	 cmp	 DWORD PTR _i$[ebp], -1
  00036	75 11		 jne	 SHORT $LN1@FromTomb4I

; 3540 : 
; 3541 : 		// not found
; 3542 : 		SendToLog("ERROR: the tomb4 index %d doesn't correspond to any ngle index", TombIndex);

  00038	8b 45 08	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0DP@MGGJAMLA@ERROR?3?5the?5tomb4?5index?5?$CFd?5doesn?8@
  00041	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00046	83 c4 08	 add	 esp, 8
$LN1@FromTomb4I:

; 3543 : 	}
; 3544 : 	return i;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]

; 3545 : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5b		 pop	 ebx
  0004f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?FromTomb4IndexToNgleIndex@@YAHH@Z ENDP			; FromTomb4IndexToNgleIndex
_TEXT	ENDS
PUBLIC	?FileLenght@@YAJPAU_iobuf@@@Z			; FileLenght
EXTRN	__imp__ftell:PROC
EXTRN	__imp__fseek:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FileLenght@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_tempdim$ = -8						; size = 4
_tempfile$ = 8						; size = 4
?FileLenght@@YAJPAU_iobuf@@@Z PROC			; FileLenght, COMDAT

; 3549 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3550 : 	long  tempdim;
; 3551 : 
; 3552 : 	
; 3553 : 
; 3554 : 	fseek(tempfile,0,SEEK_END);

  0001e	8b f4		 mov	 esi, esp
  00020	6a 02		 push	 2
  00022	6a 00		 push	 0
  00024	8b 45 08	 mov	 eax, DWORD PTR _tempfile$[ebp]
  00027	50		 push	 eax
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3555 : 	tempdim=ftell(tempfile);

  00038	8b f4		 mov	 esi, esp
  0003a	8b 45 08	 mov	 eax, DWORD PTR _tempfile$[ebp]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00044	83 c4 04	 add	 esp, 4
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	89 45 f8	 mov	 DWORD PTR _tempdim$[ebp], eax

; 3556 : 	fseek(tempfile,0,SEEK_SET);

  00051	8b f4		 mov	 esi, esp
  00053	6a 00		 push	 0
  00055	6a 00		 push	 0
  00057	8b 45 08	 mov	 eax, DWORD PTR _tempfile$[ebp]
  0005a	50		 push	 eax
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	3b f4		 cmp	 esi, esp
  00066	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3557 : 
; 3558 : 
; 3559 : 
; 3560 : 	return tempdim;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _tempdim$[ebp]

; 3561 : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?FileLenght@@YAJPAU_iobuf@@@Z ENDP			; FileLenght
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?IsThereFile@@YA_NPAD@Z				; IsThereFile
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?IsThereFile@@YA_NPAD@Z
_TEXT	SEGMENT
_stbuffer$ = -56					; size = 48
__$ArrayPad$ = -4					; size = 4
_pFileName$ = 8						; size = 4
?IsThereFile@@YA_NPAD@Z PROC				; IsThereFile, COMDAT

; 3569 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 04 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-252]
  00012	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 3570 : 	struct stat stbuffer;
; 3571 : 
; 3572 : 
; 3573 : 	if (pFileName[0] == 0) return false;

  00028	8b 45 08	 mov	 eax, DWORD PTR _pFileName$[ebp]
  0002b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0002e	85 c9		 test	 ecx, ecx
  00030	75 04		 jne	 SHORT $LN2@IsThereFil
  00032	32 c0		 xor	 al, al
  00034	eb 1a		 jmp	 SHORT $LN3@IsThereFil
$LN2@IsThereFil:

; 3574 : 
; 3575 : 	if (stat(pFileName,&stbuffer) != 0) return false;

  00036	8d 45 c8	 lea	 eax, DWORD PTR _stbuffer$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _pFileName$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 _stat
  00043	83 c4 08	 add	 esp, 8
  00046	85 c0		 test	 eax, eax
  00048	74 04		 je	 SHORT $LN1@IsThereFil
  0004a	32 c0		 xor	 al, al
  0004c	eb 02		 jmp	 SHORT $LN3@IsThereFil
$LN1@IsThereFil:

; 3576 : 	return true;

  0004e	b0 01		 mov	 al, 1
$LN3@IsThereFil:

; 3577 : }

  00050	52		 push	 edx
  00051	8b cd		 mov	 ecx, ebp
  00053	50		 push	 eax
  00054	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@IsThereFil
  0005a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0005f	58		 pop	 eax
  00060	5a		 pop	 edx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00067	33 cd		 xor	 ecx, ebp
  00069	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006e	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
  0007f	90		 npad	 1
$LN7@IsThereFil:
  00080	01 00 00 00	 DD	 1
  00084	00 00 00 00	 DD	 $LN6@IsThereFil
$LN6@IsThereFil:
  00088	c8 ff ff ff	 DD	 -56			; ffffffc8H
  0008c	30 00 00 00	 DD	 48			; 00000030H
  00090	00 00 00 00	 DD	 $LN5@IsThereFil
$LN5@IsThereFil:
  00094	73		 DB	 115			; 00000073H
  00095	74		 DB	 116			; 00000074H
  00096	62		 DB	 98			; 00000062H
  00097	75		 DB	 117			; 00000075H
  00098	66		 DB	 102			; 00000066H
  00099	66		 DB	 102			; 00000066H
  0009a	65		 DB	 101			; 00000065H
  0009b	72		 DB	 114			; 00000072H
  0009c	00		 DB	 0
?IsThereFile@@YA_NPAD@Z ENDP				; IsThereFile
_TEXT	ENDS
EXTRN	__imp___stat64i32:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
;	COMDAT _stat
_TEXT	SEGMENT
__Filename$ = 8						; size = 4
__Stat$ = 12						; size = 4
_stat	PROC						; COMDAT

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 58   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 59   :     return _stat64i32(_Filename,(struct _stat64i32 *)_Stat);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 0c	 mov	 eax, DWORD PTR __Stat$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Filename$[ebp]
  00027	51		 push	 ecx
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stat64i32
  0002e	83 c4 08	 add	 esp, 8
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 60   : }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_stat	ENDP
_TEXT	ENDS
PUBLIC	?FreeMemory@@YAXPAX@Z				; FreeMemory
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\trng.cpp
;	COMDAT ?FreeMemory@@YAXPAX@Z
_TEXT	SEGMENT
_pMem$ = 8						; size = 4
?FreeMemory@@YAXPAX@Z PROC				; FreeMemory, COMDAT

; 3583 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3584 : 
; 3585 : 
; 3586 : 	free(pMem);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _pMem$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3587 : 
; 3588 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?FreeMemory@@YAXPAX@Z ENDP				; FreeMemory
_TEXT	ENDS
PUBLIC	?GetCallBack@@YA_NHHGPAX@Z			; GetCallBack
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetCallBack@@YA_NHHGPAX@Z
_TEXT	SEGMENT
_CallBackCB$ = 8					; size = 4
_CBT_Flags$ = 12					; size = 4
_Index$ = 16						; size = 2
_pProc$ = 20						; size = 4
?GetCallBack@@YA_NHHGPAX@Z PROC				; GetCallBack, COMDAT

; 3593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3594 : 
; 3595 : 	return Trng.RequireCallBack(Trng.IdMyPlugin, CallBackCB, CBT_Flags, Index, pProc);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR _pProc$[ebp]
  00023	50		 push	 eax
  00024	0f b7 4d 10	 movzx	 ecx, WORD PTR _Index$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 0c	 mov	 edx, DWORD PTR _CBT_Flags$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 08	 mov	 eax, DWORD PTR _CallBackCB$[ebp]
  00030	50		 push	 eax
  00031	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00038	51		 push	 ecx
  00039	ff 15 08 00 00
	00		 call	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+8
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3596 : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?GetCallBack@@YA_NHHGPAX@Z ENDP				; GetCallBack
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?LoadFile@@YAPAEPADPAK@Z			; LoadFile
EXTRN	__imp__fread:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?LoadFile@@YAPAEPADPAK@Z
_TEXT	SEGMENT
_pMem$ = -32						; size = 4
_pFile$ = -20						; size = 4
_SizeFile$ = -8						; size = 4
_pFileName$ = 8						; size = 4
_pSize$ = 12						; size = 4
?LoadFile@@YAPAEPADPAK@Z PROC				; LoadFile, COMDAT

; 3609 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3610 : 	DWORD SizeFile;
; 3611 : 	FILE *pFile;
; 3612 : 	BYTE *pMem;
; 3613 : 
; 3614 : 	if (IsThereFile(pFileName) == false) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pFileName$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?IsThereFile@@YA_NPAD@Z	; IsThereFile
  00027	83 c4 04	 add	 esp, 4
  0002a	0f b6 c8	 movzx	 ecx, al
  0002d	85 c9		 test	 ecx, ecx
  0002f	75 07		 jne	 SHORT $LN4@LoadFile

; 3615 : #ifdef DEBUG_ON
; 3616 : 		SendToLog("ERROR in LoadFile(): missing file \"%s\"",pFileName);
; 3617 : 		
; 3618 : #endif
; 3619 : 		return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 b0 00 00 00	 jmp	 $LN5@LoadFile
$LN4@LoadFile:

; 3620 : 	}
; 3621 : 	pFile = fopen(pFileName,"rb");

  00038	8b f4		 mov	 esi, esp
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  0003f	8b 45 08	 mov	 eax, DWORD PTR _pFileName$[ebp]
  00042	50		 push	 eax
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00049	83 c4 08	 add	 esp, 8
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 ec	 mov	 DWORD PTR _pFile$[ebp], eax

; 3622 : 	if (pFile == NULL) {

  00056	83 7d ec 00	 cmp	 DWORD PTR _pFile$[ebp], 0
  0005a	75 07		 jne	 SHORT $LN3@LoadFile

; 3623 : #ifdef DEBUG_ON
; 3624 : 		SendToLog("ERROR trying to open file: %s", pFileName);
; 3625 : 
; 3626 : #endif
; 3627 : 		return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 85 00 00 00	 jmp	 $LN5@LoadFile
$LN3@LoadFile:

; 3628 : 	}
; 3629 : 	SizeFile=FileLenght(pFile);

  00063	8b 45 ec	 mov	 eax, DWORD PTR _pFile$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?FileLenght@@YAJPAU_iobuf@@@Z ; FileLenght
  0006c	83 c4 04	 add	 esp, 4
  0006f	89 45 f8	 mov	 DWORD PTR _SizeFile$[ebp], eax

; 3630 : 	pMem = (BYTE *) GetMemory(SizeFile);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _SizeFile$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  0007b	83 c4 04	 add	 esp, 4
  0007e	89 45 e0	 mov	 DWORD PTR _pMem$[ebp], eax

; 3631 : 	if (pMem==NULL) {

  00081	83 7d e0 00	 cmp	 DWORD PTR _pMem$[ebp], 0
  00085	75 1a		 jne	 SHORT $LN2@LoadFile

; 3632 : 		fclose(pFile);

  00087	8b f4		 mov	 esi, esp
  00089	8b 45 ec	 mov	 eax, DWORD PTR _pFile$[ebp]
  0008c	50		 push	 eax
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00093	83 c4 04	 add	 esp, 4
  00096	3b f4		 cmp	 esi, esp
  00098	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3633 : 		return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	eb 47		 jmp	 SHORT $LN5@LoadFile
$LN2@LoadFile:

; 3634 : 	}
; 3635 : 	fread(pMem, SizeFile,1, pFile);

  000a1	8b f4		 mov	 esi, esp
  000a3	8b 45 ec	 mov	 eax, DWORD PTR _pFile$[ebp]
  000a6	50		 push	 eax
  000a7	6a 01		 push	 1
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _SizeFile$[ebp]
  000ac	51		 push	 ecx
  000ad	8b 55 e0	 mov	 edx, DWORD PTR _pMem$[ebp]
  000b0	52		 push	 edx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000b7	83 c4 10	 add	 esp, 16			; 00000010H
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3636 : 	fclose(pFile);

  000c1	8b f4		 mov	 esi, esp
  000c3	8b 45 ec	 mov	 eax, DWORD PTR _pFile$[ebp]
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000cd	83 c4 04	 add	 esp, 4
  000d0	3b f4		 cmp	 esi, esp
  000d2	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 3637 : 	if (pSize != NULL) *pSize = SizeFile;

  000d7	83 7d 0c 00	 cmp	 DWORD PTR _pSize$[ebp], 0
  000db	74 08		 je	 SHORT $LN1@LoadFile
  000dd	8b 45 0c	 mov	 eax, DWORD PTR _pSize$[ebp]
  000e0	8b 4d f8	 mov	 ecx, DWORD PTR _SizeFile$[ebp]
  000e3	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@LoadFile:

; 3638 : 
; 3639 : 	return pMem;

  000e5	8b 45 e0	 mov	 eax, DWORD PTR _pMem$[ebp]
$LN5@LoadFile:

; 3640 : }

  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi
  000ea	5b		 pop	 ebx
  000eb	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000f1	3b ec		 cmp	 ebp, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c3		 ret	 0
?LoadFile@@YAPAEPADPAK@Z ENDP				; LoadFile
_TEXT	ENDS
PUBLIC	?GetRoomOff@@YAPAXHK@Z				; GetRoomOff
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetRoomOff@@YAPAXHK@Z
_TEXT	SEGMENT
_pRoomNow$ = -8						; size = 4
_RoomIndex$ = 8						; size = 4
_RoomField$ = 12					; size = 4
?GetRoomOff@@YAPAXHK@Z PROC				; GetRoomOff, COMDAT

; 3644 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3645 : 
; 3646 : 	StrRoomTr4 *pRoomNow;
; 3647 : 
; 3648 : 	pRoomNow= &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex];

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 08	 mov	 edx, DWORD PTR _RoomIndex$[ebp]
  0002c	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00032	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00035	89 55 f8	 mov	 DWORD PTR _pRoomNow$[ebp], edx

; 3649 : 
; 3650 : 	BEGIN_ASM

  00038	60		 pushad

; 3651 : 		mov ecx, RoomField

  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _RoomField$[ebp]

; 3652 : 		add dword ptr [pRoomNow], ecx

  0003c	01 4d f8	 add	 DWORD PTR _pRoomNow$[ebp], ecx

; 3653 : 	END_ASM

  0003f	61		 popad

; 3654 : 
; 3655 : 
; 3656 : 	return pRoomNow;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _pRoomNow$[ebp]

; 3657 : 
; 3658 : 
; 3659 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?GetRoomOff@@YAPAXHK@Z ENDP				; GetRoomOff
_TEXT	ENDS
PUBLIC	?GetItemOff@@YAPAXHK@Z				; GetItemOff
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetItemOff@@YAPAXHK@Z
_TEXT	SEGMENT
_pItem$ = -8						; size = 4
_ItemIndex$ = 8						; size = 4
_ItemFields$ = 12					; size = 4
?GetItemOff@@YAPAXHK@Z PROC				; GetItemOff, COMDAT

; 3662 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3663 : 	StrItemTr4 *pItem;
; 3664 : 
; 3665 : 	pItem = &Trng.pGlobTomb4->pAdr->pVetItems[ItemIndex];

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 08	 mov	 edx, DWORD PTR _ItemIndex$[ebp]
  0002c	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00032	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00035	89 55 f8	 mov	 DWORD PTR _pItem$[ebp], edx

; 3666 : 
; 3667 : 	BEGIN_ASM

  00038	60		 pushad

; 3668 : 		mov ecx, dword ptr [ItemFields]

  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _ItemFields$[ebp]

; 3669 : 		add dword ptr [pItem], ecx

  0003c	01 4d f8	 add	 DWORD PTR _pItem$[ebp], ecx

; 3670 : 	END_ASM

  0003f	61		 popad

; 3671 : 
; 3672 : 	return pItem;

  00040	8b 45 f8	 mov	 eax, DWORD PTR _pItem$[ebp]

; 3673 : 
; 3674 : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?GetItemOff@@YAPAXHK@Z ENDP				; GetItemOff
_TEXT	ENDS
PUBLIC	?GetStaticOff@@YAPAXHHK@Z			; GetStaticOff
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetStaticOff@@YAPAXHHK@Z
_TEXT	SEGMENT
_pStatic$ = -8						; size = 4
_StaticIndex$ = 8					; size = 4
_RoomIndex$ = 12					; size = 4
_StaticField$ = 16					; size = 4
?GetStaticOff@@YAPAXHHK@Z PROC				; GetStaticOff, COMDAT

; 3678 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3679 : 	StrMeshInfo *pStatic;
; 3680 : 
; 3681 : 	pStatic = &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].Ptr_StaticMesh[StaticIndex];

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 0c	 mov	 edx, DWORD PTR _RoomIndex$[ebp]
  0002c	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00032	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00035	8b 4d 08	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  00038	6b c9 14	 imul	 ecx, 20			; 00000014H
  0003b	03 4c 10 10	 add	 ecx, DWORD PTR [eax+edx+16]
  0003f	89 4d f8	 mov	 DWORD PTR _pStatic$[ebp], ecx

; 3682 : 
; 3683 : 
; 3684 : 	BEGIN_ASM

  00042	60		 pushad

; 3685 : 		mov ecx, dword ptr [StaticField]

  00043	8b 4d 10	 mov	 ecx, DWORD PTR _StaticField$[ebp]

; 3686 : 		add dword ptr [pStatic], ecx

  00046	01 4d f8	 add	 DWORD PTR _pStatic$[ebp], ecx

; 3687 : 	END_ASM

  00049	61		 popad

; 3688 : 
; 3689 : 	return pStatic;

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _pStatic$[ebp]

; 3690 : }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?GetStaticOff@@YAPAXHHK@Z ENDP				; GetStaticOff
_TEXT	ENDS
PUBLIC	?ConvNgleStaticIndex@@YAKG@Z			; ConvNgleStaticIndex
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ConvNgleStaticIndex@@YAKG@Z
_TEXT	SEGMENT
_Result$ = -32						; size = 4
_RoomIndex$ = -20					; size = 4
_StaticIndex$ = -8					; size = 4
_NgleStaticIndex$ = 8					; size = 2
?ConvNgleStaticIndex@@YAKG@Z PROC			; ConvNgleStaticIndex, COMDAT

; 3699 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3700 : 
; 3701 : 	DWORD StaticIndex;
; 3702 : 	DWORD RoomIndex;
; 3703 : 	DWORD Result;
; 3704 : 
; 3705 : 	StaticIndex = (DWORD) Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex].IndiceStatic;

  0001e	0f b7 45 08	 movzx	 eax, WORD PTR _NgleStaticIndex$[ebp]
  00022	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00028	0f bf 94 81 98
	66 09 00	 movsx	 edx, WORD PTR [ecx+eax*4+616088]
  00030	89 55 f8	 mov	 DWORD PTR _StaticIndex$[ebp], edx

; 3706 : 	RoomIndex = (DWORD) Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex].IndiceRoom;

  00033	0f b7 45 08	 movzx	 eax, WORD PTR _NgleStaticIndex$[ebp]
  00037	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0003d	0f b7 94 81 96
	66 09 00	 movzx	 edx, WORD PTR [ecx+eax*4+616086]
  00045	89 55 ec	 mov	 DWORD PTR _RoomIndex$[ebp], edx

; 3707 : 
; 3708 : #ifdef DEBUG_ON
; 3709 : 	if (Trng.pGlobTomb4->VetRemapStatics[NgleStaticIndex].IndiceStatic == -1) {
; 3710 : 		SendToLog("ERROR: the NGLE static index to convert (%d) is wrong. No static item coincides with it", 
; 3711 : 								NgleStaticIndex);
; 3712 : 
; 3713 : 	}
; 3714 : #endif
; 3715 : 	Result = StaticIndex;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  0004b	89 45 e0	 mov	 DWORD PTR _Result$[ebp], eax

; 3716 : 	Result |= (RoomIndex << 16);

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _RoomIndex$[ebp]
  00051	c1 e0 10	 shl	 eax, 16			; 00000010H
  00054	0b 45 e0	 or	 eax, DWORD PTR _Result$[ebp]
  00057	89 45 e0	 mov	 DWORD PTR _Result$[ebp], eax

; 3717 : 
; 3718 : 	return Result;

  0005a	8b 45 e0	 mov	 eax, DWORD PTR _Result$[ebp]

; 3719 : 	
; 3720 : }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?ConvNgleStaticIndex@@YAKG@Z ENDP			; ConvNgleStaticIndex
_TEXT	ENDS
PUBLIC	?SendErrorToDiskLog@@YAXPADK_N@Z		; SendErrorToDiskLog
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SendErrorToDiskLog@@YAXPADK_N@Z
_TEXT	SEGMENT
_pMessage$ = 8						; size = 4
_PluginID$ = 12						; size = 4
_TestMsgBox$ = 16					; size = 1
?SendErrorToDiskLog@@YAXPADK_N@Z PROC			; SendErrorToDiskLog, COMDAT

; 3723 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3724 : 
; 3725 : 	Service(SRV_F_InviaErroreLog, pMessage, PluginID, TestMsgBox);

  0001e	0f b6 45 10	 movzx	 eax, BYTE PTR _TestMsgBox$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _PluginID$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR _pMessage$[ebp]
  0002a	52		 push	 edx
  0002b	6a 11		 push	 17			; 00000011H
  0002d	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 3726 : 
; 3727 : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?SendErrorToDiskLog@@YAXPADK_N@Z ENDP			; SendErrorToDiskLog
_TEXT	ENDS
PUBLIC	?ConvertMicroUnits@@YAXPAUtagRECT@@@Z		; ConvertMicroUnits
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ConvertMicroUnits@@YAXPAUtagRECT@@@Z
_TEXT	SEGMENT
_pRect$ = 8						; size = 4
?ConvertMicroUnits@@YAXPAUtagRECT@@@Z PROC		; ConvertMicroUnits, COMDAT

; 3736 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3737 : 	Service(SRV_F_ConvertMicroUnits, pRect);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pRect$[ebp]
  00021	50		 push	 eax
  00022	6a 2a		 push	 42			; 0000002aH
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 3738 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ConvertMicroUnits@@YAXPAUtagRECT@@@Z ENDP		; ConvertMicroUnits
_TEXT	ENDS
PUBLIC	?AllocateImage@@YA_NHPAUStrRecordImage@@HH@Z	; AllocateImage
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AllocateImage@@YA_NHPAUStrRecordImage@@HH@Z
_TEXT	SEGMENT
_NImage$ = 8						; size = 4
_pRecord$ = 12						; size = 4
_ForceSizeX$ = 16					; size = 4
_ForceSizeY$ = 20					; size = 4
?AllocateImage@@YA_NHPAUStrRecordImage@@HH@Z PROC	; AllocateImage, COMDAT

; 3749 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3750 : 	if (Service(SRV_F_AllocateImage, NImage, pRecord, ForceSizeX, ForceSizeY)) return true;

  0001e	8b 45 14	 mov	 eax, DWORD PTR _ForceSizeY$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR _ForceSizeX$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR _pRecord$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 08	 mov	 eax, DWORD PTR _NImage$[ebp]
  0002d	50		 push	 eax
  0002e	6a 2b		 push	 43			; 0000002bH
  00030	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00035	83 c4 14	 add	 esp, 20			; 00000014H
  00038	85 c0		 test	 eax, eax
  0003a	74 04		 je	 SHORT $LN1@AllocateIm
  0003c	b0 01		 mov	 al, 1
  0003e	eb 02		 jmp	 SHORT $LN2@AllocateIm
$LN1@AllocateIm:

; 3751 : 	return false;

  00040	32 c0		 xor	 al, al
$LN2@AllocateIm:

; 3752 : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?AllocateImage@@YA_NHPAUStrRecordImage@@HH@Z ENDP	; AllocateImage
_TEXT	ENDS
PUBLIC	?FreeImage@@YAXPAUStrRecordImage@@@Z		; FreeImage
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeImage@@YAXPAUStrRecordImage@@@Z
_TEXT	SEGMENT
_pRecord$ = 8						; size = 4
?FreeImage@@YAXPAUStrRecordImage@@@Z PROC		; FreeImage, COMDAT

; 3756 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3757 : 	Service(SRV_F_FreeImage, pRecord);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pRecord$[ebp]
  00021	50		 push	 eax
  00022	6a 2c		 push	 44			; 0000002cH
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 3758 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?FreeImage@@YAXPAUStrRecordImage@@@Z ENDP		; FreeImage
_TEXT	ENDS
PUBLIC	?AllocateTombHdc@@YA_NPAUStrShowImage@@_N1@Z	; AllocateTombHdc
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?AllocateTombHdc@@YA_NPAUStrShowImage@@_N1@Z
_TEXT	SEGMENT
_pBase$ = 8						; size = 4
_TestHdcTemp$ = 12					; size = 1
_TestWriteHdc$ = 16					; size = 1
?AllocateTombHdc@@YA_NPAUStrShowImage@@_N1@Z PROC	; AllocateTombHdc, COMDAT

; 3769 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3770 : 	if (Service(SRV_F_AllocateTombHdc, pBase, TestHdcTemp, TestWriteHdc)) return true;

  0001e	0f b6 45 10	 movzx	 eax, BYTE PTR _TestWriteHdc$[ebp]
  00022	50		 push	 eax
  00023	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _TestHdcTemp$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR _pBase$[ebp]
  0002b	52		 push	 edx
  0002c	6a 2d		 push	 45			; 0000002dH
  0002e	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	85 c0		 test	 eax, eax
  00038	74 04		 je	 SHORT $LN1@AllocateTo
  0003a	b0 01		 mov	 al, 1
  0003c	eb 02		 jmp	 SHORT $LN2@AllocateTo
$LN1@AllocateTo:

; 3771 : 	return false;

  0003e	32 c0		 xor	 al, al
$LN2@AllocateTo:

; 3772 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?AllocateTombHdc@@YA_NPAUStrShowImage@@_N1@Z ENDP	; AllocateTombHdc
_TEXT	ENDS
PUBLIC	?DrawSprite2D@@YAXPAUtagRECT@@GHEK@Z		; DrawSprite2D
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DrawSprite2D@@YAXPAUtagRECT@@GHEK@Z
_TEXT	SEGMENT
_pRect$ = 8						; size = 4
_Slot$ = 12						; size = 2
_SpriteIndex$ = 16					; size = 4
_Opacity$ = 20						; size = 1
_Color$ = 24						; size = 4
?DrawSprite2D@@YAXPAUtagRECT@@GHEK@Z PROC		; DrawSprite2D, COMDAT

; 3786 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3787 : 	Service(SRV_F_DrawSprite2D, pRect, Slot, SpriteIndex, Opacity, Color);

  0001e	8b 45 18	 mov	 eax, DWORD PTR _Color$[ebp]
  00021	50		 push	 eax
  00022	0f b6 4d 14	 movzx	 ecx, BYTE PTR _Opacity$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 10	 mov	 edx, DWORD PTR _SpriteIndex$[ebp]
  0002a	52		 push	 edx
  0002b	0f b7 45 0c	 movzx	 eax, WORD PTR _Slot$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _pRect$[ebp]
  00033	51		 push	 ecx
  00034	6a 2f		 push	 47			; 0000002fH
  00036	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0003b	83 c4 18	 add	 esp, 24			; 00000018H

; 3788 : }

  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?DrawSprite2D@@YAXPAUtagRECT@@GHEK@Z ENDP		; DrawSprite2D
_TEXT	ENDS
PUBLIC	?DrawMesh3D@@YAXPAUStrPos3d@@H@Z		; DrawMesh3D
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DrawMesh3D@@YAXPAUStrPos3d@@H@Z
_TEXT	SEGMENT
_pPos$ = 8						; size = 4
_MeshIndex$ = 12					; size = 4
?DrawMesh3D@@YAXPAUStrPos3d@@H@Z PROC			; DrawMesh3D, COMDAT

; 3793 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3794 : 	Service(SRV_F_DrawMesh3D, pPos, MeshIndex);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _MeshIndex$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00025	51		 push	 ecx
  00026	6a 30		 push	 48			; 00000030H
  00028	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3795 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?DrawMesh3D@@YAXPAUStrPos3d@@H@Z ENDP			; DrawMesh3D
_TEXT	ENDS
PUBLIC	?DrawObject2D@@YAXGHHGGGH@Z			; DrawObject2D
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DrawObject2D@@YAXGHHGGGH@Z
_TEXT	SEGMENT
_Slot$ = 8						; size = 2
_CordX$ = 12						; size = 4
_CordY$ = 16						; size = 4
_OrientX$ = 20						; size = 2
_OrientY$ = 24						; size = 2
_OrientZ$ = 28						; size = 2
_Distance$ = 32						; size = 4
?DrawObject2D@@YAXGHHGGGH@Z PROC			; DrawObject2D, COMDAT

; 3803 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3804 : 	Service(SRV_F_DrawObject2D, Slot, CordX, CordY, OrientX, OrientY, OrientZ, Distance);

  0001e	8b 45 20	 mov	 eax, DWORD PTR _Distance$[ebp]
  00021	50		 push	 eax
  00022	0f b7 4d 1c	 movzx	 ecx, WORD PTR _OrientZ$[ebp]
  00026	51		 push	 ecx
  00027	0f b7 55 18	 movzx	 edx, WORD PTR _OrientY$[ebp]
  0002b	52		 push	 edx
  0002c	0f b7 45 14	 movzx	 eax, WORD PTR _OrientX$[ebp]
  00030	50		 push	 eax
  00031	8b 4d 10	 mov	 ecx, DWORD PTR _CordY$[ebp]
  00034	51		 push	 ecx
  00035	8b 55 0c	 mov	 edx, DWORD PTR _CordX$[ebp]
  00038	52		 push	 edx
  00039	0f b7 45 08	 movzx	 eax, WORD PTR _Slot$[ebp]
  0003d	50		 push	 eax
  0003e	6a 31		 push	 49			; 00000031H
  00040	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00045	83 c4 20	 add	 esp, 32			; 00000020H

; 3805 : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?DrawObject2D@@YAXGHHGGGH@Z ENDP			; DrawObject2D
_TEXT	ENDS
PUBLIC	?FreeTombHdc@@YAXPAUStrShowImage@@_N@Z		; FreeTombHdc
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeTombHdc@@YAXPAUStrShowImage@@_N@Z
_TEXT	SEGMENT
_pBase$ = 8						; size = 4
_TestKeepTempHdc$ = 12					; size = 1
?FreeTombHdc@@YAXPAUStrShowImage@@_N@Z PROC		; FreeTombHdc, COMDAT

; 3811 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3812 : 	Service(SRV_F_FreeTombHdc, pBase, TestKeepTempHdc);

  0001e	0f b6 45 0c	 movzx	 eax, BYTE PTR _TestKeepTempHdc$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pBase$[ebp]
  00026	51		 push	 ecx
  00027	6a 2e		 push	 46			; 0000002eH
  00029	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3813 : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?FreeTombHdc@@YAXPAUStrShowImage@@_N@Z ENDP		; FreeTombHdc
_TEXT	ENDS
PUBLIC	??_C@_0FC@LGLKDBFF@ERROR?3?5failed?5check?5of?5alignment@ ; `string'
PUBLIC	?CheckControlGlobTomb4@@YA_NXZ			; CheckControlGlobTomb4
;	COMDAT ??_C@_0FC@LGLKDBFF@ERROR?3?5failed?5check?5of?5alignment@
CONST	SEGMENT
??_C@_0FC@LGLKDBFF@ERROR?3?5failed?5check?5of?5alignment@ DB 'ERROR: fail'
	DB	'ed check of alignment value of GlobTomb4 structure for 1.3.0.'
	DB	'0 version', 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?CheckControlGlobTomb4@@YA_NXZ
_TEXT	SEGMENT
?CheckControlGlobTomb4@@YA_NXZ PROC			; CheckControlGlobTomb4, COMDAT

; 3816 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3817 : 
; 3818 : 	if (Trng.pGlobTomb4->CheckValue1_3_0_0 != 0x01234567) {

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	81 b8 a8 5e 21
	00 67 45 23 01	 cmp	 DWORD PTR [eax+2186920], 19088743 ; 01234567H
  0002d	74 19		 je	 SHORT $LN1@CheckContr

; 3819 : 		// globtomb4 changed 
; 3820 : 		SendErrorToDiskLog("ERROR: failed check of alignment value of GlobTomb4 structure for 1.3.0.0 version", Trng.IdMyPlugin, false);

  0002f	6a 00		 push	 0
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@LGLKDBFF@ERROR?3?5failed?5check?5of?5alignment@
  0003c	e8 00 00 00 00	 call	 ?SendErrorToDiskLog@@YAXPADK_N@Z ; SendErrorToDiskLog
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3821 : 		return false;

  00044	32 c0		 xor	 al, al
  00046	eb 02		 jmp	 SHORT $LN2@CheckContr
$LN1@CheckContr:

; 3822 : 
; 3823 : 	}
; 3824 : 
; 3825 : 	return true;

  00048	b0 01		 mov	 al, 1
$LN2@CheckContr:

; 3826 : 
; 3827 : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?CheckControlGlobTomb4@@YA_NXZ ENDP			; CheckControlGlobTomb4
_TEXT	ENDS
PUBLIC	?GetNewProgrAction@@YAPAUStrProgressiveAction@@XZ ; GetNewProgrAction
EXTRN	?MyData@@3UStrMyData@@A:BYTE			; MyData
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetNewProgrAction@@YAPAUStrProgressiveAction@@XZ
_TEXT	SEGMENT
_i$ = -20						; size = 4
_pAction$ = -8						; size = 4
?GetNewProgrAction@@YAPAUStrProgressiveAction@@XZ PROC	; GetNewProgrAction, COMDAT

; 3834 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3835 : 	
; 3836 : 	StrProgressiveAction *pAction;
; 3837 : 	int i;
; 3838 : 
; 3839 : 	pAction= &MyData.VetProgrActions[0];

  0001e	c7 45 f8 0a 00
	00 00		 mov	 DWORD PTR _pAction$[ebp], OFFSET ?MyData@@3UStrMyData@@A+10

; 3840 : 
; 3841 : 	// look for first free record
; 3842 : 	for (i=0;i<MyData.TotProgrActions;i++) {

  00025	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN6@GetNewProg
$LN5@GetNewProg:
  0002e	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN6@GetNewProg:
  00037	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	3b 05 02 00 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  00040	7d 1a		 jge	 SHORT $LN4@GetNewProg

; 3843 : 		if (pAction->ActionType == AXN_FREE) {

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pAction$[ebp]
  00045	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00048	85 c9		 test	 ecx, ecx
  0004a	75 05		 jne	 SHORT $LN3@GetNewProg

; 3844 : 
; 3845 : 			return pAction;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _pAction$[ebp]
  0004f	eb 7b		 jmp	 SHORT $LN7@GetNewProg
$LN3@GetNewProg:

; 3846 : 		}
; 3847 : 		pAction++;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _pAction$[ebp]
  00054	83 c0 20	 add	 eax, 32			; 00000020H
  00057	89 45 f8	 mov	 DWORD PTR _pAction$[ebp], eax

; 3848 : 	}

  0005a	eb d2		 jmp	 SHORT $LN5@GetNewProg
$LN4@GetNewProg:

; 3849 : 	// no record free
; 3850 : 	// increase number of allocated records
; 3851 : 	if (MyData.TotProgrActions >= MAX_MYPROGR_ACTIONS) {

  0005c	83 3d 02 00 00
	00 64		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+2, 100 ; 00000064H
  00063	7c 41		 jl	 SHORT $LN2@GetNewProg

; 3852 : 		// already reached max number of record (bad matter)
; 3853 : 		// stole the record to older progressive action and send an error message if debug is on
; 3854 : 		i= MyData.LastProgrActionIndex;

  00065	a1 06 00 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+6
  0006a	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 3855 : 
; 3856 : 		pAction = &MyData.VetProgrActions[i];

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00070	c1 e0 05	 shl	 eax, 5
  00073	05 0a 00 00 00	 add	 eax, OFFSET ?MyData@@3UStrMyData@@A+10
  00078	89 45 f8	 mov	 DWORD PTR _pAction$[ebp], eax

; 3857 : 
; 3858 : 
; 3859 : 		
; 3860 : #ifdef DEBUG_ON
; 3861 : 
; 3862 : 		SendToLog("ERROR from GetNewProgrAction(): no more available StrProgressiveAction records. Cleared old ProgrAction with ActionType = %d and ItemIndex=%d",
; 3863 : 			pAction->ActionType, pAction->ItemIndex);
; 3864 : 	
; 3865 : 	
; 3866 : #endif
; 3867 : 		pAction->ActionType= AXN_FREE;

  0007b	33 c0		 xor	 eax, eax
  0007d	8b 4d f8	 mov	 ecx, DWORD PTR _pAction$[ebp]
  00080	66 89 01	 mov	 WORD PTR [ecx], ax

; 3868 : 		// update next index to stole for older prograction
; 3869 : 		i++;

  00083	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00086	83 c0 01	 add	 eax, 1
  00089	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 3870 : 		if (i >= MAX_MYPROGR_ACTIONS) {

  0008c	83 7d ec 64	 cmp	 DWORD PTR _i$[ebp], 100	; 00000064H
  00090	7c 07		 jl	 SHORT $LN1@GetNewProg

; 3871 : 			i = 0;

  00092	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
$LN1@GetNewProg:

; 3872 : 		}
; 3873 : 		MyData.LastProgrActionIndex = i;

  00099	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0009c	a3 06 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+6, eax

; 3874 : 
; 3875 : 		return pAction;

  000a1	8b 45 f8	 mov	 eax, DWORD PTR _pAction$[ebp]
  000a4	eb 26		 jmp	 SHORT $LN7@GetNewProg
$LN2@GetNewProg:

; 3876 : 	}
; 3877 : 	// allocate new record
; 3878 : 	i = MyData.TotProgrActions;

  000a6	a1 02 00 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  000ab	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 3879 : 	pAction= &MyData.VetProgrActions[i];

  000ae	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000b1	c1 e0 05	 shl	 eax, 5
  000b4	05 0a 00 00 00	 add	 eax, OFFSET ?MyData@@3UStrMyData@@A+10
  000b9	89 45 f8	 mov	 DWORD PTR _pAction$[ebp], eax

; 3880 : 
; 3881 : 	MyData.TotProgrActions++;

  000bc	a1 02 00 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  000c1	83 c0 01	 add	 eax, 1
  000c4	a3 02 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+2, eax

; 3882 : 	return pAction;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _pAction$[ebp]
$LN7@GetNewProg:

; 3883 : 
; 3884 : }

  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
?GetNewProgrAction@@YAPAUStrProgressiveAction@@XZ ENDP	; GetNewProgrAction
_TEXT	ENDS
PUBLIC	??_C@_0EN@EBIKAGHH@INTERNAL?5ERROR?3?5not?5found?5the?5Co@ ; `string'
PUBLIC	??_C@_0EH@DLBKKJCI@ERROR?5it?5has?5not?5been?5set?5the?5ID@ ; `string'
PUBLIC	?GetColorRgb@@YAKFK_NPAD@Z			; GetColorRgb
;	COMDAT ??_C@_0EN@EBIKAGHH@INTERNAL?5ERROR?3?5not?5found?5the?5Co@
CONST	SEGMENT
??_C@_0EN@EBIKAGHH@INTERNAL?5ERROR?3?5not?5found?5the?5Co@ DB 'INTERNAL E'
	DB	'RROR: not found the ColorRgb command with id = %d (called fro'
	DB	'm %s)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@DLBKKJCI@ERROR?5it?5has?5not?5been?5set?5the?5ID@
CONST	SEGMENT
??_C@_0EH@DLBKKJCI@ERROR?5it?5has?5not?5been?5set?5the?5ID@ DB 'ERROR it '
	DB	'has not been set the ID for ColorRbg in the script command %s'
	DB	00H						; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?GetColorRgb@@YAKFK_NPAD@Z
_TEXT	SEGMENT
_pRgb$ = -44						; size = 4
_pDest$ = -32						; size = 4
_NewColor$ = -20					; size = 4
_Indice$ = -8						; size = 4
_IdColorRgb$ = 8					; size = 2
_DefColor$ = 12						; size = 4
_TestInvert$ = 16					; size = 1
_pMexCommand$ = 20					; size = 4
?GetColorRgb@@YAKFK_NPAD@Z PROC				; GetColorRgb, COMDAT

; 3892 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3893 : 	
; 3894 : 	int Indice;
; 3895 : 	COLORREF NewColor;
; 3896 : 	StrSingleColors *pDest;
; 3897 : 	StrColorRGB *pRgb;
; 3898 : 
; 3899 : 	if (IdColorRgb < 0) {

  0001e	0f bf 45 08	 movsx	 eax, WORD PTR _IdColorRgb$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	7d 19		 jge	 SHORT $LN3@GetColorRg

; 3900 : 		SendToLog("ERROR it has not been set the ID for ColorRbg in the script command %s", pMexCommand);

  00026	8b 45 14	 mov	 eax, DWORD PTR _pMexCommand$[ebp]
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@DLBKKJCI@ERROR?5it?5has?5not?5been?5set?5the?5ID@
  0002f	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00034	83 c4 08	 add	 esp, 8

; 3901 : 		return DefColor;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _DefColor$[ebp]
  0003a	e9 8f 00 00 00	 jmp	 $LN4@GetColorRg
$LN3@GetColorRg:

; 3902 : 	}
; 3903 : 
; 3904 : 	Indice = Trng.pGlobTomb4->BaseColoriRGB.VetID[IdColorRgb];

  0003f	0f bf 45 08	 movsx	 eax, WORD PTR _IdColorRgb$[ebp]
  00043	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00049	0f bf 94 41 f6
	56 09 00	 movsx	 edx, WORD PTR [ecx+eax*2+612086]
  00051	89 55 f8	 mov	 DWORD PTR _Indice$[ebp], edx

; 3905 : 	
; 3906 : 	if (Indice == -1) {

  00054	83 7d f8 ff	 cmp	 DWORD PTR _Indice$[ebp], -1
  00058	75 1b		 jne	 SHORT $LN2@GetColorRg

; 3907 : 		SendToLog("INTERNAL ERROR: not found the ColorRgb command with id = %d (called from %s)", 
; 3908 : 							IdColorRgb, pMexCommand);

  0005a	8b 45 14	 mov	 eax, DWORD PTR _pMexCommand$[ebp]
  0005d	50		 push	 eax
  0005e	0f bf 4d 08	 movsx	 ecx, WORD PTR _IdColorRgb$[ebp]
  00062	51		 push	 ecx
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@EBIKAGHH@INTERNAL?5ERROR?3?5not?5found?5the?5Co@
  00068	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3909 : 		return DefColor;

  00070	8b 45 0c	 mov	 eax, DWORD PTR _DefColor$[ebp]
  00073	eb 59		 jmp	 SHORT $LN4@GetColorRg
$LN2@GetColorRg:

; 3910 : 	}
; 3911 : 	pRgb = &Trng.pGlobTomb4->BaseColoriRGB.VetColori[Indice];

  00075	8b 45 f8	 mov	 eax, DWORD PTR _Indice$[ebp]
  00078	6b c0 06	 imul	 eax, 6
  0007b	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00081	8d 94 01 46 52
	09 00		 lea	 edx, DWORD PTR [ecx+eax+610886]
  00088	89 55 d4	 mov	 DWORD PTR _pRgb$[ebp], edx

; 3912 : 
; 3913 : 	if (TestInvert) {

  0008b	0f b6 45 10	 movzx	 eax, BYTE PTR _TestInvert$[ebp]
  0008f	85 c0		 test	 eax, eax
  00091	74 35		 je	 SHORT $LN1@GetColorRg

; 3914 : 		pDest = (StrSingleColors *) &NewColor;

  00093	8d 45 ec	 lea	 eax, DWORD PTR _NewColor$[ebp]
  00096	89 45 e0	 mov	 DWORD PTR _pDest$[ebp], eax

; 3915 : 
; 3916 : 
; 3917 : 		pDest->Blue = pRgb->Single.Red;

  00099	8b 45 e0	 mov	 eax, DWORD PTR _pDest$[ebp]
  0009c	8b 4d d4	 mov	 ecx, DWORD PTR _pRgb$[ebp]
  0009f	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  000a2	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 3918 : 		pDest->Green = pRgb->Single.Green;

  000a5	8b 45 e0	 mov	 eax, DWORD PTR _pDest$[ebp]
  000a8	8b 4d d4	 mov	 ecx, DWORD PTR _pRgb$[ebp]
  000ab	8a 51 03	 mov	 dl, BYTE PTR [ecx+3]
  000ae	88 50 01	 mov	 BYTE PTR [eax+1], dl

; 3919 : 		pDest->Red = pRgb->Single.Blue;

  000b1	8b 45 e0	 mov	 eax, DWORD PTR _pDest$[ebp]
  000b4	8b 4d d4	 mov	 ecx, DWORD PTR _pRgb$[ebp]
  000b7	8a 51 04	 mov	 dl, BYTE PTR [ecx+4]
  000ba	88 10		 mov	 BYTE PTR [eax], dl

; 3920 : 		pDest->Unused = 0;

  000bc	8b 45 e0	 mov	 eax, DWORD PTR _pDest$[ebp]
  000bf	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 3921 : 		return NewColor;

  000c3	8b 45 ec	 mov	 eax, DWORD PTR _NewColor$[ebp]
  000c6	eb 06		 jmp	 SHORT $LN4@GetColorRg
$LN1@GetColorRg:

; 3922 : 	}
; 3923 : 
; 3924 : 
; 3925 : 	return pRgb->Colore;

  000c8	8b 45 d4	 mov	 eax, DWORD PTR _pRgb$[ebp]
  000cb	8b 40 02	 mov	 eax, DWORD PTR [eax+2]
$LN4@GetColorRg:

; 3926 : 
; 3927 : 
; 3928 : }

  000ce	52		 push	 edx
  000cf	8b cd		 mov	 ecx, ebp
  000d1	50		 push	 eax
  000d2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@GetColorRg
  000d8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000dd	58		 pop	 eax
  000de	5a		 pop	 edx
  000df	5f		 pop	 edi
  000e0	5e		 pop	 esi
  000e1	5b		 pop	 ebx
  000e2	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
  000f3	90		 npad	 1
$LN8@GetColorRg:
  000f4	01 00 00 00	 DD	 1
  000f8	00 00 00 00	 DD	 $LN7@GetColorRg
$LN7@GetColorRg:
  000fc	ec ff ff ff	 DD	 -20			; ffffffecH
  00100	04 00 00 00	 DD	 4
  00104	00 00 00 00	 DD	 $LN6@GetColorRg
$LN6@GetColorRg:
  00108	4e		 DB	 78			; 0000004eH
  00109	65		 DB	 101			; 00000065H
  0010a	77		 DB	 119			; 00000077H
  0010b	43		 DB	 67			; 00000043H
  0010c	6f		 DB	 111			; 0000006fH
  0010d	6c		 DB	 108			; 0000006cH
  0010e	6f		 DB	 111			; 0000006fH
  0010f	72		 DB	 114			; 00000072H
  00110	00		 DB	 0
?GetColorRgb@@YAKFK_NPAD@Z ENDP				; GetColorRgb
_TEXT	ENDS
PUBLIC	??_C@_0FK@GKKFMDDI@ERROR?3?5required?5conversion?5from?5@ ; `string'
PUBLIC	?ConvertFromStrItemToItemIndex@@YAHPAUStrItemTr4@@@Z ; ConvertFromStrItemToItemIndex
;	COMDAT ??_C@_0FK@GKKFMDDI@ERROR?3?5required?5conversion?5from?5@
CONST	SEGMENT
??_C@_0FK@GKKFMDDI@ERROR?3?5required?5conversion?5from?5@ DB 'ERROR: requ'
	DB	'ired conversion from StrItem to item index but the pointer fo'
	DB	'r StrItem is NULL', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?ConvertFromStrItemToItemIndex@@YAHPAUStrItemTr4@@@Z
_TEXT	SEGMENT
_BaseAdr$ = -8						; size = 4
_pItem$ = 8						; size = 4
?ConvertFromStrItemToItemIndex@@YAHPAUStrItemTr4@@@Z PROC ; ConvertFromStrItemToItemIndex, COMDAT

; 3931 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3932 : 	int BaseAdr;
; 3933 : 
; 3934 : 	if (pItem==NULL) {

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pItem$[ebp], 0
  00022	75 12		 jne	 SHORT $LN1@ConvertFro

; 3935 : 		SendToLog("ERROR: required conversion from StrItem to item index but the pointer for StrItem is NULL");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@GKKFMDDI@ERROR?3?5required?5conversion?5from?5@
  00029	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0002e	83 c4 04	 add	 esp, 4

; 3936 : 		return -1;

  00031	83 c8 ff	 or	 eax, -1
  00034	eb 2c		 jmp	 SHORT $LN2@ConvertFro
$LN1@ConvertFro:

; 3937 : 	}
; 3938 : 
; 3939 : 	BaseAdr = (int) pItem;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pItem$[ebp]
  00039	89 45 f8	 mov	 DWORD PTR _BaseAdr$[ebp], eax

; 3940 : 	BaseAdr -= (int) Trng.pGlobTomb4->pAdr->pVetItems ;

  0003c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00041	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00047	8b 55 f8	 mov	 edx, DWORD PTR _BaseAdr$[ebp]
  0004a	2b 51 08	 sub	 edx, DWORD PTR [ecx+8]
  0004d	89 55 f8	 mov	 DWORD PTR _BaseAdr$[ebp], edx

; 3941 : 	BaseAdr /= sizeof(StrItemTr4);

  00050	8b 45 f8	 mov	 eax, DWORD PTR _BaseAdr$[ebp]
  00053	33 d2		 xor	 edx, edx
  00055	b9 f6 15 00 00	 mov	 ecx, 5622		; 000015f6H
  0005a	f7 f1		 div	 ecx
  0005c	89 45 f8	 mov	 DWORD PTR _BaseAdr$[ebp], eax

; 3942 : 
; 3943 : 	return BaseAdr;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _BaseAdr$[ebp]
$LN2@ConvertFro:

; 3944 : }

  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006b	3b ec		 cmp	 ebp, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?ConvertFromStrItemToItemIndex@@YAHPAUStrItemTr4@@@Z ENDP ; ConvertFromStrItemToItemIndex
_TEXT	ENDS
PUBLIC	?ReadNumVariable@@YAHH@Z			; ReadNumVariable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ReadNumVariable@@YAHH@Z
_TEXT	SEGMENT
_Code$ = 8						; size = 4
?ReadNumVariable@@YAHH@Z PROC				; ReadNumVariable, COMDAT

; 3952 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3953 : 	 
; 3954 : 	return Service(SRV_F_ReadNumVariable, Code);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _Code$[ebp]
  00021	50		 push	 eax
  00022	6a 39		 push	 57			; 00000039H
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 3955 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ReadNumVariable@@YAHH@Z ENDP				; ReadNumVariable
_TEXT	ENDS
PUBLIC	?WriteNumVariable@@YAXHH@Z			; WriteNumVariable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?WriteNumVariable@@YAXHH@Z
_TEXT	SEGMENT
_Code$ = 8						; size = 4
_Value$ = 12						; size = 4
?WriteNumVariable@@YAXHH@Z PROC				; WriteNumVariable, COMDAT

; 3963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3964 : 	Service(SRV_F_WriteNumVariable, Code, Value);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _Value$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _Code$[ebp]
  00025	51		 push	 ecx
  00026	6a 3a		 push	 58			; 0000003aH
  00028	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3965 : 
; 3966 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?WriteNumVariable@@YAXHH@Z ENDP				; WriteNumVariable
_TEXT	ENDS
PUBLIC	?ReadTextVariable@@YAPADH@Z			; ReadTextVariable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ReadTextVariable@@YAPADH@Z
_TEXT	SEGMENT
_pChar$ = -8						; size = 4
_Code$ = 8						; size = 4
?ReadTextVariable@@YAPADH@Z PROC			; ReadTextVariable, COMDAT

; 3973 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3974 : 	char *pChar;
; 3975 : 
; 3976 : 	pChar = (char *) Service(SRV_F_ReadTextVariable, Code);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _Code$[ebp]
  00021	50		 push	 eax
  00022	6a 3b		 push	 59			; 0000003bH
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 f8	 mov	 DWORD PTR _pChar$[ebp], eax

; 3977 : 
; 3978 : 	return pChar;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR _pChar$[ebp]

; 3979 : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?ReadTextVariable@@YAPADH@Z ENDP			; ReadTextVariable
_TEXT	ENDS
PUBLIC	?WriteTextVariable@@YAXHPAD@Z			; WriteTextVariable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?WriteTextVariable@@YAXHPAD@Z
_TEXT	SEGMENT
_Code$ = 8						; size = 4
_pText$ = 12						; size = 4
?WriteTextVariable@@YAXHPAD@Z PROC			; WriteTextVariable, COMDAT

; 3986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3987 : 	Service(SRV_F_WriteTextVariable, pText);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _pText$[ebp]
  00021	50		 push	 eax
  00022	6a 3c		 push	 60			; 0000003cH
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 3988 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?WriteTextVariable@@YAXHPAD@Z ENDP			; WriteTextVariable
_TEXT	ENDS
PUBLIC	?ReadMemVariable@@YAHH@Z			; ReadMemVariable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ReadMemVariable@@YAHH@Z
_TEXT	SEGMENT
_Code$ = 8						; size = 4
?ReadMemVariable@@YAHH@Z PROC				; ReadMemVariable, COMDAT

; 3997 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 3998 : 	return Service(SRV_F_ReadMemVariable, Code);

  0001e	8b 45 08	 mov	 eax, DWORD PTR _Code$[ebp]
  00021	50		 push	 eax
  00022	6a 3d		 push	 61			; 0000003dH
  00024	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00029	83 c4 08	 add	 esp, 8

; 3999 : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?ReadMemVariable@@YAHH@Z ENDP				; ReadMemVariable
_TEXT	ENDS
PUBLIC	?WriteMemVariable@@YAXHH@Z			; WriteMemVariable
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?WriteMemVariable@@YAXHH@Z
_TEXT	SEGMENT
_Code$ = 8						; size = 4
_Value$ = 12						; size = 4
?WriteMemVariable@@YAXHH@Z PROC				; WriteMemVariable, COMDAT

; 4003 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4004 : 	Service(SRV_F_WriteMemVariable, Code, Value);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _Value$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _Code$[ebp]
  00025	51		 push	 ecx
  00026	6a 3e		 push	 62			; 0000003eH
  00028	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4005 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?WriteMemVariable@@YAXHH@Z ENDP				; WriteMemVariable
_TEXT	ENDS
PUBLIC	?GetRelAnim@@YAHPAUStrItemTr4@@H@Z		; GetRelAnim
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetRelAnim@@YAHPAUStrItemTr4@@H@Z
_TEXT	SEGMENT
_RelativeIndex$ = -32					; size = 4
_FirstAnimation$ = -20					; size = 4
_pSlot$ = -8						; size = 4
_pItem$ = 8						; size = 4
_AnimIndex$ = 12					; size = 4
?GetRelAnim@@YAHPAUStrItemTr4@@H@Z PROC			; GetRelAnim, COMDAT

; 4010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4011 : 	StrSlot *pSlot;
; 4012 : 	int FirstAnimation;
; 4013 : 	int RelativeIndex;
; 4014 : 	
; 4015 : 	pSlot = &Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID];

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0002c	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00030	c1 e0 06	 shl	 eax, 6
  00033	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00036	89 45 f8	 mov	 DWORD PTR _pSlot$[ebp], eax

; 4016 : 
; 4017 : 	FirstAnimation = pSlot->IndexFirstAnim;

  00039	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0003c	0f b7 48 26	 movzx	 ecx, WORD PTR [eax+38]
  00040	89 4d ec	 mov	 DWORD PTR _FirstAnimation$[ebp], ecx

; 4018 : 
; 4019 : 	RelativeIndex = AnimIndex - FirstAnimation;

  00043	8b 45 0c	 mov	 eax, DWORD PTR _AnimIndex$[ebp]
  00046	2b 45 ec	 sub	 eax, DWORD PTR _FirstAnimation$[ebp]
  00049	89 45 e0	 mov	 DWORD PTR _RelativeIndex$[ebp], eax

; 4020 : 
; 4021 : 	return RelativeIndex;

  0004c	8b 45 e0	 mov	 eax, DWORD PTR _RelativeIndex$[ebp]

; 4022 : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?GetRelAnim@@YAHPAUStrItemTr4@@H@Z ENDP			; GetRelAnim
_TEXT	ENDS
PUBLIC	?GetAbsAnim@@YAHPAUStrItemTr4@@H@Z		; GetAbsAnim
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetAbsAnim@@YAHPAUStrItemTr4@@H@Z
_TEXT	SEGMENT
_FirstAnimation$ = -20					; size = 4
_pSlot$ = -8						; size = 4
_pItem$ = 8						; size = 4
_AnimIndex$ = 12					; size = 4
?GetAbsAnim@@YAHPAUStrItemTr4@@H@Z PROC			; GetAbsAnim, COMDAT

; 4026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4027 : 	StrSlot *pSlot;
; 4028 : 	int FirstAnimation;
; 4029 : 	
; 4030 : 	pSlot = &Trng.pGlobTomb4->pAdr->pVetSlot[pItem->SlotID];

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 55 08	 mov	 edx, DWORD PTR _pItem$[ebp]
  0002c	0f b7 42 0c	 movzx	 eax, WORD PTR [edx+12]
  00030	c1 e0 06	 shl	 eax, 6
  00033	03 41 18	 add	 eax, DWORD PTR [ecx+24]
  00036	89 45 f8	 mov	 DWORD PTR _pSlot$[ebp], eax

; 4031 : 
; 4032 : 	FirstAnimation = pSlot->IndexFirstAnim;

  00039	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0003c	0f b7 48 26	 movzx	 ecx, WORD PTR [eax+38]
  00040	89 4d ec	 mov	 DWORD PTR _FirstAnimation$[ebp], ecx

; 4033 : 
; 4034 : 	return AnimIndex + FirstAnimation;

  00043	8b 45 0c	 mov	 eax, DWORD PTR _AnimIndex$[ebp]
  00046	03 45 ec	 add	 eax, DWORD PTR _FirstAnimation$[ebp]

; 4035 : 
; 4036 : }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?GetAbsAnim@@YAHPAUStrItemTr4@@H@Z ENDP			; GetAbsAnim
_TEXT	ENDS
PUBLIC	?ConvertTombRoomIndex2NgleIndex@@YAHH@Z		; ConvertTombRoomIndex2NgleIndex
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ConvertTombRoomIndex2NgleIndex@@YAHH@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_RoomIndex$ = 8						; size = 4
?ConvertTombRoomIndex2NgleIndex@@YAHH@Z PROC		; ConvertTombRoomIndex2NgleIndex, COMDAT

; 4039 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4040 : 	int i;
; 4041 : 
; 4042 : 	for (i=0;i<MAX_ROOMS;i++) {

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@ConvertTom
$LN3@ConvertTom:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@ConvertTom:
  00030	81 7d f8 00 02
	00 00		 cmp	 DWORD PTR _i$[ebp], 512	; 00000200H
  00037	7d 1d		 jge	 SHORT $LN2@ConvertTom

; 4043 : 		if (Trng.pGlobTomb4->VetRemapRooms[i] == RoomIndex) return i;

  00039	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00042	0f bf 94 41 b1
	3b 01 00	 movsx	 edx, WORD PTR [ecx+eax*2+80817]
  0004a	3b 55 08	 cmp	 edx, DWORD PTR _RoomIndex$[ebp]
  0004d	75 05		 jne	 SHORT $LN1@ConvertTom
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00052	eb 05		 jmp	 SHORT $LN5@ConvertTom
$LN1@ConvertTom:

; 4044 : 	}

  00054	eb d1		 jmp	 SHORT $LN3@ConvertTom
$LN2@ConvertTom:

; 4045 : 
; 4046 : 	return -1;

  00056	83 c8 ff	 or	 eax, -1
$LN5@ConvertTom:

; 4047 : 
; 4048 : }

  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?ConvertTombRoomIndex2NgleIndex@@YAHH@Z ENDP		; ConvertTombRoomIndex2NgleIndex
_TEXT	ENDS
PUBLIC	??_C@_0DJ@ECJKDKJD@WARNING?3?5unknown?5CONV_?5value?5?$CI?$CFd@ ; `string'
PUBLIC	?Convert@@YAHHHHPAX@Z				; Convert
;	COMDAT ??_C@_0DJ@ECJKDKJD@WARNING?3?5unknown?5CONV_?5value?5?$CI?$CFd@
CONST	SEGMENT
??_C@_0DJ@ECJKDKJD@WARNING?3?5unknown?5CONV_?5value?5?$CI?$CFd@ DB 'WARNI'
	DB	'NG: unknown CONV_ value (%d) for Convert() function', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Convert@@YAHHHHPAX@Z
_TEXT	SEGMENT
tv64 = -244						; size = 4
_pAnim$ = -44						; size = 4
_pItem$ = -32						; size = 4
_StaticIndex$ = -20					; size = 4
_RoomIndex$ = -8					; size = 4
_CONV_Type$ = 8						; size = 4
_Index$ = 12						; size = 4
_SecondaryIndex$ = 16					; size = 4
_pPointer$ = 20						; size = 4
?Convert@@YAHHHHPAX@Z PROC				; Convert, COMDAT

; 4059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00012	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4060 : 	int RoomIndex;
; 4061 : 	int StaticIndex;
; 4062 : 	StrItemTr4 *pItem;
; 4063 : 	StrAnimationTr4 *pAnim;
; 4064 : 
; 4065 : 	switch (CONV_Type) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _CONV_Type$[ebp]
  00021	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00027	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0002d	83 e9 01	 sub	 ecx, 1
  00030	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  00036	83 bd 0c ff ff
	ff 0b		 cmp	 DWORD PTR tv64[ebp], 11	; 0000000bH
  0003d	0f 87 6d 01 00
	00		 ja	 $LN17@Convert
  00043	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  00049	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN25@Convert[edx*4]
$LN16@Convert:

; 4066 : 	case CONV_FrameIndexFromAbsToRelative:
; 4067 : 		pAnim = &Trng.pGlobTomb4->pAdr->pVetAnimations[SecondaryIndex];

  00050	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00055	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0005b	8b 55 10	 mov	 edx, DWORD PTR _SecondaryIndex$[ebp]
  0005e	6b d2 28	 imul	 edx, 40			; 00000028H
  00061	03 51 30	 add	 edx, DWORD PTR [ecx+48]
  00064	89 55 d4	 mov	 DWORD PTR _pAnim$[ebp], edx

; 4068 : 		if (Index < pAnim->FrameStart || Index > pAnim->FrameEnd) {

  00067	8b 45 d4	 mov	 eax, DWORD PTR _pAnim$[ebp]
  0006a	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  0006e	39 4d 0c	 cmp	 DWORD PTR _Index$[ebp], ecx
  00071	7c 0c		 jl	 SHORT $LN14@Convert
  00073	8b 45 d4	 mov	 eax, DWORD PTR _pAnim$[ebp]
  00076	0f b7 48 1a	 movzx	 ecx, WORD PTR [eax+26]
  0007a	39 4d 0c	 cmp	 DWORD PTR _Index$[ebp], ecx
  0007d	7e 08		 jle	 SHORT $LN15@Convert
$LN14@Convert:

; 4069 : 			return -1;

  0007f	83 c8 ff	 or	 eax, -1
  00082	e9 3d 01 00 00	 jmp	 $LN19@Convert
$LN15@Convert:

; 4070 : 		}
; 4071 : 		return Index - pAnim->FrameStart;

  00087	8b 45 d4	 mov	 eax, DWORD PTR _pAnim$[ebp]
  0008a	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00091	2b c1		 sub	 eax, ecx
  00093	e9 2c 01 00 00	 jmp	 $LN19@Convert
$LN13@Convert:

; 4072 : 	case CONV_FrameIndexFromRelativeToAbs:
; 4073 : 
; 4074 : 		pAnim = &Trng.pGlobTomb4->pAdr->pVetAnimations[SecondaryIndex];

  00098	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0009d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000a3	8b 55 10	 mov	 edx, DWORD PTR _SecondaryIndex$[ebp]
  000a6	6b d2 28	 imul	 edx, 40			; 00000028H
  000a9	03 51 30	 add	 edx, DWORD PTR [ecx+48]
  000ac	89 55 d4	 mov	 DWORD PTR _pAnim$[ebp], edx

; 4075 : 		return Index + pAnim->FrameStart;

  000af	8b 45 d4	 mov	 eax, DWORD PTR _pAnim$[ebp]
  000b2	0f b7 40 18	 movzx	 eax, WORD PTR [eax+24]
  000b6	03 45 0c	 add	 eax, DWORD PTR _Index$[ebp]
  000b9	e9 06 01 00 00	 jmp	 $LN19@Convert
$LN12@Convert:

; 4076 : 
; 4077 : 	case CONV_ItemIndexFromNgleToTomb:
; 4078 : 		return FromNgleIndexToTomb4Index(Index);

  000be	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  000c7	83 c4 04	 add	 esp, 4
  000ca	e9 f5 00 00 00	 jmp	 $LN19@Convert
$LN11@Convert:

; 4079 : 
; 4080 : 	case CONV_ItemIndexFromTombToNgle:
; 4081 : 		return FromTomb4IndexToNgleIndex(Index);

  000cf	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ?FromTomb4IndexToNgleIndex@@YAHH@Z ; FromTomb4IndexToNgleIndex
  000d8	83 c4 04	 add	 esp, 4
  000db	e9 e4 00 00 00	 jmp	 $LN19@Convert
$LN10@Convert:

; 4082 : 	
; 4083 : 	case CONV_StaticIndexFromNgleToTomb:
; 4084 : 		if (FromNgleStaticIndexToTomb4Indices(Index, &RoomIndex, &StaticIndex)==true) {

  000e0	8d 45 ec	 lea	 eax, DWORD PTR _StaticIndex$[ebp]
  000e3	50		 push	 eax
  000e4	8d 4d f8	 lea	 ecx, DWORD PTR _RoomIndex$[ebp]
  000e7	51		 push	 ecx
  000e8	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z ; FromNgleStaticIndexToTomb4Indices
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	0f b6 c0	 movzx	 eax, al
  000f7	83 f8 01	 cmp	 eax, 1
  000fa	75 10		 jne	 SHORT $LN9@Convert

; 4085 : 			* (int*) pPointer = StaticIndex;

  000fc	8b 45 14	 mov	 eax, DWORD PTR _pPointer$[ebp]
  000ff	8b 4d ec	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  00102	89 08		 mov	 DWORD PTR [eax], ecx

; 4086 : 			return RoomIndex;

  00104	8b 45 f8	 mov	 eax, DWORD PTR _RoomIndex$[ebp]
  00107	e9 b8 00 00 00	 jmp	 $LN19@Convert
$LN9@Convert:

; 4087 : 		}
; 4088 : 
; 4089 : 		return -1;

  0010c	83 c8 ff	 or	 eax, -1
  0010f	e9 b0 00 00 00	 jmp	 $LN19@Convert
$LN8@Convert:

; 4090 : 
; 4091 : 	case CONV_StaticIndexFromTombToNgle:
; 4092 : 		return FromStaticIndicesToNgleIndex(Index, SecondaryIndex);

  00114	8b 45 10	 mov	 eax, DWORD PTR _SecondaryIndex$[ebp]
  00117	50		 push	 eax
  00118	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 ?FromStaticIndicesToNgleIndex@@YAHHH@Z ; FromStaticIndicesToNgleIndex
  00121	83 c4 08	 add	 esp, 8
  00124	e9 9b 00 00 00	 jmp	 $LN19@Convert
$LN7@Convert:

; 4093 : 
; 4094 : 	case CONV_RectFromMicroUnitsToPixels:
; 4095 : 		ConvertMicroUnits((RECT*) pPointer);

  00129	8b 45 14	 mov	 eax, DWORD PTR _pPointer$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 ?ConvertMicroUnits@@YAXPAUtagRECT@@@Z ; ConvertMicroUnits
  00132	83 c4 04	 add	 esp, 4

; 4096 : 		return 1;

  00135	b8 01 00 00 00	 mov	 eax, 1
  0013a	e9 85 00 00 00	 jmp	 $LN19@Convert
$LN6@Convert:

; 4097 : 
; 4098 : 	case CONV_AnimIndexFromRelativeToAbs:
; 4099 : 		pItem = (StrItemTr4 *) pPointer;

  0013f	8b 45 14	 mov	 eax, DWORD PTR _pPointer$[ebp]
  00142	89 45 e0	 mov	 DWORD PTR _pItem$[ebp], eax

; 4100 : 		return GetAbsAnim(pItem, Index);

  00145	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00148	50		 push	 eax
  00149	8b 4d e0	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0014c	51		 push	 ecx
  0014d	e8 00 00 00 00	 call	 ?GetAbsAnim@@YAHPAUStrItemTr4@@H@Z ; GetAbsAnim
  00152	83 c4 08	 add	 esp, 8
  00155	eb 6d		 jmp	 SHORT $LN19@Convert
$LN5@Convert:

; 4101 : 
; 4102 : 	case CONV_AnimIndexFromAbsToRelative:
; 4103 : 		pItem = (StrItemTr4 *) pPointer;

  00157	8b 45 14	 mov	 eax, DWORD PTR _pPointer$[ebp]
  0015a	89 45 e0	 mov	 DWORD PTR _pItem$[ebp], eax

; 4104 : 		return GetRelAnim( pItem, Index);

  0015d	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00160	50		 push	 eax
  00161	8b 4d e0	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 ?GetRelAnim@@YAHPAUStrItemTr4@@H@Z ; GetRelAnim
  0016a	83 c4 08	 add	 esp, 8
  0016d	eb 55		 jmp	 SHORT $LN19@Convert
$LN4@Convert:

; 4105 : 
; 4106 : 	case CONV_ItemFromStrItemTr4ToIndex:
; 4107 : 		return ConvertFromStrItemToItemIndex((StrItemTr4 *) pPointer);

  0016f	8b 45 14	 mov	 eax, DWORD PTR _pPointer$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ?ConvertFromStrItemToItemIndex@@YAHPAUStrItemTr4@@@Z ; ConvertFromStrItemToItemIndex
  00178	83 c4 04	 add	 esp, 4
  0017b	eb 47		 jmp	 SHORT $LN19@Convert
$LN3@Convert:

; 4108 : 
; 4109 : 	case CONV_RoomIndexFromNgleToTomb:
; 4110 : 		RoomIndex = Trng.pGlobTomb4->VetRemapRooms[Index];

  0017d	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00180	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00186	0f bf 94 41 b1
	3b 01 00	 movsx	 edx, WORD PTR [ecx+eax*2+80817]
  0018e	89 55 f8	 mov	 DWORD PTR _RoomIndex$[ebp], edx

; 4111 : 		if (RoomIndex == -1) RoomIndex = Index;

  00191	83 7d f8 ff	 cmp	 DWORD PTR _RoomIndex$[ebp], -1
  00195	75 06		 jne	 SHORT $LN2@Convert
  00197	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0019a	89 45 f8	 mov	 DWORD PTR _RoomIndex$[ebp], eax
$LN2@Convert:

; 4112 : 		return RoomIndex;

  0019d	8b 45 f8	 mov	 eax, DWORD PTR _RoomIndex$[ebp]
  001a0	eb 22		 jmp	 SHORT $LN19@Convert
$LN1@Convert:

; 4113 : 	case CONV_RoomIndexFromTombToNgle:
; 4114 : 		return ConvertTombRoomIndex2NgleIndex(Index);

  001a2	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  001a5	50		 push	 eax
  001a6	e8 00 00 00 00	 call	 ?ConvertTombRoomIndex2NgleIndex@@YAHH@Z ; ConvertTombRoomIndex2NgleIndex
  001ab	83 c4 04	 add	 esp, 4
  001ae	eb 14		 jmp	 SHORT $LN19@Convert
$LN17@Convert:

; 4115 : 
; 4116 : 	}
; 4117 : 
; 4118 : 	SendToLog("WARNING: unknown CONV_ value (%d) for Convert() function", CONV_Type);

  001b0	8b 45 08	 mov	 eax, DWORD PTR _CONV_Type$[ebp]
  001b3	50		 push	 eax
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0DJ@ECJKDKJD@WARNING?3?5unknown?5CONV_?5value?5?$CI?$CFd@
  001b9	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  001be	83 c4 08	 add	 esp, 8

; 4119 : 	return -1;			

  001c1	83 c8 ff	 or	 eax, -1
$LN19@Convert:

; 4120 : }

  001c4	52		 push	 edx
  001c5	8b cd		 mov	 ecx, ebp
  001c7	50		 push	 eax
  001c8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@Convert
  001ce	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001d3	58		 pop	 eax
  001d4	5a		 pop	 edx
  001d5	5f		 pop	 edi
  001d6	5e		 pop	 esi
  001d7	5b		 pop	 ebx
  001d8	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  001de	3b ec		 cmp	 ebp, esp
  001e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
  001e9	8d 49 00	 npad	 3
$LN24@Convert:
  001ec	02 00 00 00	 DD	 2
  001f0	00 00 00 00	 DD	 $LN23@Convert
$LN23@Convert:
  001f4	f8 ff ff ff	 DD	 -8			; fffffff8H
  001f8	04 00 00 00	 DD	 4
  001fc	00 00 00 00	 DD	 $LN21@Convert
  00200	ec ff ff ff	 DD	 -20			; ffffffecH
  00204	04 00 00 00	 DD	 4
  00208	00 00 00 00	 DD	 $LN22@Convert
$LN22@Convert:
  0020c	53		 DB	 83			; 00000053H
  0020d	74		 DB	 116			; 00000074H
  0020e	61		 DB	 97			; 00000061H
  0020f	74		 DB	 116			; 00000074H
  00210	69		 DB	 105			; 00000069H
  00211	63		 DB	 99			; 00000063H
  00212	49		 DB	 73			; 00000049H
  00213	6e		 DB	 110			; 0000006eH
  00214	64		 DB	 100			; 00000064H
  00215	65		 DB	 101			; 00000065H
  00216	78		 DB	 120			; 00000078H
  00217	00		 DB	 0
$LN21@Convert:
  00218	52		 DB	 82			; 00000052H
  00219	6f		 DB	 111			; 0000006fH
  0021a	6f		 DB	 111			; 0000006fH
  0021b	6d		 DB	 109			; 0000006dH
  0021c	49		 DB	 73			; 00000049H
  0021d	6e		 DB	 110			; 0000006eH
  0021e	64		 DB	 100			; 00000064H
  0021f	65		 DB	 101			; 00000065H
  00220	78		 DB	 120			; 00000078H
  00221	00		 DB	 0
  00222	8b ff		 npad	 2
$LN25@Convert:
  00224	00 00 00 00	 DD	 $LN12@Convert
  00228	00 00 00 00	 DD	 $LN11@Convert
  0022c	00 00 00 00	 DD	 $LN10@Convert
  00230	00 00 00 00	 DD	 $LN8@Convert
  00234	00 00 00 00	 DD	 $LN7@Convert
  00238	00 00 00 00	 DD	 $LN6@Convert
  0023c	00 00 00 00	 DD	 $LN5@Convert
  00240	00 00 00 00	 DD	 $LN4@Convert
  00244	00 00 00 00	 DD	 $LN3@Convert
  00248	00 00 00 00	 DD	 $LN1@Convert
  0024c	00 00 00 00	 DD	 $LN16@Convert
  00250	00 00 00 00	 DD	 $LN13@Convert
?Convert@@YAHHHHPAX@Z ENDP				; Convert
_TEXT	ENDS
PUBLIC	??_C@_0DI@DEBNJFPA@ERROR?3?5unknown?5meaning?5of?5GET_?5c@ ; `string'
PUBLIC	??_C@_0EN@GIKIANME@ERROR?3?5Get?$CIGET_SLOT?$CJ?5Invalid?5ind@ ; `string'
PUBLIC	??_C@_0EO@OCOFIECI@ERROR?3?5Get?$CIGET_CAMERA_FLY?$CJ?0?5inva@ ; `string'
PUBLIC	??_C@_0EK@DFOFGCKG@ERROR?3?5Get?$CIGET_CAMERA?$CJ?0?5invalid?5@ ; `string'
PUBLIC	??_C@_0FB@NIKDIKMG@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5Se@ ; `string'
PUBLIC	??_C@_0EN@IINEOOAJ@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5ro@ ; `string'
PUBLIC	??_C@_0EK@GOOBMJEN@ERROR?3?5Get?$CIGET_AI_ITEM?$CJ?5invalid?5@ ; `string'
PUBLIC	??_C@_0FM@KHLDPOBM@ERROR?3?5Get?$CIGET_BIG_NUMBER?$CJ?5inval@ ; `string'
PUBLIC	??_C@_0EA@IEIDMNEG@WARNING?3?5not?5found?5my?5CUSTOMIZE?5@ ; `string'
PUBLIC	??_C@_0EI@CNKPJEBI@ERROR?3?5not?5found?5my?5PARAMETERS?5o@ ; `string'
PUBLIC	??_C@_0FE@CGMNPFNF@ERROR?3?5Get?$CIGET_DOOR_OF_ROOM?$CJ?5inv@ ; `string'
PUBLIC	??_C@_0FO@LCPLCGCJ@ERROR?3?5Get?$CIGET_STATIC_COLL?1VIEW_@ ; `string'
PUBLIC	??_C@_0FN@HCAHGEMN@ERROR?3?5Get?$CIGET_STATIC_COLL?1?1VIEW@ ; `string'
PUBLIC	??_C@_0FA@KOJKINJA@ERROR?3?5Get?$CIGET_COLL_BOX?$CJ?5invalid@ ; `string'
PUBLIC	??_C@_0P@MLPNHJIJ@Get?$CI?$CJ?5function?$AA@	; `string'
PUBLIC	??_C@_0EH@KLJPBKDN@ERROR?3?5Get?$CIGET_ROOM?$CJ?5invalid?5ind@ ; `string'
PUBLIC	??_C@_0FA@OLEPCMLI@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5s@ ; `string'
PUBLIC	??_C@_0EO@LBHMNKCM@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5r@ ; `string'
PUBLIC	??_C@_0EM@KFPEOBDF@ERROR?3?5Get?$CIGET_ITEM?$CJ?5invalid?5ite@ ; `string'
PUBLIC	?Get@@YA_NHHH@Z					; Get
_BSS	SEGMENT
?BsSelIndex@?1??Get@@YA_NHHH@Z@4UStrMemSelItems@@A DB 010H DUP (?) ; `Get'::`2'::BsSelIndex
?BsFlipMaps@?1??Get@@YA_NHHH@Z@4UStrFlipMap@@A DB 010H DUP (?) ; `Get'::`2'::BsFlipMaps
_BSS	ENDS
;	COMDAT ??_C@_0DI@DEBNJFPA@ERROR?3?5unknown?5meaning?5of?5GET_?5c@
CONST	SEGMENT
??_C@_0DI@DEBNJFPA@ERROR?3?5unknown?5meaning?5of?5GET_?5c@ DB 'ERROR: unk'
	DB	'nown meaning of GET_ constant with value = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@GIKIANME@ERROR?3?5Get?$CIGET_SLOT?$CJ?5Invalid?5ind@
CONST	SEGMENT
??_C@_0EN@GIKIANME@ERROR?3?5Get?$CIGET_SLOT?$CJ?5Invalid?5ind@ DB 'ERROR:'
	DB	' Get(GET_SLOT) Invalid index value (%d), outside of valid ran'
	DB	'ge 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@OCOFIECI@ERROR?3?5Get?$CIGET_CAMERA_FLY?$CJ?0?5inva@
CONST	SEGMENT
??_C@_0EO@OCOFIECI@ERROR?3?5Get?$CIGET_CAMERA_FLY?$CJ?0?5inva@ DB 'ERROR:'
	DB	' Get(GET_CAMERA_FLY), invalid index (%d), outside of valid ra'
	DB	'nge 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DFOFGCKG@ERROR?3?5Get?$CIGET_CAMERA?$CJ?0?5invalid?5@
CONST	SEGMENT
??_C@_0EK@DFOFGCKG@ERROR?3?5Get?$CIGET_CAMERA?$CJ?0?5invalid?5@ DB 'ERROR'
	DB	': Get(GET_CAMERA), invalid index (%d), outside of valid range'
	DB	' 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@NIKDIKMG@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5Se@
CONST	SEGMENT
??_C@_0FB@NIKDIKMG@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5Se@ DB 'ERROR:'
	DB	' Get(GET_LIGHT) invalid SecondaryIndex (%d), outside of valid'
	DB	' range 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@IINEOOAJ@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5ro@
CONST	SEGMENT
??_C@_0EN@IINEOOAJ@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5ro@ DB 'ERROR:'
	DB	' Get(GET_LIGHT) invalid room index (%d), outside of valid ran'
	DB	'ge 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@GOOBMJEN@ERROR?3?5Get?$CIGET_AI_ITEM?$CJ?5invalid?5@
CONST	SEGMENT
??_C@_0EK@GOOBMJEN@ERROR?3?5Get?$CIGET_AI_ITEM?$CJ?5invalid?5@ DB 'ERROR:'
	DB	' Get(GET_AI_ITEM) invalid index (%d), outside of valid range '
	DB	'0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FM@KHLDPOBM@ERROR?3?5Get?$CIGET_BIG_NUMBER?$CJ?5inval@
CONST	SEGMENT
??_C@_0FM@KHLDPOBM@ERROR?3?5Get?$CIGET_BIG_NUMBER?$CJ?5inval@ DB 'ERROR: '
	DB	'Get(GET_BIG_NUMBER) invalid index (%d) for big number, outsid'
	DB	'e of valid range 0 - %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@IEIDMNEG@WARNING?3?5not?5found?5my?5CUSTOMIZE?5@
CONST	SEGMENT
??_C@_0EA@IEIDMNEG@WARNING?3?5not?5found?5my?5CUSTOMIZE?5@ DB 'WARNING: n'
	DB	'ot found my CUSTOMIZE with CUST_ value=%d and ID = %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@CNKPJEBI@ERROR?3?5not?5found?5my?5PARAMETERS?5o@
CONST	SEGMENT
??_C@_0EI@CNKPJEBI@ERROR?3?5not?5found?5my?5PARAMETERS?5o@ DB 'ERROR: not'
	DB	' found my PARAMETERS of PARAM_ type %d with (further) ID = %d'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@CGMNPFNF@ERROR?3?5Get?$CIGET_DOOR_OF_ROOM?$CJ?5inv@
CONST	SEGMENT
??_C@_0FE@CGMNPFNF@ERROR?3?5Get?$CIGET_DOOR_OF_ROOM?$CJ?5inv@ DB 'ERROR: '
	DB	'Get(GET_DOOR_OF_ROOM) invalid door index (%d), outside of val'
	DB	'id range 0 - %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@LCPLCGCJ@ERROR?3?5Get?$CIGET_STATIC_COLL?1VIEW_@
CONST	SEGMENT
??_C@_0FO@LCPLCGCJ@ERROR?3?5Get?$CIGET_STATIC_COLL?1VIEW_@ DB 'ERROR: Get'
	DB	'(GET_STATIC_COLL/VIEW_BOX) Invalid static index (%d), outside'
	DB	' of valid range 0 - %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@HCAHGEMN@ERROR?3?5Get?$CIGET_STATIC_COLL?1?1VIEW@
CONST	SEGMENT
??_C@_0FN@HCAHGEMN@ERROR?3?5Get?$CIGET_STATIC_COLL?1?1VIEW@ DB 'ERROR: Ge'
	DB	't(GET_STATIC_COLL//VIEW_BOX) Invalid room index (%d), outside'
	DB	' of valid range 0 - %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KOJKINJA@ERROR?3?5Get?$CIGET_COLL_BOX?$CJ?5invalid@
CONST	SEGMENT
??_C@_0FA@KOJKINJA@ERROR?3?5Get?$CIGET_COLL_BOX?$CJ?5invalid@ DB 'ERROR: '
	DB	'Get(GET_COLL_BOX) invalid item index (%d), outside of valid r'
	DB	'ange 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MLPNHJIJ@Get?$CI?$CJ?5function?$AA@
CONST	SEGMENT
??_C@_0P@MLPNHJIJ@Get?$CI?$CJ?5function?$AA@ DB 'Get() function', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KLJPBKDN@ERROR?3?5Get?$CIGET_ROOM?$CJ?5invalid?5ind@
CONST	SEGMENT
??_C@_0EH@KLJPBKDN@ERROR?3?5Get?$CIGET_ROOM?$CJ?5invalid?5ind@ DB 'ERROR:'
	DB	' Get(GET_ROOM) invalid index (%d), outside of valid range 0 -'
	DB	' %d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@OLEPCMLI@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5s@
CONST	SEGMENT
??_C@_0FA@OLEPCMLI@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5s@ DB 'ERROR:'
	DB	' Get(GET_STATIC) Invalid static index (%d), outside of valid '
	DB	'range 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@LBHMNKCM@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5r@
CONST	SEGMENT
??_C@_0EO@LBHMNKCM@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5r@ DB 'ERROR:'
	DB	' Get(GET_STATIC) Invalid room index (%d), outside of valid ra'
	DB	'nge 0 - %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@KFPEOBDF@ERROR?3?5Get?$CIGET_ITEM?$CJ?5invalid?5ite@
CONST	SEGMENT
??_C@_0EM@KFPEOBDF@ERROR?3?5Get?$CIGET_ITEM?$CJ?5invalid?5ite@ DB 'ERROR:'
	DB	' Get(GET_ITEM) invalid item index (%d), outside of valid rang'
	DB	'e 0 - %d', 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Get@@YA_NHHH@Z
_TEXT	SEGMENT
tv162 = -460						; size = 4
tv64 = -460						; size = 4
$T47250 = -449						; size = 1
$T47251 = -437						; size = 1
_pScript$ = -236					; size = 4
_pMeshRightHand$ = -224					; size = 4
_i$ = -212						; size = 4
_Slot$ = -200						; size = 2
_pParam$ = -188						; size = 4
_pCust$ = -176						; size = 4
_StateId$ = -164					; size = 2
_MeshIndex$ = -152					; size = 4
_z$ = -140						; size = 4
_Flags$ = -128						; size = 2
_pSlot$ = -116						; size = 4
_pLara$ = -104						; size = 4
_pInfo$ = -92						; size = 4
_TestConvert$ = -77					; size = 1
_pGame$ = -68						; size = 4
_pStatic$ = -56						; size = 4
_pItem$ = -44						; size = 4
_StaticIndex$ = -32					; size = 4
_RoomIndex$ = -20					; size = 4
_TombIndex$ = -8					; size = 4
_GET_Type$ = 8						; size = 4
_Index$ = 12						; size = 4
_SecondaryIndex$ = 16					; size = 4
?Get@@YA_NHHH@Z PROC					; Get, COMDAT

; 4127 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-460]
  00012	b9 73 00 00 00	 mov	 ecx, 115		; 00000073H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 3f fe ff
	ff 00		 mov	 BYTE PTR $T47250[ebp], 0
  00025	c6 85 4b fe ff
	ff 00		 mov	 BYTE PTR $T47251[ebp], 0

; 4128 : 
; 4129 : 	int TombIndex;
; 4130 : 	int RoomIndex;
; 4131 : 	int StaticIndex;
; 4132 : 	StrItemTr4 *pItem;
; 4133 : 	StrMeshInfo *pStatic;
; 4134 : 	StrGameInfo *pGame;
; 4135 : 	bool TestConvert;
; 4136 : 	StrLaraInfo *pInfo;
; 4137 : 	StrItemTr4 *pLara;
; 4138 : 	StrSlot *pSlot;
; 4139 : 	WORD Flags;
; 4140 : 	int z;
; 4141 : 	int MeshIndex;
; 4142 : 	WORD StateId;
; 4143 : 	StrGenericCustomize *pCust;
; 4144 : 	StrGenericParameters *pParam;
; 4145 : 	WORD Slot;
; 4146 : 	int i;
; 4147 : 	StrMeshTr4 *pMeshRightHand;
; 4148 : 	StrScriptSettings *pScript;
; 4149 : 	static StrMemSelItems BsSelIndex;
; 4150 : 	static StrFlipMap BsFlipMaps;
; 4151 : 
; 4152 : 
; 4153 : 	switch (GET_Type) {

  0002c	8b 45 08	 mov	 eax, DWORD PTR _GET_Type$[ebp]
  0002f	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00035	83 bd 34 fe ff
	ff 1c		 cmp	 DWORD PTR tv64[ebp], 28	; 0000001cH
  0003c	0f 87 7b 16 00
	00		 ja	 $LN1@Get
  00042	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  00048	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN174@Get[ecx*4]
$LN154@Get:

; 4154 : 	case GET_FLIPMAPS:
; 4155 : 		// fill BsFlipMaps structure with flipmap data
; 4156 : 		BsFlipMaps.pVetButtonFlipMaps = Trng.pGlobTomb4->pAdr->Remap.pVetButtonFlipMaps;

  0004f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00054	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0005a	8b 91 08 01 00
	00		 mov	 edx, DWORD PTR [ecx+264]
  00060	89 15 04 00 00
	00		 mov	 DWORD PTR ?BsFlipMaps@?1??Get@@YA_NHHH@Z@4UStrFlipMap@@A+4, edx

; 4157 : 		BsFlipMaps.pVetEnabledFlipMaps = Trng.pGlobTomb4->pAdr->Remap.pVetEnabledFlipMaps;

  00066	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0006b	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00071	8b 91 04 01 00
	00		 mov	 edx, DWORD PTR [ecx+260]
  00077	89 15 00 00 00
	00		 mov	 DWORD PTR ?BsFlipMaps@?1??Get@@YA_NHHH@Z@4UStrFlipMap@@A, edx

; 4158 : 		BsFlipMaps.pVetFlipRooms = &Trng.pGlobTomb4->FlipMapRooms.VetRoomMain[0];

  0007d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00082	05 6f ed 09 00	 add	 eax, 650607		; 0009ed6fH
  00087	a3 0c 00 00 00	 mov	 DWORD PTR ?BsFlipMaps@?1??Get@@YA_NHHH@Z@4UStrFlipMap@@A+12, eax

; 4159 : 		BsFlipMaps.TotFlipRooms = Trng.pGlobTomb4->FlipMapRooms.TotFlipRooms;

  0008c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00091	8b 88 6b ed 09
	00		 mov	 ecx, DWORD PTR [eax+650603]
  00097	89 0d 08 00 00
	00		 mov	 DWORD PTR ?BsFlipMaps@?1??Get@@YA_NHHH@Z@4UStrFlipMap@@A+8, ecx

; 4160 : 		// link the pointer of BsFlipMaps to Get.pFlipMap field
; 4161 : 		GET.pFlipMap = &BsFlipMaps;

  0009d	c7 05 50 02 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+592, OFFSET ?BsFlipMaps@?1??Get@@YA_NHHH@Z@4UStrFlipMap@@A

; 4162 : 		return true;

  000a7	b0 01		 mov	 al, 1
  000a9	e9 26 16 00 00	 jmp	 $LN157@Get
$LN153@Get:

; 4163 : 		
; 4164 : 	case GET_VARIABLES:
; 4165 : 		GET.Vars.pMemorySelected = &BsSelIndex;

  000ae	c7 05 a8 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+424, OFFSET ?BsSelIndex@?1??Get@@YA_NHHH@Z@4UStrMemSelItems@@A

; 4166 : 		GET.Vars.pMemorySelected->pAnimationSelected = &Trng.pGlobTomb4->CurrentInventoryIndex;

  000b8	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000bd	05 2c 2c 1a 00	 add	 eax, 1715244		; 001a2c2cH
  000c2	8b 0d a8 01 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+424
  000c8	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 4167 : 		GET.Vars.pMemorySelected->pItemSelected = &Trng.pGlobTomb4->ItemIndexSelected;

  000cb	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000d0	05 24 2c 1a 00	 add	 eax, 1715236		; 001a2c24H
  000d5	8b 0d a8 01 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+424
  000db	89 01		 mov	 DWORD PTR [ecx], eax

; 4168 : 		GET.Vars.pMemorySelected->pIventorySelected = &Trng.pGlobTomb4->CurrentInventoryIndex;

  000dd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000e2	05 2c 2c 1a 00	 add	 eax, 1715244		; 001a2c2cH
  000e7	8b 0d a8 01 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+424
  000ed	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 4169 : 		GET.Vars.pMemorySelected->pSlotSelected = &Trng.pGlobTomb4->CurrentSlotIndex;

  000f0	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000f5	05 28 2c 1a 00	 add	 eax, 1715240		; 001a2c28H
  000fa	8b 0d a8 01 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+424
  00100	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4170 : 		GET.Vars.pTrngVars = Trng.pGlobTomb4->pBaseVariableTRNG;

  00103	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00108	8b 88 8a 02 01
	00		 mov	 ecx, DWORD PTR [eax+66186]
  0010e	89 0d ac 01 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+428, ecx

; 4171 : 
; 4172 : 		return true;

  00114	b0 01		 mov	 al, 1
  00116	e9 b9 15 00 00	 jmp	 $LN157@Get
$LN152@Get:

; 4173 : 
; 4174 : 	case GET_INFO_ITEM:
; 4175 : 		if (Index & NGLE_INDEX) {

  0011b	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0011e	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00123	74 2d		 je	 SHORT $LN151@Get

; 4176 : 			Index &= MASK_NGLE_INDEX;

  00125	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00128	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0012d	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4177 : 			TombIndex=FromNgleIndexToTomb4Index(Index);

  00130	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  00139	83 c4 04	 add	 esp, 4
  0013c	89 45 f8	 mov	 DWORD PTR _TombIndex$[ebp], eax

; 4178 : 			if (TombIndex==-1) return false;

  0013f	83 7d f8 ff	 cmp	 DWORD PTR _TombIndex$[ebp], -1
  00143	75 07		 jne	 SHORT $LN150@Get
  00145	32 c0		 xor	 al, al
  00147	e9 88 15 00 00	 jmp	 $LN157@Get
$LN150@Get:

; 4179 : 			Index= TombIndex;

  0014c	8b 45 f8	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  0014f	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax
$LN151@Get:

; 4180 : 		}
; 4181 : 		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[Index];

  00152	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00157	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0015d	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  00160	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00166	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00169	89 55 d4	 mov	 DWORD PTR _pItem$[ebp], edx

; 4182 : 		GET.InfoItem.TestCreature=false;

  0016c	c6 05 f9 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+249, 0

; 4183 : 		GET.InfoItem.TestEnabled =false;

  00173	c6 05 f6 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+246, 0

; 4184 : 		GET.InfoItem.TestSemiGod=false;

  0017a	c6 05 f7 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+247, 0

; 4185 : 		GET.InfoItem.TestDoor=false;

  00181	c6 05 fb 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+251, 0

; 4186 : 		GET.InfoItem.TestOnlyExplode=false;

  00188	c6 05 f8 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+248, 0

; 4187 : 
; 4188 : 
; 4189 : 		// is it a creature?
; 4190 : 		Slot=pItem->SlotID;

  0018f	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00192	66 8b 48 0c	 mov	 cx, WORD PTR [eax+12]
  00196	66 89 8d 38 ff
	ff ff		 mov	 WORD PTR _Slot$[ebp], cx

; 4191 : 		pSlot=&Trng.pGlobTomb4->pAdr->pVetSlot[Slot];

  0019d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  001a2	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  001a8	0f b7 95 38 ff
	ff ff		 movzx	 edx, WORD PTR _Slot$[ebp]
  001af	c1 e2 06	 shl	 edx, 6
  001b2	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  001b5	89 55 8c	 mov	 DWORD PTR _pSlot$[ebp], edx

; 4192 : 		if (pSlot->Flags & enumFSLOT.AI_STANDARD) {

  001b8	8b 45 8c	 mov	 eax, DWORD PTR _pSlot$[ebp]
  001bb	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  001bf	23 0d 08 00 00
	00		 and	 ecx, DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+8
  001c5	74 5a		 je	 SHORT $LN149@Get

; 4193 : 			GET.InfoItem.TestCreature =true;

  001c7	c6 05 f9 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+249, 1

; 4194 : 			// is it enabled?
; 4195 : 			if ((pItem->Objectbuttons & 0x8000)==0 && 
; 4196 : 				(pItem->FlagsMain & 0x06) != 0x06) {

  001ce	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  001d1	0f b7 48 28	 movzx	 ecx, WORD PTR [eax+40]
  001d5	81 e1 00 80 00
	00		 and	 ecx, 32768		; 00008000H
  001db	75 18		 jne	 SHORT $LN148@Get
  001dd	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  001e0	8b 88 ea 15 00
	00		 mov	 ecx, DWORD PTR [eax+5610]
  001e6	83 e1 06	 and	 ecx, 6
  001e9	83 f9 06	 cmp	 ecx, 6
  001ec	74 07		 je	 SHORT $LN148@Get

; 4197 : 				GET.InfoItem.TestEnabled =true;

  001ee	c6 05 f6 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+246, 1
$LN148@Get:

; 4198 : 			}
; 4199 : 			// is it semigod?
; 4200 : 			if (pSlot->Vitality == (short) 0xC000) {

  001f5	8b 45 8c	 mov	 eax, DWORD PTR _pSlot$[ebp]
  001f8	0f bf 48 28	 movsx	 ecx, WORD PTR [eax+40]
  001fc	81 f9 00 c0 ff
	ff		 cmp	 ecx, -16384		; ffffc000H
  00202	75 07		 jne	 SHORT $LN147@Get

; 4201 : 				GET.InfoItem.TestSemiGod=true;

  00204	c6 05 f7 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+247, 1
$LN147@Get:

; 4202 : 			}
; 4203 : 			// is it killable only with explosive ammo?
; 4204 : 			if (pSlot->Flags & NEF_ONLY_EXPLODE) {

  0020b	8b 45 8c	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0020e	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  00212	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00218	74 07		 je	 SHORT $LN149@Get

; 4205 : 				GET.InfoItem.TestOnlyExplode=true;

  0021a	c6 05 f8 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+248, 1
$LN149@Get:

; 4206 : 			}
; 4207 : 
; 4208 : 		}
; 4209 : 		// is it a door?
; 4210 : 		if ((Slot >= 122 && Slot <= 129) ||
; 4211 : 			(Slot >= 322 && Slot <= 335)) {

  00221	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00228	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  0022b	7c 0e		 jl	 SHORT $LN143@Get
  0022d	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00234	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  00239	7e 1c		 jle	 SHORT $LN144@Get
$LN143@Get:
  0023b	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00242	3d 42 01 00 00	 cmp	 eax, 322		; 00000142H
  00247	7c 30		 jl	 SHORT $LN145@Get
  00249	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00250	3d 4f 01 00 00	 cmp	 eax, 335		; 0000014fH
  00255	7f 22		 jg	 SHORT $LN145@Get
$LN144@Get:

; 4212 : 			GET.InfoItem.TestDoor=true;

  00257	c6 05 fb 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+251, 1

; 4213 : 			// is it open or close?
; 4214 : 			if (pItem->StateIdCurrent == 0) {

  0025e	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00261	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00265	85 c9		 test	 ecx, ecx
  00267	75 09		 jne	 SHORT $LN142@Get

; 4215 : 				GET.InfoItem.TestEnabled =false;

  00269	c6 05 f6 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+246, 0

; 4216 : 			}else {

  00270	eb 07		 jmp	 SHORT $LN145@Get
$LN142@Get:

; 4217 : 				GET.InfoItem.TestEnabled=true;

  00272	c6 05 f6 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+246, 1
$LN145@Get:

; 4218 : 			}
; 4219 : 		}
; 4220 : 		
; 4221 : 		// are there collisions?
; 4222 : 		// by default, yes there are, but now we see special kind of objects:
; 4223 : 		GET.InfoItem.TestCollisions=true;

  00279	c6 05 fa 00 00
	00 01		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+250, 1

; 4224 : 
; 4225 : 		switch (Slot) {

  00280	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00287	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv162[ebp], eax
  0028d	81 bd 34 fe ff
	ff 91 00 00 00	 cmp	 DWORD PTR tv162[ebp], 145 ; 00000091H
  00297	7f 29		 jg	 SHORT $LN159@Get
  00299	81 bd 34 fe ff
	ff 8e 00 00 00	 cmp	 DWORD PTR tv162[ebp], 142 ; 0000008eH
  002a3	7d 37		 jge	 SHORT $LN138@Get
  002a5	83 bd 34 fe ff
	ff 56		 cmp	 DWORD PTR tv162[ebp], 86 ; 00000056H
  002ac	7c 37		 jl	 SHORT $LN137@Get
  002ae	83 bd 34 fe ff
	ff 59		 cmp	 DWORD PTR tv162[ebp], 89 ; 00000059H
  002b5	7e 25		 jle	 SHORT $LN138@Get
  002b7	83 bd 34 fe ff
	ff 73		 cmp	 DWORD PTR tv162[ebp], 115 ; 00000073H
  002be	74 1c		 je	 SHORT $LN138@Get
  002c0	eb 23		 jmp	 SHORT $LN137@Get
$LN159@Get:
  002c2	81 bd 34 fe ff
	ff 7c 01 00 00	 cmp	 DWORD PTR tv162[ebp], 380 ; 0000017cH
  002cc	7c 17		 jl	 SHORT $LN137@Get
  002ce	81 bd 34 fe ff
	ff 81 01 00 00	 cmp	 DWORD PTR tv162[ebp], 385 ; 00000181H
  002d8	7e 02		 jle	 SHORT $LN138@Get
  002da	eb 09		 jmp	 SHORT $LN137@Get
$LN138@Get:

; 4226 : 		case 86:  // WRAITH1
; 4227 : 		case 87:  // WRAITH2
; 4228 : 		case 88:  // WRAITH3
; 4229 : 		case 89:  // WRAITH4
; 4230 : 		case 115:  // DART_EMITTER
; 4231 : 		case 142:  // FLAME
; 4232 : 		case 143: // FLAME_EMITTER
; 4233 : 		case 144:  // FLAME_EMITTER2
; 4234 : 		case 145:  // FLAME_EMITTER3
; 4235 : 		case 380: // SMOKE_EMITTER_WHITE
; 4236 : 		case 381: // SMOKE_EMITTER_BLACK
; 4237 : 		case 382: // STEAM_EMITTER
; 4238 : 		case 383: // EARTHQUAKE
; 4239 : 		case 384: // BUBBLES
; 4240 : 		case 385: // WATERFALLMIST
; 4241 : 			GET.InfoItem.TestCollisions=false;

  002dc	c6 05 fa 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+250, 0

; 4242 : 			break;

  002e3	eb 31		 jmp	 SHORT $LN139@Get
$LN137@Get:

; 4243 : 		default:
; 4244 : 			// all other items:
; 4245 : 			if (GET.InfoItem.TestDoor==true && GET.InfoItem.TestEnabled == true) {

  002e5	0f b6 05 fb 00
	00 00		 movzx	 eax, BYTE PTR ?GET@@3UStrGetLocator@@A+251
  002ec	83 f8 01	 cmp	 eax, 1
  002ef	75 15		 jne	 SHORT $LN136@Get
  002f1	0f b6 05 f6 00
	00 00		 movzx	 eax, BYTE PTR ?GET@@3UStrGetLocator@@A+246
  002f8	83 f8 01	 cmp	 eax, 1
  002fb	75 09		 jne	 SHORT $LN136@Get

; 4246 : 				// it is a door and it is open: no collisions
; 4247 : 				GET.InfoItem.TestCollisions=false;

  002fd	c6 05 fa 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+250, 0

; 4248 : 			}else {

  00304	eb 10		 jmp	 SHORT $LN139@Get
$LN136@Get:

; 4249 : 				// for other items, verify with collision procedure
; 4250 : 				if (pSlot->pProcCollision == NULL) {

  00306	8b 45 8c	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00309	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0030d	75 07		 jne	 SHORT $LN139@Get

; 4251 : 					// missing collision procedure: no collision
; 4252 : 					GET.InfoItem.TestCollisions=false;

  0030f	c6 05 fa 00 00
	00 00		 mov	 BYTE PTR ?GET@@3UStrGetLocator@@A+250, 0
$LN139@Get:

; 4253 : 				}
; 4254 : 			}
; 4255 : 			break;
; 4256 : 		}
; 4257 : 
; 4258 : 
; 4259 : 		break;

  00316	e9 b7 13 00 00	 jmp	 $LN155@Get
$LN133@Get:

; 4260 : 
; 4261 : 	case GET_LARA:
; 4262 : 		GET.pLara = Trng.pGlobTomb4->pAdr->pLara;

  0031b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00320	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00326	8b 11		 mov	 edx, DWORD PTR [ecx]
  00328	89 15 00 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A, edx

; 4263 : 		GET.LaraIndex = *Trng.pGlobTomb4->pAdr->pLaraIndex;

  0032e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00333	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00339	8b 91 9c 00 00
	00		 mov	 edx, DWORD PTR [ecx+156]
  0033f	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00342	a3 04 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+4, eax

; 4264 : 		break;

  00347	e9 86 13 00 00	 jmp	 $LN155@Get
$LN132@Get:

; 4265 : 	case GET_ITEM:
; 4266 : 		GET.pItem=NULL;

  0034c	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+8, 0

; 4267 : 
; 4268 : 		if (Index & NGLE_INDEX) {

  00356	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00359	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0035e	74 2d		 je	 SHORT $LN131@Get

; 4269 : 			Index &= MASK_NGLE_INDEX;

  00360	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00363	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00368	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4270 : 			TombIndex=FromNgleIndexToTomb4Index(Index);

  0036b	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0036e	50		 push	 eax
  0036f	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  00374	83 c4 04	 add	 esp, 4
  00377	89 45 f8	 mov	 DWORD PTR _TombIndex$[ebp], eax

; 4271 : 			if (TombIndex==-1) return false;

  0037a	83 7d f8 ff	 cmp	 DWORD PTR _TombIndex$[ebp], -1
  0037e	75 07		 jne	 SHORT $LN130@Get
  00380	32 c0		 xor	 al, al
  00382	e9 4d 13 00 00	 jmp	 $LN157@Get
$LN130@Get:

; 4272 : 			Index= TombIndex;

  00387	8b 45 f8	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  0038a	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax
$LN131@Get:

; 4273 : 		}
; 4274 : 		if (Index < 0 || Index >= Trng.pGlobTomb4->pAdr->TotItemsMax) {

  0038d	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  00391	7c 16		 jl	 SHORT $LN128@Get
  00393	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00398	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0039e	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  003a1	3b 91 0c 02 00
	00		 cmp	 edx, DWORD PTR [ecx+524]
  003a7	7c 2a		 jl	 SHORT $LN129@Get
$LN128@Get:

; 4275 : 			SendToLog("ERROR: Get(GET_ITEM) invalid item index (%d), outside of valid range 0 - %d",
; 4276 : 				Index, Trng.pGlobTomb4->pAdr->TotItemsMax);

  003a9	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  003ae	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  003b4	8b 91 0c 02 00
	00		 mov	 edx, DWORD PTR [ecx+524]
  003ba	52		 push	 edx
  003bb	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  003be	50		 push	 eax
  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_0EM@KFPEOBDF@ERROR?3?5Get?$CIGET_ITEM?$CJ?5invalid?5ite@
  003c4	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  003c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4277 : 			return false;

  003cc	32 c0		 xor	 al, al
  003ce	e9 01 13 00 00	 jmp	 $LN157@Get
$LN129@Get:

; 4278 : 		}
; 4279 : 		GET.pItem = &Trng.pGlobTomb4->pAdr->pVetItems[Index];

  003d3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  003d8	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  003de	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  003e1	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  003e7	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  003ea	89 15 08 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+8, edx

; 4280 : 		break;

  003f0	e9 dd 12 00 00	 jmp	 $LN155@Get
$LN127@Get:

; 4281 : 	case GET_STATIC:
; 4282 : 		GET.pStatic=NULL;

  003f5	c7 05 0c 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+12, 0

; 4283 : 
; 4284 : 		if (Index & NGLE_INDEX) {

  003ff	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00402	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00407	74 2f		 je	 SHORT $LN126@Get

; 4285 : 			Index &= MASK_NGLE_INDEX;

  00409	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0040c	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  00411	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4286 : 			if (FromNgleStaticIndexToTomb4Indices(Index, &RoomIndex, &StaticIndex)==false) return false;

  00414	8d 45 e0	 lea	 eax, DWORD PTR _StaticIndex$[ebp]
  00417	50		 push	 eax
  00418	8d 4d ec	 lea	 ecx, DWORD PTR _RoomIndex$[ebp]
  0041b	51		 push	 ecx
  0041c	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  0041f	52		 push	 edx
  00420	e8 00 00 00 00	 call	 ?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z ; FromNgleStaticIndexToTomb4Indices
  00425	83 c4 0c	 add	 esp, 12			; 0000000cH
  00428	0f b6 c0	 movzx	 eax, al
  0042b	85 c0		 test	 eax, eax
  0042d	75 07		 jne	 SHORT $LN125@Get
  0042f	32 c0		 xor	 al, al
  00431	e9 9e 12 00 00	 jmp	 $LN157@Get
$LN125@Get:

; 4287 : 
; 4288 : 		}else {

  00436	eb 0c		 jmp	 SHORT $LN124@Get
$LN126@Get:

; 4289 : 			RoomIndex = Index;

  00438	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0043b	89 45 ec	 mov	 DWORD PTR _RoomIndex$[ebp], eax

; 4290 : 			StaticIndex = SecondaryIndex;

  0043e	8b 45 10	 mov	 eax, DWORD PTR _SecondaryIndex$[ebp]
  00441	89 45 e0	 mov	 DWORD PTR _StaticIndex$[ebp], eax
$LN124@Get:

; 4291 : 		}
; 4292 : 		if (RoomIndex < 0 || RoomIndex >= *Trng.pGlobTomb4->pAdr->pTotRooms) {

  00444	83 7d ec 00	 cmp	 DWORD PTR _RoomIndex$[ebp], 0
  00448	7c 19		 jl	 SHORT $LN122@Get
  0044a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0044f	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00455	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  0045b	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0045e	39 45 ec	 cmp	 DWORD PTR _RoomIndex$[ebp], eax
  00461	7c 2d		 jl	 SHORT $LN123@Get
$LN122@Get:

; 4293 : 			SendToLog("ERROR: Get(GET_STATIC) Invalid room index (%d), outside of valid range 0 - %d",
; 4294 : 					RoomIndex, *Trng.pGlobTomb4->pAdr->pTotRooms);

  00463	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00468	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0046e	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  00474	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00477	50		 push	 eax
  00478	8b 4d ec	 mov	 ecx, DWORD PTR _RoomIndex$[ebp]
  0047b	51		 push	 ecx
  0047c	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@LBHMNKCM@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5r@
  00481	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00486	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4295 : 			return false;

  00489	32 c0		 xor	 al, al
  0048b	e9 44 12 00 00	 jmp	 $LN157@Get
$LN123@Get:

; 4296 : 		}
; 4297 : 		z= Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].TotStaticMesh;

  00490	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00495	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0049b	8b 55 ec	 mov	 edx, DWORD PTR _RoomIndex$[ebp]
  0049e	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  004a4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  004a7	0f b7 4c 10 32	 movzx	 ecx, WORD PTR [eax+edx+50]
  004ac	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], ecx

; 4298 : 
; 4299 : 		if (StaticIndex < 0 || StaticIndex >= z) {

  004b2	83 7d e0 00	 cmp	 DWORD PTR _StaticIndex$[ebp], 0
  004b6	7c 0b		 jl	 SHORT $LN120@Get
  004b8	8b 45 e0	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  004bb	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  004c1	7c 1f		 jl	 SHORT $LN121@Get
$LN120@Get:

; 4300 : 			SendToLog("ERROR: Get(GET_STATIC) Invalid static index (%d), outside of valid range 0 - %d",
; 4301 : 				StaticIndex, z);

  004c3	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  004c9	50		 push	 eax
  004ca	8b 4d e0	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  004cd	51		 push	 ecx
  004ce	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@OLEPCMLI@ERROR?3?5Get?$CIGET_STATIC?$CJ?5Invalid?5s@
  004d3	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  004d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4302 : 			return false;

  004db	32 c0		 xor	 al, al
  004dd	e9 f2 11 00 00	 jmp	 $LN157@Get
$LN121@Get:

; 4303 : 		}
; 4304 : 		GET.pStatic = &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].Ptr_StaticMesh[StaticIndex];

  004e2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  004e7	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  004ed	8b 55 ec	 mov	 edx, DWORD PTR _RoomIndex$[ebp]
  004f0	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  004f6	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  004f9	8b 4d e0	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  004fc	6b c9 14	 imul	 ecx, 20			; 00000014H
  004ff	03 4c 10 10	 add	 ecx, DWORD PTR [eax+edx+16]
  00503	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+12, ecx

; 4305 : 		break;

  00509	e9 c4 11 00 00	 jmp	 $LN155@Get
$LN119@Get:

; 4306 : 	case GET_ROOM:
; 4307 : 
; 4308 : 		GET.pRoom=NULL;

  0050e	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+16, 0

; 4309 : 
; 4310 : 		if (Index < 0 || Index >= *Trng.pGlobTomb4->pAdr->pTotRooms) {

  00518	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  0051c	7c 19		 jl	 SHORT $LN117@Get
  0051e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00523	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00529	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  0052f	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00532	39 45 0c	 cmp	 DWORD PTR _Index$[ebp], eax
  00535	7c 2d		 jl	 SHORT $LN118@Get
$LN117@Get:

; 4311 : 			SendToLog("ERROR: Get(GET_ROOM) invalid index (%d), outside of valid range 0 - %d",
; 4312 : 							Index, *Trng.pGlobTomb4->pAdr->pTotRooms);

  00537	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0053c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00542	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  00548	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0054b	50		 push	 eax
  0054c	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  0054f	51		 push	 ecx
  00550	68 00 00 00 00	 push	 OFFSET ??_C@_0EH@KLJPBKDN@ERROR?3?5Get?$CIGET_ROOM?$CJ?5invalid?5ind@
  00555	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0055a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4313 : 			return false;

  0055d	32 c0		 xor	 al, al
  0055f	e9 70 11 00 00	 jmp	 $LN157@Get
$LN118@Get:

; 4314 : 		}
; 4315 : 		GET.pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[Index];

  00564	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00569	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0056f	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  00572	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00578	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0057b	89 15 10 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+16, edx

; 4316 : 		break;

  00581	e9 4c 11 00 00	 jmp	 $LN155@Get
$LN116@Get:

; 4317 : 	case GET_COLOR_RGB:
; 4318 : 		TestConvert=true;

  00586	c6 45 b3 01	 mov	 BYTE PTR _TestConvert$[ebp], 1

; 4319 : 		if (SecondaryIndex == COLF_TOMB_COLOR) TestConvert=false;

  0058a	83 7d 10 01	 cmp	 DWORD PTR _SecondaryIndex$[ebp], 1
  0058e	75 04		 jne	 SHORT $LN115@Get
  00590	c6 45 b3 00	 mov	 BYTE PTR _TestConvert$[ebp], 0
$LN115@Get:

; 4320 : 
; 4321 : 		GET.Color = GetColorRgb(Index, 0xFF000000, TestConvert, "Get() function");

  00594	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MLPNHJIJ@Get?$CI?$CJ?5function?$AA@
  00599	0f b6 45 b3	 movzx	 eax, BYTE PTR _TestConvert$[ebp]
  0059d	50		 push	 eax
  0059e	68 00 00 00 ff	 push	 -16777216		; ff000000H
  005a3	0f b7 4d 0c	 movzx	 ecx, WORD PTR _Index$[ebp]
  005a7	51		 push	 ecx
  005a8	e8 00 00 00 00	 call	 ?GetColorRgb@@YAKFK_NPAD@Z ; GetColorRgb
  005ad	83 c4 10	 add	 esp, 16			; 00000010H
  005b0	a3 c7 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+199, eax

; 4322 : 		break;

  005b5	e9 18 11 00 00	 jmp	 $LN155@Get
$LN114@Get:

; 4323 : 
; 4324 : 	case GET_ITEM_COLL_BOX:
; 4325 : 		GET.pCollItem=NULL;

  005ba	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+20, 0

; 4326 : 
; 4327 : 		if (Index & NGLE_INDEX) {

  005c4	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  005c7	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  005cc	74 2d		 je	 SHORT $LN113@Get

; 4328 : 			Index &= MASK_NGLE_INDEX;

  005ce	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  005d1	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  005d6	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4329 : 			TombIndex=FromNgleIndexToTomb4Index(Index);

  005d9	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  005dc	50		 push	 eax
  005dd	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  005e2	83 c4 04	 add	 esp, 4
  005e5	89 45 f8	 mov	 DWORD PTR _TombIndex$[ebp], eax

; 4330 : 			if (TombIndex==-1) return false;

  005e8	83 7d f8 ff	 cmp	 DWORD PTR _TombIndex$[ebp], -1
  005ec	75 07		 jne	 SHORT $LN112@Get
  005ee	32 c0		 xor	 al, al
  005f0	e9 df 10 00 00	 jmp	 $LN157@Get
$LN112@Get:

; 4331 : 			Index= TombIndex;

  005f5	8b 45 f8	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  005f8	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax
$LN113@Get:

; 4332 : 		}
; 4333 : 		if (Index < 0 || Index >= Trng.pGlobTomb4->pAdr->TotItemsMax) {

  005fb	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  005ff	7c 16		 jl	 SHORT $LN110@Get
  00601	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00606	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0060c	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  0060f	3b 91 0c 02 00
	00		 cmp	 edx, DWORD PTR [ecx+524]
  00615	7c 2a		 jl	 SHORT $LN111@Get
$LN110@Get:

; 4334 : 			SendToLog("ERROR: Get(GET_COLL_BOX) invalid item index (%d), outside of valid range 0 - %d",
; 4335 : 				Index, Trng.pGlobTomb4->pAdr->TotItemsMax);

  00617	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0061c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00622	8b 91 0c 02 00
	00		 mov	 edx, DWORD PTR [ecx+524]
  00628	52		 push	 edx
  00629	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0062c	50		 push	 eax
  0062d	68 00 00 00 00	 push	 OFFSET ??_C@_0FA@KOJKINJA@ERROR?3?5Get?$CIGET_COLL_BOX?$CJ?5invalid@
  00632	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00637	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4336 : 			return false;

  0063a	32 c0		 xor	 al, al
  0063c	e9 93 10 00 00	 jmp	 $LN157@Get
$LN111@Get:

; 4337 : 		}
; 4338 : 		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[Index];		

  00641	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00646	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0064c	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  0064f	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00655	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00658	89 55 d4	 mov	 DWORD PTR _pItem$[ebp], edx

; 4339 : 		GET.pCollItem = GetBestFrame(pItem);

  0065b	8b f4		 mov	 esi, esp
  0065d	8b 45 d4	 mov	 eax, DWORD PTR _pItem$[ebp]
  00660	50		 push	 eax
  00661	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA ; GetBestFrame
  00667	83 c4 04	 add	 esp, 4
  0066a	3b f4		 cmp	 esi, esp
  0066c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00671	a3 14 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+20, eax

; 4340 : 		break;

  00676	e9 57 10 00 00	 jmp	 $LN155@Get
$LN109@Get:

; 4341 : 	case GET_STATIC_COLL_BOX:
; 4342 : 	case GET_STATIC_VIEW_BOX:
; 4343 : 		if (Index & NGLE_INDEX) {

  0067b	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0067e	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00683	74 2f		 je	 SHORT $LN108@Get

; 4344 : 			Index &= MASK_NGLE_INDEX;

  00685	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  00688	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0068d	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4345 : 			if (FromNgleStaticIndexToTomb4Indices(Index, &RoomIndex, &StaticIndex)==false) return false;

  00690	8d 45 e0	 lea	 eax, DWORD PTR _StaticIndex$[ebp]
  00693	50		 push	 eax
  00694	8d 4d ec	 lea	 ecx, DWORD PTR _RoomIndex$[ebp]
  00697	51		 push	 ecx
  00698	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  0069b	52		 push	 edx
  0069c	e8 00 00 00 00	 call	 ?FromNgleStaticIndexToTomb4Indices@@YA_NHPAH0@Z ; FromNgleStaticIndexToTomb4Indices
  006a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a4	0f b6 c0	 movzx	 eax, al
  006a7	85 c0		 test	 eax, eax
  006a9	75 07		 jne	 SHORT $LN107@Get
  006ab	32 c0		 xor	 al, al
  006ad	e9 22 10 00 00	 jmp	 $LN157@Get
$LN107@Get:

; 4346 : 
; 4347 : 		}else {

  006b2	eb 0c		 jmp	 SHORT $LN106@Get
$LN108@Get:

; 4348 : 			RoomIndex = Index;

  006b4	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  006b7	89 45 ec	 mov	 DWORD PTR _RoomIndex$[ebp], eax

; 4349 : 			StaticIndex = SecondaryIndex;

  006ba	8b 45 10	 mov	 eax, DWORD PTR _SecondaryIndex$[ebp]
  006bd	89 45 e0	 mov	 DWORD PTR _StaticIndex$[ebp], eax
$LN106@Get:

; 4350 : 		}
; 4351 : 		if (RoomIndex < 0 || RoomIndex >= *Trng.pGlobTomb4->pAdr->pTotRooms) {

  006c0	83 7d ec 00	 cmp	 DWORD PTR _RoomIndex$[ebp], 0
  006c4	7c 19		 jl	 SHORT $LN104@Get
  006c6	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  006cb	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  006d1	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  006d7	0f b7 02	 movzx	 eax, WORD PTR [edx]
  006da	39 45 ec	 cmp	 DWORD PTR _RoomIndex$[ebp], eax
  006dd	7c 2d		 jl	 SHORT $LN105@Get
$LN104@Get:

; 4352 : 			SendToLog("ERROR: Get(GET_STATIC_COLL//VIEW_BOX) Invalid room index (%d), outside of valid range 0 - %d",
; 4353 : 					RoomIndex, *Trng.pGlobTomb4->pAdr->pTotRooms);

  006df	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  006e4	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  006ea	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  006f0	0f b7 02	 movzx	 eax, WORD PTR [edx]
  006f3	50		 push	 eax
  006f4	8b 4d ec	 mov	 ecx, DWORD PTR _RoomIndex$[ebp]
  006f7	51		 push	 ecx
  006f8	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@HCAHGEMN@ERROR?3?5Get?$CIGET_STATIC_COLL?1?1VIEW@
  006fd	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00702	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4354 : 			return false;

  00705	32 c0		 xor	 al, al
  00707	e9 c8 0f 00 00	 jmp	 $LN157@Get
$LN105@Get:

; 4355 : 		}
; 4356 : 
; 4357 : 		z= Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].TotStaticMesh;

  0070c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00711	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00717	8b 55 ec	 mov	 edx, DWORD PTR _RoomIndex$[ebp]
  0071a	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00720	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00723	0f b7 4c 10 32	 movzx	 ecx, WORD PTR [eax+edx+50]
  00728	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], ecx

; 4358 : 		if (StaticIndex < 0 || StaticIndex >= z) {

  0072e	83 7d e0 00	 cmp	 DWORD PTR _StaticIndex$[ebp], 0
  00732	7c 0b		 jl	 SHORT $LN102@Get
  00734	8b 45 e0	 mov	 eax, DWORD PTR _StaticIndex$[ebp]
  00737	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  0073d	7c 1f		 jl	 SHORT $LN103@Get
$LN102@Get:

; 4359 : 			SendToLog("ERROR: Get(GET_STATIC_COLL/VIEW_BOX) Invalid static index (%d), outside of valid range 0 - %d",
; 4360 : 				StaticIndex, z);

  0073f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  00745	50		 push	 eax
  00746	8b 4d e0	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  00749	51		 push	 ecx
  0074a	68 00 00 00 00	 push	 OFFSET ??_C@_0FO@LCPLCGCJ@ERROR?3?5Get?$CIGET_STATIC_COLL?1VIEW_@
  0074f	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00754	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4361 : 			return false;

  00757	32 c0		 xor	 al, al
  00759	e9 76 0f 00 00	 jmp	 $LN157@Get
$LN103@Get:

; 4362 : 		}
; 4363 : 		pStatic = &Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].Ptr_StaticMesh[StaticIndex];

  0075e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00763	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00769	8b 55 ec	 mov	 edx, DWORD PTR _RoomIndex$[ebp]
  0076c	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00772	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00775	8b 4d e0	 mov	 ecx, DWORD PTR _StaticIndex$[ebp]
  00778	6b c9 14	 imul	 ecx, 20			; 00000014H
  0077b	03 4c 10 10	 add	 ecx, DWORD PTR [eax+edx+16]
  0077f	89 4d c8	 mov	 DWORD PTR _pStatic$[ebp], ecx

; 4364 : 		Index= pStatic->SlotId;

  00782	8b 45 c8	 mov	 eax, DWORD PTR _pStatic$[ebp]
  00785	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  00789	89 4d 0c	 mov	 DWORD PTR _Index$[ebp], ecx

; 4365 : 		if (GET_Type == GET_STATIC_COLL_BOX) {

  0078c	83 7d 08 05	 cmp	 DWORD PTR _GET_Type$[ebp], 5
  00790	75 20		 jne	 SHORT $LN101@Get

; 4366 : 			GET.pCollStatic = &Trng.pGlobTomb4->pAdr->pVetEditObjects[Index].CollisionBox;

  00792	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00797	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0079d	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  007a0	6b d2 1c	 imul	 edx, 28			; 0000001cH
  007a3	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  007a6	8d 4c 10 10	 lea	 ecx, DWORD PTR [eax+edx+16]
  007aa	89 0d 18 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+24, ecx

; 4367 : 		}else {

  007b0	eb 1e		 jmp	 SHORT $LN100@Get
$LN101@Get:

; 4368 : 			GET.pViewStatic = &Trng.pGlobTomb4->pAdr->pVetEditObjects[Index].ViewBox;

  007b2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  007b7	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  007bd	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  007c0	6b d2 1c	 imul	 edx, 28			; 0000001cH
  007c3	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  007c6	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  007ca	89 0d 1c 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+28, ecx
$LN100@Get:

; 4369 : 		}
; 4370 : 		break;

  007d0	e9 fd 0e 00 00	 jmp	 $LN155@Get
$LN99@Get:

; 4371 : 	case GET_DOOR_OF_ROOM:
; 4372 : 		GET.pDoor=NULL;

  007d5	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+32, 0

; 4373 : 
; 4374 : 		z= Trng.pGlobTomb4->pAdr->pVetRooms[Index].pDoors->TotDoors;

  007df	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  007e4	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  007ea	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  007ed	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  007f3	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007f6	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  007fa	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  007fd	89 95 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], edx

; 4375 : 
; 4376 : 		if (Index < 0 || Index >= z) {

  00803	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  00807	7c 0b		 jl	 SHORT $LN97@Get
  00809	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0080c	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  00812	7c 1f		 jl	 SHORT $LN98@Get
$LN97@Get:

; 4377 : 			SendToLog("ERROR: Get(GET_DOOR_OF_ROOM) invalid door index (%d), outside of valid range 0 - %d",
; 4378 : 					Index, z);

  00814	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  0081a	50		 push	 eax
  0081b	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  0081e	51		 push	 ecx
  0081f	68 00 00 00 00	 push	 OFFSET ??_C@_0FE@CGMNPFNF@ERROR?3?5Get?$CIGET_DOOR_OF_ROOM?$CJ?5inv@
  00824	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00829	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4379 : 			return false;

  0082c	32 c0		 xor	 al, al
  0082e	e9 a1 0e 00 00	 jmp	 $LN157@Get
$LN98@Get:

; 4380 : 		}
; 4381 : 		GET.pDoor = &Trng.pGlobTomb4->pAdr->pVetRooms[Index].pDoors->VetDoors[SecondaryIndex];

  00833	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00838	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0083e	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  00841	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00847	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0084a	8b 4c 10 04	 mov	 ecx, DWORD PTR [eax+edx+4]
  0084e	8b 55 10	 mov	 edx, DWORD PTR _SecondaryIndex$[ebp]
  00851	c1 e2 05	 shl	 edx, 5
  00854	8d 44 11 02	 lea	 eax, DWORD PTR [ecx+edx+2]
  00858	a3 20 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+32, eax

; 4382 : 		break;

  0085d	e9 70 0e 00 00	 jmp	 $LN155@Get
$LN96@Get:

; 4383 : 
; 4384 : 	case GET_INFO_LARA:
; 4385 : 		pInfo = &GET.LaraInfo;

  00862	c7 45 a4 24 00
	00 00		 mov	 DWORD PTR _pInfo$[ebp], OFFSET ?GET@@3UStrGetLocator@@A+36

; 4386 : 		// clear old values
; 4387 : 		ClearMemory(pInfo, sizeof(StrLaraInfo));

  00869	6a 56		 push	 86			; 00000056H
  0086b	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0086e	50		 push	 eax
  0086f	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  00874	83 c4 08	 add	 esp, 8

; 4388 : 
; 4389 : 		pInfo->TestFreeHands=true;

  00877	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0087a	c6 00 01	 mov	 BYTE PTR [eax], 1

; 4390 : 		// get some data we'll use to discover infos about lara:
; 4391 : 		StateId = Trng.pGlobTomb4->pAdr->pLara->StateIdCurrent;

  0087d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00882	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00888	8b 11		 mov	 edx, DWORD PTR [ecx]
  0088a	66 8b 42 0e	 mov	 ax, WORD PTR [edx+14]
  0088e	66 89 85 5c ff
	ff ff		 mov	 WORD PTR _StateId$[ebp], ax

; 4392 : 		pLara = Trng.pGlobTomb4->pAdr->pLara;

  00895	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0089a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  008a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  008a2	89 55 98	 mov	 DWORD PTR _pLara$[ebp], edx

; 4393 : 		pInfo->SkipPhaseFlags  =FindSkipPhase();

  008a5	e8 00 00 00 00	 call	 ?FindSkipPhase@@YAKXZ	; FindSkipPhase
  008aa	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  008ad	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 4394 : 
; 4395 : 
; 4396 : 
; 4397 : 		// ------------ what item lara is holding in her hands --------------------------
; 4398 : 		if (*Trng.pGlobTomb4->pAdr->pFlagsLaraHands == enumFLH.HOLDS_ITEM ||
; 4399 : 			*Trng.pGlobTomb4->pAdr->pObjInLaraHandsNow == enumHOLD.FLARE ) {

  008b0	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  008b5	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  008bb	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  008be	0f b7 02	 movzx	 eax, WORD PTR [edx]
  008c1	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR ?enumFLH@@3UStrEnumFLH@@A+16
  008c7	74 1d		 je	 SHORT $LN94@Get
  008c9	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  008ce	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  008d4	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  008d7	0f b7 02	 movzx	 eax, WORD PTR [edx]
  008da	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+24
  008e0	0f 85 ac 00 00
	00		 jne	 $LN95@Get
$LN94@Get:

; 4400 : 			pInfo->TestFreeHands=false;

  008e6	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  008e9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4401 : 			// lara holds item in her hands
; 4402 : 			pInfo->TestIsHoldingItem = true;

  008ec	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  008ef	c6 40 01 01	 mov	 BYTE PTR [eax+1], 1

; 4403 : 			pInfo->HoldedItem = *Trng.pGlobTomb4->pAdr->pObjInLaraHandsNow;

  008f3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  008f8	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  008fe	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00901	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00904	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00907	89 41 07	 mov	 DWORD PTR [ecx+7], eax

; 4404 : 			// if item is flare, set also value of flaretime
; 4405 : 			if (pInfo->HoldedItem == enumHOLD.FLARE) {

  0090a	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0090d	8b 48 07	 mov	 ecx, DWORD PTR [eax+7]
  00910	3b 0d 18 00 00
	00		 cmp	 ecx, DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+24
  00916	75 1a		 jne	 SHORT $LN93@Get

; 4406 : 				pInfo->FlareTime = *Trng.pGlobTomb4->pAdr->pFlareLifeTime;

  00918	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0091d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00923	8b 91 98 00 00
	00		 mov	 edx, DWORD PTR [ecx+152]
  00929	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0092c	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  0092f	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN93@Get:

; 4407 : 			}
; 4408 : 			
; 4409 : 			// if item is torch, verify if it's burning
; 4410 : 
; 4411 : 			if (pInfo->HoldedItem == enumHOLD.OUT_TORCH ) {

  00932	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00935	8b 48 07	 mov	 ecx, DWORD PTR [eax+7]
  00938	3b 0d 1c 00 00
	00		 cmp	 ecx, DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+28
  0093e	75 2f		 jne	 SHORT $LN92@Get

; 4412 : 				if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.TORCH_IS_BURNING ) {

  00940	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00945	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0094b	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00951	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00954	23 05 14 00 00
	00		 and	 eax, DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+20
  0095a	74 13		 je	 SHORT $LN92@Get

; 4413 : 					pInfo->HoldedItem = enumHOLD.FIRED_TORCH;

  0095c	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0095f	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+32
  00965	89 48 07	 mov	 DWORD PTR [eax+7], ecx

; 4414 : 					pInfo->TestBurningTorch=true;

  00968	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0096b	c6 40 10 01	 mov	 BYTE PTR [eax+16], 1
$LN92@Get:

; 4415 : 				}
; 4416 : 			}
; 4417 : 			// check if it is a weapon
; 4418 : 			if (pInfo->HoldedItem >= enumHOLD.PISTOLS  && pInfo->HoldedItem <= enumHOLD.CROSSBOW ) {

  0096f	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00972	8b 48 07	 mov	 ecx, DWORD PTR [eax+7]
  00975	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A
  0097b	7c 15		 jl	 SHORT $LN95@Get
  0097d	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00980	8b 48 07	 mov	 ecx, DWORD PTR [eax+7]
  00983	3b 0d 14 00 00
	00		 cmp	 ecx, DWORD PTR ?enumHOLD@@3UStrEnumHOLD@@A+20
  00989	7f 07		 jg	 SHORT $LN95@Get

; 4419 : 				pInfo->TestIsHoldingWeapon = true;

  0098b	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  0098e	c6 40 02 01	 mov	 BYTE PTR [eax+2], 1
$LN95@Get:

; 4420 : 			}
; 4421 : 		}
; 4422 : 		// ------------ weapon selected -------------------------------
; 4423 : 		pInfo->WeaponSelected = *Trng.pGlobTomb4->pAdr->pWeaponSelected;

  00992	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00997	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0099d	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  009a0	0f b7 02	 movzx	 eax, WORD PTR [edx]
  009a3	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  009a6	89 41 03	 mov	 DWORD PTR [ecx+3], eax

; 4424 : 
; 4425 : 		// ------------ vehicle -------------------
; 4426 : 		pInfo->IndexOfVehicle = *Trng.pGlobTomb4->pAdr->pVehicleIndex;

  009a9	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  009ae	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  009b4	8b 51 5c	 mov	 edx, DWORD PTR [ecx+92]
  009b7	0f bf 02	 movsx	 eax, WORD PTR [edx]
  009ba	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  009bd	89 41 16	 mov	 DWORD PTR [ecx+22], eax

; 4427 : 		if (pInfo->IndexOfVehicle != -1) {

  009c0	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  009c3	83 78 16 ff	 cmp	 DWORD PTR [eax+22], -1
  009c7	74 32		 je	 SHORT $LN89@Get

; 4428 : 			pInfo->TestFreeHands=false;

  009c9	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  009cc	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4429 : 			pInfo->TestIsDrivingVehicle=true;

  009cf	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  009d2	c6 40 11 01	 mov	 BYTE PTR [eax+17], 1

; 4430 : 			pInfo->SlotVehicle = Trng.pGlobTomb4->pAdr->pVetItems[pInfo->IndexOfVehicle].SlotID;

  009d6	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  009db	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  009e1	8b 55 a4	 mov	 edx, DWORD PTR _pInfo$[ebp]
  009e4	8b 42 16	 mov	 eax, DWORD PTR [edx+22]
  009e7	69 c0 f6 15 00
	00		 imul	 eax, 5622		; 000015f6H
  009ed	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  009f0	0f b7 54 01 0c	 movzx	 edx, WORD PTR [ecx+eax+12]
  009f5	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  009f8	89 50 12	 mov	 DWORD PTR [eax+18], edx
$LN89@Get:

; 4431 : 		}
; 4432 : 		// --------- crowbar --------------------
; 4433 : 		// the only way to discover if lara is holding the crowbar is checking the value of right hand mesh and 
; 4434 : 		// compare it with the same mesh of CROWBAR_ANIM
; 4435 : 
; 4436 : 		// locate the first mesh for CROWBAR_ANIM slot
; 4437 : 		MeshIndex= Trng.pGlobTomb4->pAdr->pVetSlot[enumSLOT.CROWBAR_ANIM].IndexFirstMesh;

  009fb	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00a00	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00a06	8b 15 70 00 00
	00		 mov	 edx, DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+112
  00a0c	c1 e2 06	 shl	 edx, 6
  00a0f	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00a12	0f b7 4c 10 02	 movzx	 ecx, WORD PTR [eax+edx+2]
  00a17	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _MeshIndex$[ebp], ecx

; 4438 : 		// the right hand the mesh with index = 10 but in the game all meshes are duplicated, so we have 
; 4439 : 		// to multiply by 2 the real mesh index
; 4440 : 		pMeshRightHand = Trng.pGlobTomb4->pAdr->VetMeshPointer[MeshIndex+ 10*2];

  00a1d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00a22	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00a28	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00a2b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _MeshIndex$[ebp]
  00a31	8b 4c 82 50	 mov	 ecx, DWORD PTR [edx+eax*4+80]
  00a35	89 8d 20 ff ff
	ff		 mov	 DWORD PTR _pMeshRightHand$[ebp], ecx

; 4441 : 		// now we check if the mesh currently loaded in lara's body has same value of MeshRightHand
; 4442 : 		// note: the mesh vector for current lara meshes is not duplicated so in this case we'll use 10 as index for right hand
; 4443 : 		if (pMeshRightHand == Trng.pGlobTomb4->pAdr->VetMeshLara[10]) {

  00a3b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00a40	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00a46	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00a49	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR _pMeshRightHand$[ebp]
  00a4f	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  00a52	75 0d		 jne	 SHORT $LN88@Get

; 4444 : 			// yes: lara is holding the crowbar
; 4445 : 			pInfo->TestIsHoldingCrowBar=true;

  00a54	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a57	c6 40 0b 01	 mov	 BYTE PTR [eax+11], 1

; 4446 : 			pInfo->TestFreeHands=false;

  00a5b	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a5e	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN88@Get:

; 4447 : 		}
; 4448 : 		
; 4449 : 		// ---------- rope -----------------------
; 4450 : 		pInfo->RopeIndex = *Trng.pGlobTomb4->pAdr->pRopeNowIndex;

  00a61	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00a66	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00a6c	8b 51 78	 mov	 edx, DWORD PTR [ecx+120]
  00a6f	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a72	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00a74	89 48 1b	 mov	 DWORD PTR [eax+27], ecx

; 4451 : 		if (pInfo->RopeIndex != -1) {

  00a77	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a7a	83 78 1b ff	 cmp	 DWORD PTR [eax+27], -1
  00a7e	74 0d		 je	 SHORT $LN87@Get

; 4452 : 			pInfo->TestFreeHands=false;

  00a80	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a83	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4453 : 			pInfo->TestIsOnRope=true;

  00a86	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a89	c6 40 1a 01	 mov	 BYTE PTR [eax+26], 1
$LN87@Get:

; 4454 : 
; 4455 : 		}
; 4456 : 		// --------- polerope --------------------------
; 4457 : 
; 4458 : 		pInfo->PoleRopeIndex=-1;

  00a8d	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00a90	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [eax+32], -1

; 4459 : 		if (StateId >= 99 && StateId <= 103) {

  00a97	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00a9e	83 f8 63	 cmp	 eax, 99			; 00000063H
  00aa1	7c 32		 jl	 SHORT $LN86@Get
  00aa3	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00aaa	83 f8 67	 cmp	 eax, 103		; 00000067H
  00aad	7f 26		 jg	 SHORT $LN86@Get

; 4460 : 			// lara is hanged on pole rope
; 4461 : 			pInfo->PoleRopeIndex = *Trng.pGlobTomb4->pAdr->pObjectActive;

  00aaf	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00ab4	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00aba	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00ac0	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00ac3	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00ac5	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 4462 : 			pInfo->TestIsOnRope = true;

  00ac8	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00acb	c6 40 1a 01	 mov	 BYTE PTR [eax+26], 1

; 4463 : 			pInfo->TestFreeHands=false;

  00acf	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00ad2	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN86@Get:

; 4464 : 		}
; 4465 : 
; 4466 : 		// ----------- is climbing? ------------------------
; 4467 : 		if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_CLIMBING ) {

  00ad5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00ada	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00ae0	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00ae6	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ae9	23 05 18 00 00
	00		 and	 eax, DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+24
  00aef	74 0d		 je	 SHORT $LN85@Get

; 4468 : 			pInfo->TestIsClimbing=true;

  00af1	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00af4	c6 40 24 01	 mov	 BYTE PTR [eax+36], 1

; 4469 : 			pInfo->TestFreeHands=false;

  00af8	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00afb	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN85@Get:

; 4470 : 		}
; 4471 : 
; 4472 : 		// ------------- is monkeying ? -----------------------------
; 4473 : 		if ((StateId >= 0x4b && StateId <= 0x4f) || 
; 4474 : 			StateId == 0x52 || StateId == 0x53) {

  00afe	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b05	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00b08	7c 0c		 jl	 SHORT $LN82@Get
  00b0a	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b11	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  00b14	7e 18		 jle	 SHORT $LN83@Get
$LN82@Get:
  00b16	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b1d	83 f8 52	 cmp	 eax, 82			; 00000052H
  00b20	74 0c		 je	 SHORT $LN83@Get
  00b22	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b29	83 f8 53	 cmp	 eax, 83			; 00000053H
  00b2c	75 0d		 jne	 SHORT $LN84@Get
$LN83@Get:

; 4475 : 			pInfo->TestIsMonkeying=true;

  00b2e	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00b31	c6 40 25 01	 mov	 BYTE PTR [eax+37], 1

; 4476 : 			pInfo->TestFreeHands=false;

  00b35	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00b38	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN84@Get:

; 4477 : 		}
; 4478 : 
; 4479 : 		// ------------- on all fours ----------------------------------
; 4480 : 		if (StateId >= 0x50 && StateId <= 0x58) {

  00b3b	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b42	83 f8 50	 cmp	 eax, 80			; 00000050H
  00b45	7c 13		 jl	 SHORT $LN81@Get
  00b47	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b4e	83 f8 58	 cmp	 eax, 88			; 00000058H
  00b51	7f 07		 jg	 SHORT $LN81@Get

; 4481 : 			pInfo->TestIsOnAllFour=true;

  00b53	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00b56	c6 40 26 01	 mov	 BYTE PTR [eax+38], 1
$LN81@Get:

; 4482 : 		}
; 4483 : 
; 4484 : 		// ------------- duck -------------------------------------------
; 4485 : 		if (StateId == 0x47 || StateId == 0x48) {

  00b5a	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b61	83 f8 47	 cmp	 eax, 71			; 00000047H
  00b64	74 0c		 je	 SHORT $LN79@Get
  00b66	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00b6d	83 f8 48	 cmp	 eax, 72			; 00000048H
  00b70	75 07		 jne	 SHORT $LN80@Get
$LN79@Get:

; 4486 : 			pInfo->TestIsDucking = true;

  00b72	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00b75	c6 40 27 01	 mov	 BYTE PTR [eax+39], 1
$LN80@Get:

; 4487 : 		}
; 4488 : 		// ------------ is burning? -------------------------------------
; 4489 : 		if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_BURNING ) {

  00b79	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00b7e	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00b84	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00b8a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b8d	23 05 04 00 00
	00		 and	 eax, DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+4
  00b93	74 07		 je	 SHORT $LN78@Get

; 4490 : 			pInfo->TestIsBurning = true;

  00b95	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00b98	c6 40 28 01	 mov	 BYTE PTR [eax+40], 1
$LN78@Get:

; 4491 : 		}
; 4492 : 		
; 4493 : 		// ------------- is immortal ? ------------------------------------
; 4494 : 		if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_INVULNERABLE ) {

  00b9c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00ba1	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00ba7	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00bad	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00bb0	23 05 0c 00 00
	00		 and	 eax, DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+12
  00bb6	74 07		 je	 SHORT $LN77@Get

; 4495 : 			pInfo->TestIsImmortal = true;

  00bb8	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00bbb	c6 40 29 01	 mov	 BYTE PTR [eax+41], 1
$LN77@Get:

; 4496 : 		}
; 4497 : 		// ------------- is dripping ? -----------------------------------
; 4498 : 		for (i=0;i<16;i++) {

  00bbf	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00bc9	eb 0f		 jmp	 SHORT $LN76@Get
$LN75@Get:
  00bcb	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bd1	83 c0 01	 add	 eax, 1
  00bd4	89 85 2c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN76@Get:
  00bda	83 bd 2c ff ff
	ff 10		 cmp	 DWORD PTR _i$[ebp], 16	; 00000010H
  00be1	7d 27		 jge	 SHORT $LN74@Get

; 4499 : 			if (Trng.pGlobTomb4->pAdr->pVetDrip[i]) {

  00be3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00be8	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00bee	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00bf1	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00bf7	0f b6 0c 02	 movzx	 ecx, BYTE PTR [edx+eax]
  00bfb	85 c9		 test	 ecx, ecx
  00bfd	74 09		 je	 SHORT $LN73@Get

; 4500 : 				pInfo->TestIsDripping=true;

  00bff	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c02	c6 40 2b 01	 mov	 BYTE PTR [eax+43], 1

; 4501 : 				break;

  00c06	eb 02		 jmp	 SHORT $LN74@Get
$LN73@Get:

; 4502 : 			}
; 4503 : 		}

  00c08	eb c1		 jmp	 SHORT $LN75@Get
$LN74@Get:

; 4504 : 
; 4505 : 		// ------------- is poisoned ? ------------------------------------
; 4506 : 		if (*Trng.pGlobTomb4->pAdr->pPoison1 != 0 || *Trng.pGlobTomb4->pAdr->pPoison2) {

  00c0a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00c0f	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00c15	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00c18	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00c1b	85 c0		 test	 eax, eax
  00c1d	75 15		 jne	 SHORT $LN71@Get
  00c1f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00c24	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00c2a	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00c2d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00c30	85 c0		 test	 eax, eax
  00c32	74 07		 je	 SHORT $LN72@Get
$LN71@Get:

; 4507 : 			pInfo->TestIsPoisoned=true;

  00c34	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c37	c6 40 2a 01	 mov	 BYTE PTR [eax+42], 1
$LN72@Get:

; 4508 : 		}
; 4509 : 
; 4510 : 		// ------------- is falling ? --------------------------------------
; 4511 : 		if (pLara->FlagsMain & 0x008) {

  00c3b	8b 45 98	 mov	 eax, DWORD PTR _pLara$[ebp]
  00c3e	8b 88 ea 15 00
	00		 mov	 ecx, DWORD PTR [eax+5610]
  00c44	83 e1 08	 and	 ecx, 8
  00c47	74 07		 je	 SHORT $LN70@Get

; 4512 : 			pInfo->TestIsFalling=true;

  00c49	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c4c	c6 40 2c 01	 mov	 BYTE PTR [eax+44], 1
$LN70@Get:

; 4513 : 		}
; 4514 : 
; 4515 : 		// ------------- is rushing ? ---------------------------
; 4516 : 		if (StateId == 0x49) {

  00c50	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00c57	83 f8 49	 cmp	 eax, 73			; 00000049H
  00c5a	75 1e		 jne	 SHORT $LN69@Get

; 4517 : 			pInfo->TestIsRushing = true;

  00c5c	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c5f	c6 40 2d 01	 mov	 BYTE PTR [eax+45], 1

; 4518 : 			pInfo->RushValue = *Trng.pGlobTomb4->pAdr->pDashBarValue;

  00c63	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00c68	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00c6e	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00c71	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00c74	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00c77	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN69@Get:

; 4519 : 		}
; 4520 : 		// ------------- using laser sight ? ---------------------
; 4521 : 		if (pInfo->SkipPhaseFlags & enumSKIP.LASER_SIGHT) {

  00c7a	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c7d	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00c80	23 0d 24 00 00
	00		 and	 ecx, DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+36
  00c86	74 0d		 je	 SHORT $LN68@Get

; 4522 : 			pInfo->TestIsUsingLaserSight=true;

  00c88	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c8b	c6 40 2e 01	 mov	 BYTE PTR [eax+46], 1

; 4523 : 			pInfo->TestFreeHands=false;

  00c8f	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c92	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN68@Get:

; 4524 : 		}
; 4525 : 
; 4526 : 		// ------------ using binoculars ? -------------------------
; 4527 : 		if (pInfo->SkipPhaseFlags & enumSKIP.BINOCULARS) {

  00c95	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00c98	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00c9b	23 0d 20 00 00
	00		 and	 ecx, DWORD PTR ?enumSKIP@@3UStrEnumSKIP@@A+32
  00ca1	74 0d		 je	 SHORT $LN67@Get

; 4528 : 			pInfo->TestIsUsingBinoculars=true;

  00ca3	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00ca6	c6 40 2f 01	 mov	 BYTE PTR [eax+47], 1

; 4529 : 			pInfo->TestFreeHands=false;

  00caa	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00cad	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN67@Get:

; 4530 : 		}
; 4531 : 		// ---------- lara is aiming an enmey? ----------------------
; 4532 : 		pInfo->pStrAimedEnemy = *Trng.pGlobTomb4->pAdr->p2CurrentEnemyTarget;

  00cb0	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00cb5	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00cbb	8b 91 2c 01 00
	00		 mov	 edx, DWORD PTR [ecx+300]
  00cc1	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00cc4	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00cc6	89 48 35	 mov	 DWORD PTR [eax+53], ecx

; 4533 : 		if (pInfo->pStrAimedEnemy != NULL) {

  00cc9	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00ccc	83 78 35 00	 cmp	 DWORD PTR [eax+53], 0
  00cd0	74 07		 je	 SHORT $LN66@Get

; 4534 : 			pInfo->TestIsAimingEnemy = true;

  00cd2	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00cd5	c6 40 34 01	 mov	 BYTE PTR [eax+52], 1
$LN66@Get:

; 4535 : 		
; 4536 : 		}
; 4537 : 
; 4538 : 		// ----------- lara is pushing pushable object? ------------------
; 4539 : 		if (StateId == 0x24 || StateId == 0x25) {

  00cd9	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00ce0	83 f8 24	 cmp	 eax, 36			; 00000024H
  00ce3	74 10		 je	 SHORT $LN64@Get
  00ce5	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00cec	83 f8 25	 cmp	 eax, 37			; 00000025H
  00cef	0f 85 bf 00 00
	00		 jne	 $LN65@Get
$LN64@Get:

; 4540 : 
; 4541 : 			Index = *Trng.pGlobTomb4->pAdr->pObjectActive;

  00cf5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00cfa	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00d00	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  00d06	8b 02		 mov	 eax, DWORD PTR [edx]
  00d08	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4542 : 			if (Index != -1) {

  00d0b	83 7d 0c ff	 cmp	 DWORD PTR _Index$[ebp], -1
  00d0f	0f 84 9f 00 00
	00		 je	 $LN65@Get

; 4543 : 				Slot = Trng.pGlobTomb4->pAdr->pVetItems[Index].SlotID;

  00d15	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00d1a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00d20	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  00d23	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00d29	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00d2c	66 8b 4c 10 0c	 mov	 cx, WORD PTR [eax+edx+12]
  00d31	66 89 8d 38 ff
	ff ff		 mov	 WORD PTR _Slot$[ebp], cx

; 4544 : 
; 4545 : 				if (Slot >= enumSLOT.PUSHABLE_OBJECT1 && Slot <= enumSLOT.PUSHABLE_OBJECT5) {

  00d38	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00d3f	3b 05 70 02 00
	00		 cmp	 eax, DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+624
  00d45	7c 6d		 jl	 SHORT $LN65@Get
  00d47	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00d4e	3b 05 80 02 00
	00		 cmp	 eax, DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+640
  00d54	7f 5e		 jg	 SHORT $LN65@Get

; 4546 : 					if (StateId == 0x24) {

  00d56	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00d5d	83 f8 24	 cmp	 eax, 36			; 00000024H
  00d60	75 23		 jne	 SHORT $LN61@Get

; 4547 : 						pInfo->TestIsPushingItem=true;

  00d62	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00d65	c6 40 39 01	 mov	 BYTE PTR [eax+57], 1

; 4548 : 						pInfo->PushableIndex = Index;

  00d69	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00d6c	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  00d6f	89 48 3f	 mov	 DWORD PTR [eax+63], ecx

; 4549 : 						pInfo->PushableSlot = Slot;

  00d72	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00d79	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00d7c	89 41 3b	 mov	 DWORD PTR [ecx+59], eax

; 4550 : 						pInfo->TestFreeHands=false;

  00d7f	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00d82	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN61@Get:

; 4551 : 					}
; 4552 : 					// ----------- lara is pulling pushable object ? ----------------
; 4553 : 					if (StateId == 0x25) {

  00d85	0f b7 85 5c ff
	ff ff		 movzx	 eax, WORD PTR _StateId$[ebp]
  00d8c	83 f8 25	 cmp	 eax, 37			; 00000025H
  00d8f	75 23		 jne	 SHORT $LN65@Get

; 4554 : 						pInfo->TestIsPushingItem=true;

  00d91	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00d94	c6 40 39 01	 mov	 BYTE PTR [eax+57], 1

; 4555 : 						pInfo->PushableIndex = Index;

  00d98	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00d9b	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  00d9e	89 48 3f	 mov	 DWORD PTR [eax+63], ecx

; 4556 : 						pInfo->PushableSlot = Slot;

  00da1	0f b7 85 38 ff
	ff ff		 movzx	 eax, WORD PTR _Slot$[ebp]
  00da8	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00dab	89 41 3b	 mov	 DWORD PTR [ecx+59], eax

; 4557 : 						pInfo->TestFreeHands=false;

  00dae	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00db1	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN65@Get:

; 4558 : 					}
; 4559 : 				}
; 4560 : 			}
; 4561 : 		}
; 4562 : 
; 4563 : 		// ------- environment of lara ---------------------------
; 4564 : 		Flags= *Trng.pGlobTomb4->pAdr->pLaraLocationFlags;

  00db4	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00db9	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00dbf	8b 51 58	 mov	 edx, DWORD PTR [ecx+88]
  00dc2	66 8b 02	 mov	 ax, WORD PTR [edx]
  00dc5	66 89 45 80	 mov	 WORD PTR _Flags$[ebp], ax

; 4565 : 
; 4566 : 		if (Flags == enumLLF.FLOATING) {

  00dc9	0f b7 45 80	 movzx	 eax, WORD PTR _Flags$[ebp]
  00dcd	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+8
  00dd3	75 07		 jne	 SHORT $LN59@Get

; 4567 : 			pInfo->TestEnvFloatingOnWater =true;

  00dd5	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00dd8	c6 40 44 01	 mov	 BYTE PTR [eax+68], 1
$LN59@Get:

; 4568 : 		}
; 4569 : 		if (Flags== enumLLF.GROUND ) {

  00ddc	0f b7 45 80	 movzx	 eax, WORD PTR _Flags$[ebp]
  00de0	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?enumLLF@@3UStrEnumLLF@@A
  00de6	75 07		 jne	 SHORT $LN58@Get

; 4570 : 			pInfo->TestEnvGround =true;

  00de8	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00deb	c6 40 43 01	 mov	 BYTE PTR [eax+67], 1
$LN58@Get:

; 4571 : 		}
; 4572 : 
; 4573 : 		if (Flags == enumLLF.LOW_WATER) {

  00def	0f b7 45 80	 movzx	 eax, WORD PTR _Flags$[ebp]
  00df3	3b 05 10 00 00
	00		 cmp	 eax, DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+16
  00df9	75 07		 jne	 SHORT $LN57@Get

; 4574 : 			pInfo->TestEnvLowWater =true;

  00dfb	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00dfe	c6 40 46 01	 mov	 BYTE PTR [eax+70], 1
$LN57@Get:

; 4575 : 		}
; 4576 : 
; 4577 : 		if (Flags == enumLLF.UNDERWATER) {

  00e02	0f b7 45 80	 movzx	 eax, WORD PTR _Flags$[ebp]
  00e06	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+4
  00e0c	75 07		 jne	 SHORT $LN56@Get

; 4578 : 			pInfo->TestEnvUnderwater = true;

  00e0e	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00e11	c6 40 45 01	 mov	 BYTE PTR [eax+69], 1
$LN56@Get:

; 4579 : 		}
; 4580 : 
; 4581 : 		if (Flags == enumLLF.DOZY ) {

  00e15	0f b7 45 80	 movzx	 eax, WORD PTR _Flags$[ebp]
  00e19	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?enumLLF@@3UStrEnumLLF@@A+12
  00e1f	75 07		 jne	 SHORT $LN55@Get

; 4582 : 			pInfo->TestEnvSpecial = true;

  00e21	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00e24	c6 40 47 01	 mov	 BYTE PTR [eax+71], 1
$LN55@Get:

; 4583 : 		}
; 4584 : 
; 4585 : 		// ---------------------- Air available --------------------
; 4586 : 		pInfo->AirValue = *Trng.pGlobTomb4->pAdr->pAirAvailable;

  00e28	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00e2d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00e33	8b 91 cc 00 00
	00		 mov	 edx, DWORD PTR [ecx+204]
  00e39	0f bf 02	 movsx	 eax, WORD PTR [edx]
  00e3c	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00e3f	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 4587 : 
; 4588 : 		// ------------------- Aligned orienting of Lara ---------------------------
; 4589 : 		pInfo->OrientAligned = GetAlignedOrient(pLara->OrientationH, false, &pInfo->OrientGap);

  00e42	8b 45 a4	 mov	 eax, DWORD PTR _pInfo$[ebp]
  00e45	83 c0 52	 add	 eax, 82			; 00000052H
  00e48	50		 push	 eax
  00e49	6a 00		 push	 0
  00e4b	8b 4d 98	 mov	 ecx, DWORD PTR _pLara$[ebp]
  00e4e	0f b7 51 4e	 movzx	 edx, WORD PTR [ecx+78]
  00e52	52		 push	 edx
  00e53	e8 00 00 00 00	 call	 ?GetAlignedOrient@@YAFF_NPAH@Z ; GetAlignedOrient
  00e58	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e5b	8b 4d a4	 mov	 ecx, DWORD PTR _pInfo$[ebp]
  00e5e	66 89 41 50	 mov	 WORD PTR [ecx+80], ax

; 4590 : 
; 4591 : 		break;

  00e62	e9 6b 08 00 00	 jmp	 $LN155@Get
$LN54@Get:

; 4592 : 	case GET_MY_PARAMETER_COMMAND:
; 4593 : 		// ---------------- locate my parameter command ------------------
; 4594 : 		GET.pParam=NULL;

  00e67	c7 05 7a 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+122, 0

; 4595 : 
; 4596 : 		for (i=0;i<MyData.BaseParametersMine.TotParameters;i++) {

  00e71	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00e7b	eb 0f		 jmp	 SHORT $LN53@Get
$LN52@Get:
  00e7d	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00e83	83 c0 01	 add	 eax, 1
  00e86	89 85 2c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN53@Get:
  00e8c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00e92	3b 05 92 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3218
  00e98	0f 8d 95 00 00
	00		 jge	 $LN51@Get

; 4597 : 			pParam= &MyData.BaseParametersMine.pVetParameters[i];

  00e9e	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00ea4	8b 0d 96 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3222
  00eaa	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00ead	c6 85 3f fe ff
	ff 01		 mov	 BYTE PTR $T47250[ebp], 1
  00eb4	89 95 44 ff ff
	ff		 mov	 DWORD PTR _pParam$[ebp], edx

; 4598 : 
; 4599 : 			if (pParam->ParamValue == Index) {

  00eba	80 bd 3f fe ff
	ff 00		 cmp	 BYTE PTR $T47250[ebp], 0
  00ec1	75 0d		 jne	 SHORT $LN160@Get
  00ec3	68 00 00 00 00	 push	 OFFSET $LN161@Get
  00ec8	e8 00 00 00 00	 call	 __RTC_UninitUse
  00ecd	83 c4 04	 add	 esp, 4
$LN160@Get:
  00ed0	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pParam$[ebp]
  00ed6	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00ed9	3b 4d 0c	 cmp	 ecx, DWORD PTR _Index$[ebp]
  00edc	75 50		 jne	 SHORT $LN50@Get

; 4600 : 				if (SecondaryIndex == -1 || SecondaryIndex == pParam->pVetArg[0]) {

  00ede	83 7d 10 ff	 cmp	 DWORD PTR _SecondaryIndex$[ebp], -1
  00ee2	74 27		 je	 SHORT $LN48@Get
  00ee4	80 bd 3f fe ff
	ff 00		 cmp	 BYTE PTR $T47250[ebp], 0
  00eeb	75 0d		 jne	 SHORT $LN162@Get
  00eed	68 00 00 00 00	 push	 OFFSET $LN161@Get
  00ef2	e8 00 00 00 00	 call	 __RTC_UninitUse
  00ef7	83 c4 04	 add	 esp, 4
$LN162@Get:
  00efa	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pParam$[ebp]
  00f00	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00f03	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  00f06	39 55 10	 cmp	 DWORD PTR _SecondaryIndex$[ebp], edx
  00f09	75 23		 jne	 SHORT $LN50@Get
$LN48@Get:

; 4601 : 					GET.pParam = pParam;

  00f0b	80 bd 3f fe ff
	ff 00		 cmp	 BYTE PTR $T47250[ebp], 0
  00f12	75 0d		 jne	 SHORT $LN163@Get
  00f14	68 00 00 00 00	 push	 OFFSET $LN161@Get
  00f19	e8 00 00 00 00	 call	 __RTC_UninitUse
  00f1e	83 c4 04	 add	 esp, 4
$LN163@Get:
  00f21	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pParam$[ebp]
  00f27	a3 7a 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+122, eax

; 4602 : 					break;

  00f2c	eb 05		 jmp	 SHORT $LN51@Get
$LN50@Get:

; 4603 : 				}
; 4604 : 			}
; 4605 : 		}

  00f2e	e9 4a ff ff ff	 jmp	 $LN52@Get
$LN51@Get:

; 4606 : 		if (i == MyData.BaseParametersMine.TotParameters) {

  00f33	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00f39	3b 05 92 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3218
  00f3f	75 1c		 jne	 SHORT $LN47@Get

; 4607 : 			// not found parameter with given input values
; 4608 : 			SendToLog("ERROR: not found my PARAMETERS of PARAM_ type %d with (further) ID = %d",
; 4609 : 				Index, SecondaryIndex);

  00f41	8b 45 10	 mov	 eax, DWORD PTR _SecondaryIndex$[ebp]
  00f44	50		 push	 eax
  00f45	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  00f48	51		 push	 ecx
  00f49	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@CNKPJEBI@ERROR?3?5not?5found?5my?5PARAMETERS?5o@
  00f4e	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00f53	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4610 : 
; 4611 : 			return false;

  00f56	32 c0		 xor	 al, al
  00f58	e9 77 07 00 00	 jmp	 $LN157@Get
$LN47@Get:

; 4612 : 		}
; 4613 : 		GET.pParam = pParam;

  00f5d	80 bd 3f fe ff
	ff 00		 cmp	 BYTE PTR $T47250[ebp], 0
  00f64	75 0d		 jne	 SHORT $LN164@Get
  00f66	68 00 00 00 00	 push	 OFFSET $LN161@Get
  00f6b	e8 00 00 00 00	 call	 __RTC_UninitUse
  00f70	83 c4 04	 add	 esp, 4
$LN164@Get:
  00f73	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _pParam$[ebp]
  00f79	a3 7a 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+122, eax

; 4614 : 		break;

  00f7e	e9 4f 07 00 00	 jmp	 $LN155@Get
$LN46@Get:

; 4615 : 
; 4616 : 	case GET_MY_CUSTOMIZE_COMMAND:
; 4617 : 		GET.pCust=NULL;

  00f83	c7 05 7e 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+126, 0

; 4618 : 
; 4619 : 		// ------------ find my customize command ----------------------
; 4620 : 		for (i=0;i<MyData.BaseCustomizeMine.TotCustomize;i++) {

  00f8d	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$[ebp], 0
  00f97	eb 0f		 jmp	 SHORT $LN45@Get
$LN44@Get:
  00f99	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00f9f	83 c0 01	 add	 eax, 1
  00fa2	89 85 2c ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax
$LN45@Get:
  00fa8	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00fae	3b 05 8a 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3210
  00fb4	0f 8d 95 00 00
	00		 jge	 $LN43@Get

; 4621 : 			pCust = &MyData.BaseCustomizeMine.pVetCustomize[i];

  00fba	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  00fc0	8b 0d 8e 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3214
  00fc6	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00fc9	c6 85 4b fe ff
	ff 01		 mov	 BYTE PTR $T47251[ebp], 1
  00fd0	89 95 50 ff ff
	ff		 mov	 DWORD PTR _pCust$[ebp], edx

; 4622 : 
; 4623 : 			if (pCust->CustValue == Index) {

  00fd6	80 bd 4b fe ff
	ff 00		 cmp	 BYTE PTR $T47251[ebp], 0
  00fdd	75 0d		 jne	 SHORT $LN165@Get
  00fdf	68 00 00 00 00	 push	 OFFSET $LN166@Get
  00fe4	e8 00 00 00 00	 call	 __RTC_UninitUse
  00fe9	83 c4 04	 add	 esp, 4
$LN165@Get:
  00fec	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _pCust$[ebp]
  00ff2	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00ff5	3b 4d 0c	 cmp	 ecx, DWORD PTR _Index$[ebp]
  00ff8	75 50		 jne	 SHORT $LN42@Get

; 4624 : 				if (SecondaryIndex == -1 || SecondaryIndex == pCust->pVetArg[0]) {

  00ffa	83 7d 10 ff	 cmp	 DWORD PTR _SecondaryIndex$[ebp], -1
  00ffe	74 27		 je	 SHORT $LN40@Get
  01000	80 bd 4b fe ff
	ff 00		 cmp	 BYTE PTR $T47251[ebp], 0
  01007	75 0d		 jne	 SHORT $LN167@Get
  01009	68 00 00 00 00	 push	 OFFSET $LN166@Get
  0100e	e8 00 00 00 00	 call	 __RTC_UninitUse
  01013	83 c4 04	 add	 esp, 4
$LN167@Get:
  01016	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _pCust$[ebp]
  0101c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0101f	0f bf 11	 movsx	 edx, WORD PTR [ecx]
  01022	39 55 10	 cmp	 DWORD PTR _SecondaryIndex$[ebp], edx
  01025	75 23		 jne	 SHORT $LN42@Get
$LN40@Get:

; 4625 : 					GET.pCust = pCust;

  01027	80 bd 4b fe ff
	ff 00		 cmp	 BYTE PTR $T47251[ebp], 0
  0102e	75 0d		 jne	 SHORT $LN168@Get
  01030	68 00 00 00 00	 push	 OFFSET $LN166@Get
  01035	e8 00 00 00 00	 call	 __RTC_UninitUse
  0103a	83 c4 04	 add	 esp, 4
$LN168@Get:
  0103d	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _pCust$[ebp]
  01043	a3 7e 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+126, eax

; 4626 : 					break;

  01048	eb 05		 jmp	 SHORT $LN43@Get
$LN42@Get:

; 4627 : 				}
; 4628 : 			}
; 4629 : 		}

  0104a	e9 4a ff ff ff	 jmp	 $LN44@Get
$LN43@Get:

; 4630 : 		if (i== MyData.BaseCustomizeMine.TotCustomize) {

  0104f	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _i$[ebp]
  01055	3b 05 8a 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3210
  0105b	75 22		 jne	 SHORT $LN39@Get

; 4631 : 			// not found, giving warning only if it has been given also a specific ID
; 4632 : 			if (SecondaryIndex != -1) {

  0105d	83 7d 10 ff	 cmp	 DWORD PTR _SecondaryIndex$[ebp], -1
  01061	74 15		 je	 SHORT $LN38@Get

; 4633 : 				SendToLog("WARNING: not found my CUSTOMIZE with CUST_ value=%d and ID = %d",
; 4634 : 					Index, SecondaryIndex);

  01063	8b 45 10	 mov	 eax, DWORD PTR _SecondaryIndex$[ebp]
  01066	50		 push	 eax
  01067	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  0106a	51		 push	 ecx
  0106b	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@IEIDMNEG@WARNING?3?5not?5found?5my?5CUSTOMIZE?5@
  01070	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  01075	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@Get:

; 4635 : 			}
; 4636 : 			return false;

  01078	32 c0		 xor	 al, al
  0107a	e9 55 06 00 00	 jmp	 $LN157@Get
$LN39@Get:

; 4637 : 		}
; 4638 : 		GET.pCust = pCust;

  0107f	80 bd 4b fe ff
	ff 00		 cmp	 BYTE PTR $T47251[ebp], 0
  01086	75 0d		 jne	 SHORT $LN169@Get
  01088	68 00 00 00 00	 push	 OFFSET $LN166@Get
  0108d	e8 00 00 00 00	 call	 __RTC_UninitUse
  01092	83 c4 04	 add	 esp, 4
$LN169@Get:
  01095	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _pCust$[ebp]
  0109b	a3 7e 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+126, eax

; 4639 : 		break;

  010a0	e9 2d 06 00 00	 jmp	 $LN155@Get
$LN37@Get:

; 4640 : 	case GET_INPUT:
; 4641 : 		// --------- locate input of keyboard/joystick ----------------------
; 4642 : 		GET.Input.GameCommandsRead = *Trng.pGlobTomb4->pAdr->pInputGameCommands;

  010a5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  010aa	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  010b0	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  010b6	0f b7 02	 movzx	 eax, WORD PTR [edx]
  010b9	a3 8e 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+142, eax

; 4643 : 		GET.Input.pGameCommandsWrite = Trng.pGlobTomb4->pAdr->pInputGameCommands;

  010be	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  010c3	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  010c9	8b 91 88 00 00
	00		 mov	 edx, DWORD PTR [ecx+136]
  010cf	89 15 92 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+146, edx

; 4644 : 		GET.Input.InventoryCommandsRead = *Trng.pGlobTomb4->pAdr->pInputExtGameCommands;

  010d5	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  010da	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  010e0	8b 51 74	 mov	 edx, DWORD PTR [ecx+116]
  010e3	8b 02		 mov	 eax, DWORD PTR [edx]
  010e5	a3 96 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+150, eax

; 4645 : 		GET.Input.VetScanCode = Trng.pGlobTomb4->pAdr->pVetInputKeyboard;

  010ea	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  010ef	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  010f5	8b 51 7c	 mov	 edx, DWORD PTR [ecx+124]
  010f8	89 15 9a 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+154, edx

; 4646 : 		
; 4647 : 		break;

  010fe	e9 cf 05 00 00	 jmp	 $LN155@Get
$LN36@Get:

; 4648 : 	case GET_SCRIPT_SETTINGS:
; 4649 : 		pScript= &GET.ScriptSettings;

  01103	c7 85 14 ff ff
	ff b2 00 00 00	 mov	 DWORD PTR _pScript$[ebp], OFFSET ?GET@@3UStrGetLocator@@A+178

; 4650 : 		
; 4651 : 		if (Trng.pGlobTomb4->ScriptOptions.MainFlags & 1) {

  0110d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01112	0f b7 88 2a 20
	1b 00		 movzx	 ecx, WORD PTR [eax+1777706]
  01119	83 e1 01	 and	 ecx, 1
  0111c	74 0b		 je	 SHORT $LN35@Get

; 4652 : 			pScript->TestDiagnostic=true;

  0111e	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pScript$[ebp]
  01124	c6 00 01	 mov	 BYTE PTR [eax], 1

; 4653 : 		}else {

  01127	eb 09		 jmp	 SHORT $LN34@Get
$LN35@Get:

; 4654 : 			pScript->TestDiagnostic=false;

  01129	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pScript$[ebp]
  0112f	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN34@Get:

; 4655 : 		}
; 4656 : 
; 4657 : 		pScript->pFMV_Extension = &Trng.pGlobTomb4->pAdr->pScriptDat[0x29];

  01132	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01137	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0113d	8b 91 c4 00 00
	00		 mov	 edx, DWORD PTR [ecx+196]
  01143	83 c2 29	 add	 edx, 41			; 00000029H
  01146	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pScript$[ebp]
  0114c	89 50 01	 mov	 DWORD PTR [eax+1], edx

; 4658 : 
; 4659 : 		pScript->FlagsMain = *Trng.pGlobTomb4->pAdr->pScriptMainFlags;

  0114f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01154	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0115a	8b 91 c0 00 00
	00		 mov	 edx, DWORD PTR [ecx+192]
  01160	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01163	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _pScript$[ebp]
  01169	89 41 05	 mov	 DWORD PTR [ecx+5], eax

; 4660 : 		pScript->FlagsLevel = *Trng.pGlobTomb4->pAdr->pScriptLevelFlags;

  0116c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01171	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01177	8b 91 bc 00 00
	00		 mov	 edx, DWORD PTR [ecx+188]
  0117d	0f b7 02	 movzx	 eax, WORD PTR [edx]
  01180	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR _pScript$[ebp]
  01186	89 41 09	 mov	 DWORD PTR [ecx+9], eax

; 4661 : 		pScript->DiagnosticDGX = Trng.pGlobTomb4->pDiagnostica->FlagsDgx;

  01189	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0118e	8b 88 ec 20 1b
	00		 mov	 ecx, DWORD PTR [eax+1777900]
  01194	0f b7 51 39	 movzx	 edx, WORD PTR [ecx+57]
  01198	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pScript$[ebp]
  0119e	89 50 11	 mov	 DWORD PTR [eax+17], edx

; 4662 : 		pScript->DiagnosticEDGX = Trng.pGlobTomb4->pDiagnostica->DgxExtra;

  011a1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  011a6	8b 88 ec 20 1b
	00		 mov	 ecx, DWORD PTR [eax+1777900]
  011ac	0f b7 51 3b	 movzx	 edx, WORD PTR [ecx+59]
  011b0	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR _pScript$[ebp]
  011b6	89 50 0d	 mov	 DWORD PTR [eax+13], edx

; 4663 : 		break;

  011b9	e9 14 05 00 00	 jmp	 $LN155@Get
$LN33@Get:

; 4664 : 	case GET_STRINGNG:
; 4665 : 		GET.pStringNG = GetString(Index | STRING_NG);

  011be	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  011c1	0d 00 80 00 00	 or	 eax, 32768		; 00008000H
  011c6	50		 push	 eax
  011c7	e8 00 00 00 00	 call	 ?GetString@@YAPADH@Z	; GetString
  011cc	83 c4 04	 add	 esp, 4
  011cf	a3 9e 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+158, eax

; 4666 : 		break;

  011d4	e9 f9 04 00 00	 jmp	 $LN155@Get
$LN32@Get:

; 4667 : 	case GET_STRING:
; 4668 : 		GET.pString = GetString(Index);

  011d9	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  011dc	50		 push	 eax
  011dd	e8 00 00 00 00	 call	 ?GetString@@YAPADH@Z	; GetString
  011e2	83 c4 04	 add	 esp, 4
  011e5	a3 a6 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+166, eax

; 4669 : 		break;

  011ea	e9 e3 04 00 00	 jmp	 $LN155@Get
$LN31@Get:

; 4670 : 	case GET_BIG_NUMBER:
; 4671 : 		GET.BigNumber=0;

  011ef	c7 05 aa 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+170, 0

; 4672 : 		if (Index < 0 || Index >= Trng.pGlobTomb4->TotBigNumbers) {

  011f9	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  011fd	7c 10		 jl	 SHORT $LN29@Get
  011ff	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01204	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  01207	3b 88 fb f0 00
	00		 cmp	 ecx, DWORD PTR [eax+61691]
  0120d	7c 24		 jl	 SHORT $LN30@Get
$LN29@Get:

; 4673 : 			SendToLog("ERROR: Get(GET_BIG_NUMBER) invalid index (%d) for big number, outside of valid range 0 - %d",
; 4674 : 				Index, Trng.pGlobTomb4->TotBigNumbers);

  0120f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01214	8b 88 fb f0 00
	00		 mov	 ecx, DWORD PTR [eax+61691]
  0121a	51		 push	 ecx
  0121b	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  0121e	52		 push	 edx
  0121f	68 00 00 00 00	 push	 OFFSET ??_C@_0FM@KHLDPOBM@ERROR?3?5Get?$CIGET_BIG_NUMBER?$CJ?5inval@
  01224	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  01229	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4675 : 			return false;

  0122c	32 c0		 xor	 al, al
  0122e	e9 a1 04 00 00	 jmp	 $LN157@Get
$LN30@Get:

; 4676 : 		}
; 4677 : 		GET.BigNumber = Trng.pGlobTomb4->VetBigNumbers[Index];

  01233	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  01236	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0123c	0f b7 94 41 ff
	f0 00 00	 movzx	 edx, WORD PTR [ecx+eax*2+61695]
  01244	89 15 aa 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+170, edx

; 4678 : 		break;

  0124a	e9 83 04 00 00	 jmp	 $LN155@Get
$LN28@Get:

; 4679 : 	case GET_PROGRESSIVE_ACTION:
; 4680 : 		GET.pAction = GetNewProgrAction();

  0124f	e8 00 00 00 00	 call	 ?GetNewProgrAction@@YAPAUStrProgressiveAction@@XZ ; GetNewProgrAction
  01254	a3 ae 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+174, eax

; 4681 : 		break;

  01259	e9 74 04 00 00	 jmp	 $LN155@Get
$LN27@Get:

; 4682 : 	case GET_AI_ITEM:
; 4683 : 		GET.pAI=NULL;

  0125e	c7 05 8a 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+138, 0

; 4684 : 		z= *Trng.pGlobTomb4->pAdr->pTotAIData;

  01268	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0126d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01273	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  01279	8b 02		 mov	 eax, DWORD PTR [edx]
  0127b	89 85 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], eax

; 4685 : 		if (Index < 0 || Index >= z) {

  01281	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  01285	7c 0b		 jl	 SHORT $LN25@Get
  01287	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0128a	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  01290	7c 1f		 jl	 SHORT $LN26@Get
$LN25@Get:

; 4686 : 			SendToLog("ERROR: Get(GET_AI_ITEM) invalid index (%d), outside of valid range 0 - %d",
; 4687 : 				Index, z);

  01292	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  01298	50		 push	 eax
  01299	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  0129c	51		 push	 ecx
  0129d	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@GOOBMJEN@ERROR?3?5Get?$CIGET_AI_ITEM?$CJ?5invalid?5@
  012a2	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  012a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4688 : 			return false;

  012aa	32 c0		 xor	 al, al
  012ac	e9 23 04 00 00	 jmp	 $LN157@Get
$LN26@Get:

; 4689 : 		}
; 4690 : 		GET.pAI = &Trng.pGlobTomb4->pAdr->pVetAIData[Index];

  012b1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  012b6	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  012bc	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  012bf	6b d2 18	 imul	 edx, 24			; 00000018H
  012c2	03 91 80 00 00
	00		 add	 edx, DWORD PTR [ecx+128]
  012c8	89 15 8a 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+138, edx

; 4691 : 		break;		

  012ce	e9 ff 03 00 00	 jmp	 $LN155@Get
$LN24@Get:

; 4692 : 	case GET_LIGHT:
; 4693 : 		GET.pLight=NULL;

  012d3	c7 05 a2 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+162, 0

; 4694 : 
; 4695 : 		z= *Trng.pGlobTomb4->pAdr->pTotRooms;

  012dd	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  012e2	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  012e8	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  012ee	0f b7 02	 movzx	 eax, WORD PTR [edx]
  012f1	89 85 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], eax

; 4696 : 
; 4697 : 		if (Index < 0 || Index >= z) {

  012f7	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  012fb	7c 0b		 jl	 SHORT $LN22@Get
  012fd	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  01300	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  01306	7c 1f		 jl	 SHORT $LN23@Get
$LN22@Get:

; 4698 : 			SendToLog("ERROR: Get(GET_LIGHT) invalid room index (%d), outside of valid range 0 - %d",
; 4699 : 					Index, z);

  01308	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  0130e	50		 push	 eax
  0130f	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  01312	51		 push	 ecx
  01313	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@IINEOOAJ@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5ro@
  01318	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0131d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4700 : 			return false;

  01320	32 c0		 xor	 al, al
  01322	e9 ad 03 00 00	 jmp	 $LN157@Get
$LN23@Get:

; 4701 : 		}
; 4702 : 
; 4703 : 		z= Trng.pGlobTomb4->pAdr->pVetRooms[Index].TotLights;

  01327	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0132c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01332	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  01335	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  0133b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0133e	0f b7 4c 10 30	 movzx	 ecx, WORD PTR [eax+edx+48]
  01343	89 8d 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], ecx

; 4704 : 		if (SecondaryIndex < 0 || SecondaryIndex >= z) {

  01349	83 7d 10 00	 cmp	 DWORD PTR _SecondaryIndex$[ebp], 0
  0134d	7c 0b		 jl	 SHORT $LN20@Get
  0134f	8b 45 10	 mov	 eax, DWORD PTR _SecondaryIndex$[ebp]
  01352	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  01358	7c 1f		 jl	 SHORT $LN21@Get
$LN20@Get:

; 4705 : 			SendToLog("ERROR: Get(GET_LIGHT) invalid SecondaryIndex (%d), outside of valid range 0 - %d",
; 4706 : 				SecondaryIndex, z);

  0135a	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  01360	50		 push	 eax
  01361	8b 4d 10	 mov	 ecx, DWORD PTR _SecondaryIndex$[ebp]
  01364	51		 push	 ecx
  01365	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@NIKDIKMG@ERROR?3?5Get?$CIGET_LIGHT?$CJ?5invalid?5Se@
  0136a	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0136f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4707 : 			return false;

  01372	32 c0		 xor	 al, al
  01374	e9 5b 03 00 00	 jmp	 $LN157@Get
$LN21@Get:

; 4708 : 		}
; 4709 : 
; 4710 : 		GET.pLight = &Trng.pGlobTomb4->pAdr->pVetRooms[Index].pLights[SecondaryIndex];

  01379	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0137e	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01384	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  01387	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  0138d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  01390	8b 4d 10	 mov	 ecx, DWORD PTR _SecondaryIndex$[ebp]
  01393	6b c9 2e	 imul	 ecx, 46			; 0000002eH
  01396	03 4c 10 0c	 add	 ecx, DWORD PTR [eax+edx+12]
  0139a	89 0d a2 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+162, ecx

; 4711 : 		break;

  013a0	e9 2d 03 00 00	 jmp	 $LN155@Get
$LN19@Get:

; 4712 : 	case GET_CAMERA:
; 4713 : 		GET.pCamera=NULL;

  013a5	c7 05 86 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+134, 0

; 4714 : 		if (Index & NGLE_INDEX) {

  013af	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  013b2	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  013b7	74 2d		 je	 SHORT $LN18@Get

; 4715 : 			Index &= MASK_NGLE_INDEX;

  013b9	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  013bc	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  013c1	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4716 : 			TombIndex=FromNgleIndexToTomb4Index(Index);

  013c4	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  013c7	50		 push	 eax
  013c8	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  013cd	83 c4 04	 add	 esp, 4
  013d0	89 45 f8	 mov	 DWORD PTR _TombIndex$[ebp], eax

; 4717 : 			if (TombIndex==-1) return false;

  013d3	83 7d f8 ff	 cmp	 DWORD PTR _TombIndex$[ebp], -1
  013d7	75 07		 jne	 SHORT $LN17@Get
  013d9	32 c0		 xor	 al, al
  013db	e9 f4 02 00 00	 jmp	 $LN157@Get
$LN17@Get:

; 4718 : 			Index= TombIndex;

  013e0	8b 45 f8	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  013e3	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax
$LN18@Get:

; 4719 : 		}
; 4720 : 		z= *Trng.pGlobTomb4->pAdr->Camera.pTotCameras;

  013e6	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  013eb	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  013f1	8b 91 00 01 00
	00		 mov	 edx, DWORD PTR [ecx+256]
  013f7	8b 02		 mov	 eax, DWORD PTR [edx]
  013f9	89 85 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], eax

; 4721 : 		if (Index < 0 || Index >= z) {

  013ff	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  01403	7c 0b		 jl	 SHORT $LN15@Get
  01405	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  01408	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  0140e	7c 1f		 jl	 SHORT $LN16@Get
$LN15@Get:

; 4722 : 			SendToLog("ERROR: Get(GET_CAMERA), invalid index (%d), outside of valid range 0 - %d",
; 4723 : 				Index, z);

  01410	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  01416	50		 push	 eax
  01417	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  0141a	51		 push	 ecx
  0141b	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@DFOFGCKG@ERROR?3?5Get?$CIGET_CAMERA?$CJ?0?5invalid?5@
  01420	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  01425	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4724 : 			return false;

  01428	32 c0		 xor	 al, al
  0142a	e9 a5 02 00 00	 jmp	 $LN157@Get
$LN16@Get:

; 4725 : 		}
; 4726 : 		GET.pCamera = &Trng.pGlobTomb4->pAdr->Camera.pVetCamera[Index];

  0142f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01434	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0143a	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  0143d	c1 e2 04	 shl	 edx, 4
  01440	03 91 d4 00 00
	00		 add	 edx, DWORD PTR [ecx+212]
  01446	89 15 86 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+134, edx

; 4727 : 		break;

  0144c	e9 81 02 00 00	 jmp	 $LN155@Get
$LN14@Get:

; 4728 : 	case GET_CAMERA_FLY:
; 4729 : 		if (Index & NGLE_INDEX) {

  01451	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  01454	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  01459	74 2d		 je	 SHORT $LN13@Get

; 4730 : 			Index &= MASK_NGLE_INDEX;

  0145b	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  0145e	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  01463	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax

; 4731 : 			TombIndex=FromNgleIndexToTomb4Index(Index);

  01466	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  01469	50		 push	 eax
  0146a	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0146f	83 c4 04	 add	 esp, 4
  01472	89 45 f8	 mov	 DWORD PTR _TombIndex$[ebp], eax

; 4732 : 			if (TombIndex==-1) return false;

  01475	83 7d f8 ff	 cmp	 DWORD PTR _TombIndex$[ebp], -1
  01479	75 07		 jne	 SHORT $LN12@Get
  0147b	32 c0		 xor	 al, al
  0147d	e9 52 02 00 00	 jmp	 $LN157@Get
$LN12@Get:

; 4733 : 			Index= TombIndex;

  01482	8b 45 f8	 mov	 eax, DWORD PTR _TombIndex$[ebp]
  01485	89 45 0c	 mov	 DWORD PTR _Index$[ebp], eax
$LN13@Get:

; 4734 : 		}
; 4735 : 		GET.pCameraFly=NULL;

  01488	c7 05 82 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+130, 0

; 4736 : 		z= *Trng.pGlobTomb4->pAdr->pTotFlyBy;

  01492	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01497	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0149d	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  014a3	8b 02		 mov	 eax, DWORD PTR [edx]
  014a5	89 85 74 ff ff
	ff		 mov	 DWORD PTR _z$[ebp], eax

; 4737 : 		if (Index < 0 || Index >= z) {

  014ab	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  014af	7c 0b		 jl	 SHORT $LN10@Get
  014b1	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  014b4	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _z$[ebp]
  014ba	7c 1f		 jl	 SHORT $LN11@Get
$LN10@Get:

; 4738 : 			SendToLog("ERROR: Get(GET_CAMERA_FLY), invalid index (%d), outside of valid range 0 - %d",
; 4739 : 				Index, z);

  014bc	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _z$[ebp]
  014c2	50		 push	 eax
  014c3	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  014c6	51		 push	 ecx
  014c7	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@OCOFIECI@ERROR?3?5Get?$CIGET_CAMERA_FLY?$CJ?0?5inva@
  014cc	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  014d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4740 : 			return false;

  014d4	32 c0		 xor	 al, al
  014d6	e9 f9 01 00 00	 jmp	 $LN157@Get
$LN11@Get:

; 4741 : 		}
; 4742 : 		GET.pCameraFly = &Trng.pGlobTomb4->pAdr->pVetFlyBy[Index];

  014db	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  014e0	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  014e6	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  014e9	6b d2 28	 imul	 edx, 40			; 00000028H
  014ec	03 91 10 01 00
	00		 add	 edx, DWORD PTR [ecx+272]
  014f2	89 15 82 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+130, edx

; 4743 : 		break;

  014f8	e9 d5 01 00 00	 jmp	 $LN155@Get
$LN9@Get:

; 4744 : 	case GET_GAME_INFO:
; 4745 : 		pGame = &GET.GameInfo;

  014fd	c7 45 bc cb 00
	00 00		 mov	 DWORD PTR _pGame$[ebp], OFFSET ?GET@@3UStrGetLocator@@A+203

; 4746 : 
; 4747 : 		pGame->FrameCounter = *Trng.pGlobTomb4->pAdr->pFrameCounter;

  01504	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01509	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0150f	8b 91 1c 01 00
	00		 mov	 edx, DWORD PTR [ecx+284]
  01515	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  01518	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0151a	89 48 05	 mov	 DWORD PTR [eax+5], ecx

; 4748 : 		pGame->LevelIndex= *Trng.pGlobTomb4->pAdr->pLevelNow;

  0151d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01522	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01528	8b 91 b8 00 00
	00		 mov	 edx, DWORD PTR [ecx+184]
  0152e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01531	8b 4d bc	 mov	 ecx, DWORD PTR _pGame$[ebp]
  01534	89 41 01	 mov	 DWORD PTR [ecx+1], eax

; 4749 : 		pGame->RowHeight = *Trng.pGlobTomb4->pAdr->pRowCharHeight;

  01537	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0153c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01542	8b 91 ac 00 00
	00		 mov	 edx, DWORD PTR [ecx+172]
  01548	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0154b	8b 4d bc	 mov	 ecx, DWORD PTR _pGame$[ebp]
  0154e	89 41 11	 mov	 DWORD PTR [ecx+17], eax

; 4750 : 		pGame->ScreenSizeX = *Trng.pGlobTomb4->pAdr->pSizeScreenX;

  01551	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01556	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0155c	8b 91 a4 00 00
	00		 mov	 edx, DWORD PTR [ecx+164]
  01562	0f bf 02	 movsx	 eax, WORD PTR [edx]
  01565	8b 4d bc	 mov	 ecx, DWORD PTR _pGame$[ebp]
  01568	89 41 09	 mov	 DWORD PTR [ecx+9], eax

; 4751 : 		pGame->ScreenSizeY = *Trng.pGlobTomb4->pAdr->pSizeScreenY;

  0156b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01570	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01576	8b 91 a8 00 00
	00		 mov	 edx, DWORD PTR [ecx+168]
  0157c	0f bf 02	 movsx	 eax, WORD PTR [edx]
  0157f	8b 4d bc	 mov	 ecx, DWORD PTR _pGame$[ebp]
  01582	89 41 0d	 mov	 DWORD PTR [ecx+13], eax

; 4752 : 		pGame->TestVolumetric=false;

  01585	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  01588	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4753 : 		if (*Trng.pGlobTomb4->pAdr->pSetting_Volumetric != 0) {

  0158b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01590	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01596	8b 91 74 01 00
	00		 mov	 edx, DWORD PTR [ecx+372]
  0159c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0159f	85 c0		 test	 eax, eax
  015a1	74 06		 je	 SHORT $LN8@Get

; 4754 : 			pGame->TestVolumetric =true;

  015a3	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  015a6	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN8@Get:

; 4755 : 		}
; 4756 : 
; 4757 : 		pGame->AudioTrack = *Trng.pGlobTomb4->pAdr->pCDTrackNow;

  015a9	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  015ae	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  015b4	8b 91 c8 01 00
	00		 mov	 edx, DWORD PTR [ecx+456]
  015ba	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  015bd	8b 0a		 mov	 ecx, DWORD PTR [edx]
  015bf	89 48 15	 mov	 DWORD PTR [eax+21], ecx

; 4758 : 		pGame->TestAudioLooped=false;

  015c2	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  015c5	c6 40 19 00	 mov	 BYTE PTR [eax+25], 0

; 4759 : 		if (*Trng.pGlobTomb4->pAdr->pAudioTrackLoop != 0) {

  015c9	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  015ce	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  015d4	8b 91 60 01 00
	00		 mov	 edx, DWORD PTR [ecx+352]
  015da	83 3a 00	 cmp	 DWORD PTR [edx], 0
  015dd	74 07		 je	 SHORT $LN7@Get

; 4760 : 			pGame->TestAudioLooped=true;

  015df	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  015e2	c6 40 19 01	 mov	 BYTE PTR [eax+25], 1
$LN7@Get:

; 4761 : 		}
; 4762 : 
; 4763 : 		pGame->TestExclusiveVideo = IsFullScreenMode();

  015e6	e8 00 00 00 00	 call	 ?IsFullScreenMode@@YA_NXZ ; IsFullScreenMode
  015eb	8b 4d bc	 mov	 ecx, DWORD PTR _pGame$[ebp]
  015ee	88 41 1a	 mov	 BYTE PTR [ecx+26], al

; 4764 : 		pGame->pVar = Trng.pGlobTomb4->pBaseVariableTRNG;

  015f1	8b 45 bc	 mov	 eax, DWORD PTR _pGame$[ebp]
  015f4	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  015fa	8b 91 8a 02 01
	00		 mov	 edx, DWORD PTR [ecx+66186]
  01600	89 50 1b	 mov	 DWORD PTR [eax+27], edx

; 4765 : 	
; 4766 : 	
; 4767 : 		break;

  01603	e9 ca 00 00 00	 jmp	 $LN155@Get
$LN6@Get:

; 4768 : 	case GET_SLOT:
; 4769 : 		if (Index < 0 || Index >= enumSLOT.NUMBER_OBJECTS) {

  01608	83 7d 0c 00	 cmp	 DWORD PTR _Index$[ebp], 0
  0160c	7c 0b		 jl	 SHORT $LN4@Get
  0160e	8b 45 0c	 mov	 eax, DWORD PTR _Index$[ebp]
  01611	3b 05 20 08 00
	00		 cmp	 eax, DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2080
  01617	7c 1e		 jl	 SHORT $LN5@Get
$LN4@Get:

; 4770 : 			SendToLog("ERROR: Get(GET_SLOT) Invalid index value (%d), outside of valid range 0 - %d", Index,
; 4771 : 				enumSLOT.NUMBER_OBJECTS);

  01619	a1 20 08 00 00	 mov	 eax, DWORD PTR ?enumSLOT@@3UStrEnumSLOT@@A+2080
  0161e	50		 push	 eax
  0161f	8b 4d 0c	 mov	 ecx, DWORD PTR _Index$[ebp]
  01622	51		 push	 ecx
  01623	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GIKIANME@ERROR?3?5Get?$CIGET_SLOT?$CJ?5Invalid?5ind@
  01628	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0162d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4772 : 			return false;

  01630	32 c0		 xor	 al, al
  01632	e9 9d 00 00 00	 jmp	 $LN157@Get
$LN5@Get:

; 4773 : 		}
; 4774 : 		GET.pSlot = &Trng.pGlobTomb4->pAdr->pVetSlot[Index];

  01637	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0163c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01642	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  01645	c1 e2 06	 shl	 edx, 6
  01648	03 51 18	 add	 edx, DWORD PTR [ecx+24]
  0164b	89 15 ea 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+234, edx

; 4775 : 		break;

  01651	eb 7f		 jmp	 SHORT $LN155@Get
$LN3@Get:

; 4776 : 	case GET_INVENTORY:
; 4777 : 		GET.pInventory = Trng.pGlobTomb4->pAdr->pInventory;

  01653	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01658	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0165e	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  01661	89 15 ee 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+238, edx

; 4778 : 		GET.InventoryData.pItemPresence = GET.pInventory;

  01667	a1 ee 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+238
  0166c	a3 fc 00 00 00	 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+252, eax

; 4779 : 		GET.InventoryData.pChosenItemSlot = Trng.pGlobTomb4->pAdr->pInventoryChosenItem;

  01671	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  01676	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0167c	8b 91 14 02 00
	00		 mov	 edx, DWORD PTR [ecx+532]
  01682	89 15 00 01 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+256, edx

; 4780 : 		GET.InventoryData.pRequiredItemSlot = Trng.pGlobTomb4->pAdr->pInventoryRequiredSlotItem;

  01688	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0168d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  01693	8b 91 10 02 00
	00		 mov	 edx, DWORD PTR [ecx+528]
  01699	89 15 04 01 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+260, edx

; 4781 : 		break;

  0169f	eb 31		 jmp	 SHORT $LN155@Get
$LN2@Get:

; 4782 : 	case GET_ANIMATION:
; 4783 : 		GET.pAnimation = &Trng.pGlobTomb4->pAdr->pVetAnimations[Index];

  016a1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  016a6	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  016ac	8b 55 0c	 mov	 edx, DWORD PTR _Index$[ebp]
  016af	6b d2 28	 imul	 edx, 40			; 00000028H
  016b2	03 51 30	 add	 edx, DWORD PTR [ecx+48]
  016b5	89 15 f2 00 00
	00		 mov	 DWORD PTR ?GET@@3UStrGetLocator@@A+242, edx

; 4784 : 		break;

  016bb	eb 15		 jmp	 SHORT $LN155@Get
$LN1@Get:

; 4785 : 	default:
; 4786 : 		SendToLog("ERROR: unknown meaning of GET_ constant with value = %d", GET_Type);

  016bd	8b 45 08	 mov	 eax, DWORD PTR _GET_Type$[ebp]
  016c0	50		 push	 eax
  016c1	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@DEBNJFPA@ERROR?3?5unknown?5meaning?5of?5GET_?5c@
  016c6	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  016cb	83 c4 08	 add	 esp, 8

; 4787 : 		return false;

  016ce	32 c0		 xor	 al, al
  016d0	eb 02		 jmp	 SHORT $LN157@Get
$LN155@Get:

; 4788 : 
; 4789 : 	}
; 4790 : 
; 4791 : 
; 4792 : 	return true;

  016d2	b0 01		 mov	 al, 1
$LN157@Get:

; 4793 : 	
; 4794 : }

  016d4	52		 push	 edx
  016d5	8b cd		 mov	 ecx, ebp
  016d7	50		 push	 eax
  016d8	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN173@Get
  016de	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  016e3	58		 pop	 eax
  016e4	5a		 pop	 edx
  016e5	5f		 pop	 edi
  016e6	5e		 pop	 esi
  016e7	5b		 pop	 ebx
  016e8	81 c4 cc 01 00
	00		 add	 esp, 460		; 000001ccH
  016ee	3b ec		 cmp	 ebp, esp
  016f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  016f5	8b e5		 mov	 esp, ebp
  016f7	5d		 pop	 ebp
  016f8	c3		 ret	 0
  016f9	8d 49 00	 npad	 3
$LN173@Get:
  016fc	02 00 00 00	 DD	 2
  01700	00 00 00 00	 DD	 $LN172@Get
$LN172@Get:
  01704	ec ff ff ff	 DD	 -20			; ffffffecH
  01708	04 00 00 00	 DD	 4
  0170c	00 00 00 00	 DD	 $LN170@Get
  01710	e0 ff ff ff	 DD	 -32			; ffffffe0H
  01714	04 00 00 00	 DD	 4
  01718	00 00 00 00	 DD	 $LN171@Get
$LN171@Get:
  0171c	53		 DB	 83			; 00000053H
  0171d	74		 DB	 116			; 00000074H
  0171e	61		 DB	 97			; 00000061H
  0171f	74		 DB	 116			; 00000074H
  01720	69		 DB	 105			; 00000069H
  01721	63		 DB	 99			; 00000063H
  01722	49		 DB	 73			; 00000049H
  01723	6e		 DB	 110			; 0000006eH
  01724	64		 DB	 100			; 00000064H
  01725	65		 DB	 101			; 00000065H
  01726	78		 DB	 120			; 00000078H
  01727	00		 DB	 0
$LN170@Get:
  01728	52		 DB	 82			; 00000052H
  01729	6f		 DB	 111			; 0000006fH
  0172a	6f		 DB	 111			; 0000006fH
  0172b	6d		 DB	 109			; 0000006dH
  0172c	49		 DB	 73			; 00000049H
  0172d	6e		 DB	 110			; 0000006eH
  0172e	64		 DB	 100			; 00000064H
  0172f	65		 DB	 101			; 00000065H
  01730	78		 DB	 120			; 00000078H
  01731	00		 DB	 0
$LN166@Get:
  01732	70		 DB	 112			; 00000070H
  01733	43		 DB	 67			; 00000043H
  01734	75		 DB	 117			; 00000075H
  01735	73		 DB	 115			; 00000073H
  01736	74		 DB	 116			; 00000074H
  01737	00		 DB	 0
$LN161@Get:
  01738	70		 DB	 112			; 00000070H
  01739	50		 DB	 80			; 00000050H
  0173a	61		 DB	 97			; 00000061H
  0173b	72		 DB	 114			; 00000072H
  0173c	61		 DB	 97			; 00000061H
  0173d	6d		 DB	 109			; 0000006dH
  0173e	00		 DB	 0
  0173f	90		 npad	 1
$LN174@Get:
  01740	00 00 00 00	 DD	 $LN133@Get
  01744	00 00 00 00	 DD	 $LN132@Get
  01748	00 00 00 00	 DD	 $LN127@Get
  0174c	00 00 00 00	 DD	 $LN119@Get
  01750	00 00 00 00	 DD	 $LN114@Get
  01754	00 00 00 00	 DD	 $LN109@Get
  01758	00 00 00 00	 DD	 $LN109@Get
  0175c	00 00 00 00	 DD	 $LN99@Get
  01760	00 00 00 00	 DD	 $LN96@Get
  01764	00 00 00 00	 DD	 $LN54@Get
  01768	00 00 00 00	 DD	 $LN46@Get
  0176c	00 00 00 00	 DD	 $LN37@Get
  01770	00 00 00 00	 DD	 $LN33@Get
  01774	00 00 00 00	 DD	 $LN32@Get
  01778	00 00 00 00	 DD	 $LN31@Get
  0177c	00 00 00 00	 DD	 $LN36@Get
  01780	00 00 00 00	 DD	 $LN28@Get
  01784	00 00 00 00	 DD	 $LN27@Get
  01788	00 00 00 00	 DD	 $LN24@Get
  0178c	00 00 00 00	 DD	 $LN19@Get
  01790	00 00 00 00	 DD	 $LN14@Get
  01794	00 00 00 00	 DD	 $LN116@Get
  01798	00 00 00 00	 DD	 $LN9@Get
  0179c	00 00 00 00	 DD	 $LN6@Get
  017a0	00 00 00 00	 DD	 $LN3@Get
  017a4	00 00 00 00	 DD	 $LN2@Get
  017a8	00 00 00 00	 DD	 $LN152@Get
  017ac	00 00 00 00	 DD	 $LN153@Get
  017b0	00 00 00 00	 DD	 $LN154@Get
?Get@@YA_NHHH@Z ENDP					; Get
_TEXT	ENDS
PUBLIC	??_C@_0DM@KNMGNNCA@ERROR?3?5in?5Get?$CIFIND_ITEMS_SECTOR?0@ ; `string'
PUBLIC	??_C@_0DM@HFEHHMNJ@ERROR?3?5in?5Get?$CIFIND_ITEMS_NEARBY?0@ ; `string'
PUBLIC	??_C@_0DO@HKNFJDMA@ERROR?3?5in?5Get?$CIFIND_STATICS_NEARB@ ; `string'
PUBLIC	??_C@_0DO@KCFEDCDJ@ERROR?3?5in?5Get?$CIFIND_STATICS_SECTO@ ; `string'
PUBLIC	?Find@@YA_NHFFFHPAX@Z				; Find
;	COMDAT ??_C@_0DM@KNMGNNCA@ERROR?3?5in?5Get?$CIFIND_ITEMS_SECTOR?0@
CONST	SEGMENT
??_C@_0DM@KNMGNNCA@ERROR?3?5in?5Get?$CIFIND_ITEMS_SECTOR?0@ DB 'ERROR: in'
	DB	' Get(FIND_ITEMS_SECTOR,): missing valid room index', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HFEHHMNJ@ERROR?3?5in?5Get?$CIFIND_ITEMS_NEARBY?0@
CONST	SEGMENT
??_C@_0DM@HFEHHMNJ@ERROR?3?5in?5Get?$CIFIND_ITEMS_NEARBY?0@ DB 'ERROR: in'
	DB	' Get(FIND_ITEMS_NEARBY,): missing valid room index', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@HKNFJDMA@ERROR?3?5in?5Get?$CIFIND_STATICS_NEARB@
CONST	SEGMENT
??_C@_0DO@HKNFJDMA@ERROR?3?5in?5Get?$CIFIND_STATICS_NEARB@ DB 'ERROR: in '
	DB	'Get(FIND_STATICS_NEARBY,): missing valid room index', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@KCFEDCDJ@ERROR?3?5in?5Get?$CIFIND_STATICS_SECTO@
CONST	SEGMENT
??_C@_0DO@KCFEDCDJ@ERROR?3?5in?5Get?$CIFIND_STATICS_SECTO@ DB 'ERROR: in '
	DB	'Get(FIND_STATICS_SECTOR,): missing valid room index', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?Find@@YA_NHFFFHPAX@Z
_TEXT	SEGMENT
tv64 = -424						; size = 4
_MaxZ$ = -224						; size = 4
_MinZ$ = -212						; size = 4
_MaxX$ = -200						; size = 4
_MinX$ = -188						; size = 4
_NewRoom$ = -176					; size = 2
_pPos$ = -164						; size = 4
_pAI$ = -152						; size = 4
_pStatic$ = -140					; size = 4
_j$ = -128						; size = 4
_LastRoomIndex$ = -116					; size = 4
_pFly$ = -104						; size = 4
_FirstRoomIndex$ = -92					; size = 4
_pRoom$ = -80						; size = 4
_z$ = -68						; size = 4
_pAction$ = -56						; size = 4
_i$ = -44						; size = 4
_TestOk$ = -29						; size = 1
_pItem$ = -20						; size = 4
_IndexNow$ = -8						; size = 4
_FindType$ = 8						; size = 4
_SlotType$ = 12						; size = 2
_RoomIndex$ = 16					; size = 2
_Ocb$ = 20						; size = 2
_Extra$ = 24						; size = 4
_pPointer$ = 28						; size = 4
?Find@@YA_NHFFFHPAX@Z PROC				; Find, COMDAT

; 4801 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a8 01 00
	00		 sub	 esp, 424		; 000001a8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 58 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-424]
  00012	b9 6a 00 00 00	 mov	 ecx, 106		; 0000006aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 4802 : 	int IndexNow;
; 4803 : 	StrItemTr4 *pItem;
; 4804 : 	bool TestOk;
; 4805 : 	int i;
; 4806 : 	StrProgressiveAction *pAction;
; 4807 : 	int z;
; 4808 : 	StrRoomTr4 *pRoom;
; 4809 : 	int FirstRoomIndex;
; 4810 : 	StrFlyByTr4 *pFly;
; 4811 : 	int LastRoomIndex;
; 4812 : 	int j;
; 4813 : 	StrMeshInfo *pStatic;
; 4814 : 	StrAIDataTr4 *pAI;
; 4815 : 	StrTriplePoint *pPos;
; 4816 : 	short NewRoom;
; 4817 : 	DWORD MinX, MaxX, MinZ, MaxZ;
; 4818 : 
; 4819 : 
; 4820 : 	switch (FindType)

  0001e	8b 45 08	 mov	 eax, DWORD PTR _FindType$[ebp]
  00021	89 85 58 fe ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00027	83 bd 58 fe ff
	ff 10		 cmp	 DWORD PTR tv64[ebp], 16	; 00000010H
  0002e	0f 87 af 0f 00
	00		 ja	 $LN129@Find
  00034	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  0003a	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN136@Find[ecx*4]
$LN128@Find:

; 4821 : 	{
; 4822 : 	case FIND_ASSIGN_SLOT_MINE:
; 4823 : 		FIND.SlotAssigned = -1;

  00041	83 c8 ff	 or	 eax, -1
  00044	66 a3 ac 14 00
	00		 mov	 WORD PTR ?FIND@@3UStrFind@@A+5292, ax

; 4824 : 
; 4825 : 		for (i=0;i<MyData.BaseAssignSlotMine.TotAssign;i++) {

  0004a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00051	eb 09		 jmp	 SHORT $LN127@Find
$LN126@Find:
  00053	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN127@Find:
  0005c	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0005f	3b 05 9a 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3226
  00065	7d 29		 jge	 SHORT $LN125@Find

; 4826 : 			if (MyData.BaseAssignSlotMine.VetAssignSlot[i].TipoSlot == SlotType) {

  00067	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0006a	0f b7 0c 85 a0
	0c 00 00	 movzx	 ecx, WORD PTR ?MyData@@3UStrMyData@@A[eax*4+3232]
  00072	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00076	3b ca		 cmp	 ecx, edx
  00078	75 14		 jne	 SHORT $LN124@Find

; 4827 : 				FIND.SlotAssigned= MyData.BaseAssignSlotMine.VetAssignSlot[i].MioSlot;

  0007a	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	66 8b 0c 85 9e
	0c 00 00	 mov	 cx, WORD PTR ?MyData@@3UStrMyData@@A[eax*4+3230]
  00085	66 89 0d ac 14
	00 00		 mov	 WORD PTR ?FIND@@3UStrFind@@A+5292, cx

; 4828 : 				break;

  0008c	eb 02		 jmp	 SHORT $LN125@Find
$LN124@Find:

; 4829 : 			}
; 4830 : 		}

  0008e	eb c3		 jmp	 SHORT $LN126@Find
$LN125@Find:

; 4831 : 		if (FIND.SlotAssigned==-1) return false;

  00090	0f bf 05 ac 14
	00 00		 movsx	 eax, WORD PTR ?FIND@@3UStrFind@@A+5292
  00097	83 f8 ff	 cmp	 eax, -1
  0009a	75 07		 jne	 SHORT $LN123@Find
  0009c	32 c0		 xor	 al, al
  0009e	e9 42 0f 00 00	 jmp	 $LN131@Find
$LN123@Find:

; 4832 : 		break;

  000a3	e9 3b 0f 00 00	 jmp	 $LN129@Find
$LN122@Find:

; 4833 : 
; 4834 : 	case FIND_PROGR_ACTION_TRNG:
; 4835 : 		FIND.TotProgAxnTrng=0;

  000a8	c7 05 70 11 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4464, 0

; 4836 : 		pAction = &Trng.pGlobTomb4->VetProgressiveActions[0];

  000b2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000b7	05 2f d9 1a 00	 add	 eax, 1759535		; 001ad92fH
  000bc	89 45 c8	 mov	 DWORD PTR _pAction$[ebp], eax

; 4837 : 		for (i=0;i<Trng.pGlobTomb4->TotProgressiveActions;i++) {

  000bf	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000c6	eb 09		 jmp	 SHORT $LN121@Find
$LN120@Find:
  000c8	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  000cb	83 c0 01	 add	 eax, 1
  000ce	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN121@Find:
  000d1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000d6	0f b7 88 2d d9
	1a 00		 movzx	 ecx, WORD PTR [eax+1759533]
  000dd	39 4d d4	 cmp	 DWORD PTR _i$[ebp], ecx
  000e0	7d 49		 jge	 SHORT $LN119@Find

; 4838 : 			if (pAction->ActionType == SlotType && 
; 4839 : 				(Extra == -1 || Extra == pAction->ItemIndex)) {

  000e2	8b 45 c8	 mov	 eax, DWORD PTR _pAction$[ebp]
  000e5	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000e8	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  000ec	3b ca		 cmp	 ecx, edx
  000ee	75 30		 jne	 SHORT $LN118@Find
  000f0	83 7d 18 ff	 cmp	 DWORD PTR _Extra$[ebp], -1
  000f4	74 0c		 je	 SHORT $LN117@Find
  000f6	8b 45 c8	 mov	 eax, DWORD PTR _pAction$[ebp]
  000f9	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  000fd	39 4d 18	 cmp	 DWORD PTR _Extra$[ebp], ecx
  00100	75 1e		 jne	 SHORT $LN118@Find
$LN117@Find:

; 4840 : 				// found a trng action
; 4841 : 				FIND.pVetProgAxnTrng[FIND.TotProgAxnTrng++] = pAction;

  00102	a1 70 11 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+4464
  00107	8b 4d c8	 mov	 ecx, DWORD PTR _pAction$[ebp]
  0010a	89 0c 85 74 11
	00 00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A[eax*4+4468], ecx
  00111	8b 15 70 11 00
	00		 mov	 edx, DWORD PTR ?FIND@@3UStrFind@@A+4464
  00117	83 c2 01	 add	 edx, 1
  0011a	89 15 70 11 00
	00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4464, edx
$LN118@Find:

; 4842 : 			}
; 4843 : 			pAction++;

  00120	8b 45 c8	 mov	 eax, DWORD PTR _pAction$[ebp]
  00123	83 c0 20	 add	 eax, 32			; 00000020H
  00126	89 45 c8	 mov	 DWORD PTR _pAction$[ebp], eax

; 4844 : 		}

  00129	eb 9d		 jmp	 SHORT $LN120@Find
$LN119@Find:

; 4845 : 		if (FIND.TotProgAxnTrng==0) return false;

  0012b	83 3d 70 11 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+4464, 0
  00132	75 07		 jne	 SHORT $LN116@Find
  00134	32 c0		 xor	 al, al
  00136	e9 aa 0e 00 00	 jmp	 $LN131@Find
$LN116@Find:

; 4846 : 		break;

  0013b	e9 a3 0e 00 00	 jmp	 $LN129@Find
$LN115@Find:

; 4847 : 
; 4848 : 	case FIND_PROGR_ACTION_MINE:
; 4849 : 		FIND.TotProgAxnMine=0;

  00140	c7 05 04 13 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4868, 0

; 4850 : 		pAction = &MyData.VetProgrActions[0];

  0014a	c7 45 c8 0a 00
	00 00		 mov	 DWORD PTR _pAction$[ebp], OFFSET ?MyData@@3UStrMyData@@A+10

; 4851 : 		for (i=0;i<MyData.TotProgrActions;i++) {

  00151	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00158	eb 09		 jmp	 SHORT $LN114@Find
$LN113@Find:
  0015a	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  0015d	83 c0 01	 add	 eax, 1
  00160	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN114@Find:
  00163	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00166	3b 05 02 00 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  0016c	7d 49		 jge	 SHORT $LN112@Find

; 4852 : 			if (pAction->ActionType == SlotType && 
; 4853 : 				(Extra == -1 || Extra == pAction->ItemIndex)) {

  0016e	8b 45 c8	 mov	 eax, DWORD PTR _pAction$[ebp]
  00171	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00174	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00178	3b ca		 cmp	 ecx, edx
  0017a	75 30		 jne	 SHORT $LN111@Find
  0017c	83 7d 18 ff	 cmp	 DWORD PTR _Extra$[ebp], -1
  00180	74 0c		 je	 SHORT $LN110@Find
  00182	8b 45 c8	 mov	 eax, DWORD PTR _pAction$[ebp]
  00185	0f bf 48 02	 movsx	 ecx, WORD PTR [eax+2]
  00189	39 4d 18	 cmp	 DWORD PTR _Extra$[ebp], ecx
  0018c	75 1e		 jne	 SHORT $LN111@Find
$LN110@Find:

; 4854 : 				// found an action of mine
; 4855 : 				FIND.pVetProgAxnMine[FIND.TotProgAxnMine++] = pAction;

  0018e	a1 04 13 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+4868
  00193	8b 4d c8	 mov	 ecx, DWORD PTR _pAction$[ebp]
  00196	89 0c 85 08 13
	00 00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A[eax*4+4872], ecx
  0019d	8b 15 04 13 00
	00		 mov	 edx, DWORD PTR ?FIND@@3UStrFind@@A+4868
  001a3	83 c2 01	 add	 edx, 1
  001a6	89 15 04 13 00
	00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4868, edx
$LN111@Find:

; 4856 : 			}
; 4857 : 			pAction++;

  001ac	8b 45 c8	 mov	 eax, DWORD PTR _pAction$[ebp]
  001af	83 c0 20	 add	 eax, 32			; 00000020H
  001b2	89 45 c8	 mov	 DWORD PTR _pAction$[ebp], eax

; 4858 : 		}

  001b5	eb a3		 jmp	 SHORT $LN113@Find
$LN112@Find:

; 4859 : 		if (FIND.TotProgAxnMine == 0) return false;

  001b7	83 3d 04 13 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+4868, 0
  001be	75 07		 jne	 SHORT $LN109@Find
  001c0	32 c0		 xor	 al, al
  001c2	e9 1e 0e 00 00	 jmp	 $LN131@Find
$LN109@Find:

; 4860 : 		break;

  001c7	e9 17 0e 00 00	 jmp	 $LN129@Find
$LN108@Find:

; 4861 : 
; 4862 : 	case FIND_ENEMY_COMMAND:
; 4863 : 		FIND.pEnemy=NULL;

  001cc	c7 05 98 14 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5272, 0

; 4864 : 		// looks for enemy= script command with Slot = Slot
; 4865 : 		for (i=0;i<Trng.pGlobTomb4->BaseEnemys.TotEnemy;i++) {

  001d6	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  001dd	eb 09		 jmp	 SHORT $LN107@Find
$LN106@Find:
  001df	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  001e2	83 c0 01	 add	 eax, 1
  001e5	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN107@Find:
  001e8	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  001ed	8b 4d d4	 mov	 ecx, DWORD PTR _i$[ebp]
  001f0	3b 88 05 22 1b
	00		 cmp	 ecx, DWORD PTR [eax+1778181]
  001f6	7d 39		 jge	 SHORT $LN105@Find

; 4866 : 			if (Trng.pGlobTomb4->BaseEnemys.VetEnemy[i].SlotId == SlotType) {

  001f8	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  001fb	6b c0 1c	 imul	 eax, 28			; 0000001cH
  001fe	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00204	0f b7 94 01 09
	22 1b 00	 movzx	 edx, WORD PTR [ecx+eax+1778185]
  0020c	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00210	3b d0		 cmp	 edx, eax
  00212	75 1b		 jne	 SHORT $LN104@Find

; 4867 : 				FIND.pEnemy = &Trng.pGlobTomb4->BaseEnemys.VetEnemy[i];

  00214	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00217	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0021a	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00220	8d 94 01 09 22
	1b 00		 lea	 edx, DWORD PTR [ecx+eax+1778185]
  00227	89 15 98 14 00
	00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5272, edx

; 4868 : 				break;

  0022d	eb 02		 jmp	 SHORT $LN105@Find
$LN104@Find:

; 4869 : 			}
; 4870 : 		}

  0022f	eb ae		 jmp	 SHORT $LN106@Find
$LN105@Find:

; 4871 : 
; 4872 : 		if (FIND.pEnemy==NULL) return false;

  00231	83 3d 98 14 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+5272, 0
  00238	75 07		 jne	 SHORT $LN103@Find
  0023a	32 c0		 xor	 al, al
  0023c	e9 a4 0d 00 00	 jmp	 $LN131@Find
$LN103@Find:

; 4873 : 		break;

  00241	e9 9d 0d 00 00	 jmp	 $LN129@Find
$LN102@Find:

; 4874 : 
; 4875 : 	case FIND_IMAGE_COMMAND:
; 4876 : 		FIND.pImage=NULL;

  00246	c7 05 9c 14 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5276, 0

; 4877 : 		// looks for Image= script command with Id = Extra
; 4878 : 		
; 4879 : 		j= Trng.pGlobTomb4->pBaseScriptImages->VetID[Extra];

  00250	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00255	8b 88 44 0d 07
	00		 mov	 ecx, DWORD PTR [eax+462148]
  0025b	8b 55 18	 mov	 edx, DWORD PTR _Extra$[ebp]
  0025e	0f bf 84 51 54
	14 00 00	 movsx	 eax, WORD PTR [ecx+edx*2+5204]
  00266	89 45 80	 mov	 DWORD PTR _j$[ebp], eax

; 4880 : 		
; 4881 : 		if (j == -1) return false;

  00269	83 7d 80 ff	 cmp	 DWORD PTR _j$[ebp], -1
  0026d	75 07		 jne	 SHORT $LN101@Find
  0026f	32 c0		 xor	 al, al
  00271	e9 6f 0d 00 00	 jmp	 $LN131@Find
$LN101@Find:

; 4882 : 
; 4883 : 		FIND.pImage = &Trng.pGlobTomb4->pBaseScriptImages->VetImages[j];

  00276	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0027b	8b 88 44 0d 07
	00		 mov	 ecx, DWORD PTR [eax+462148]
  00281	8b 55 80	 mov	 edx, DWORD PTR _j$[ebp]
  00284	6b d2 1a	 imul	 edx, 26			; 0000001aH
  00287	8d 44 11 04	 lea	 eax, DWORD PTR [ecx+edx+4]
  0028b	a3 9c 14 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5276, eax

; 4884 : 		break;

  00290	e9 4e 0d 00 00	 jmp	 $LN129@Find
$LN100@Find:

; 4885 : 
; 4886 : 	case FIND_WINDOWS_FONT:
; 4887 : 		FIND.pWindowsFont=NULL;

  00295	c7 05 a0 14 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5280, 0

; 4888 : 
; 4889 : 		j= Trng.pGlobTomb4->BaseFonts.VetID[Extra];

  0029f	8b 45 18	 mov	 eax, DWORD PTR _Extra$[ebp]
  002a2	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002a8	0f bf 94 41 de
	32 01 00	 movsx	 edx, WORD PTR [ecx+eax*2+78558]
  002b0	89 55 80	 mov	 DWORD PTR _j$[ebp], edx

; 4890 : 		if (j==-1) return false;

  002b3	83 7d 80 ff	 cmp	 DWORD PTR _j$[ebp], -1
  002b7	75 07		 jne	 SHORT $LN99@Find
  002b9	32 c0		 xor	 al, al
  002bb	e9 25 0d 00 00	 jmp	 $LN131@Find
$LN99@Find:

; 4891 : 
; 4892 : 		FIND.pWindowsFont = &Trng.pGlobTomb4->BaseFonts.VetFonts[j];

  002c0	8b 45 80	 mov	 eax, DWORD PTR _j$[ebp]
  002c3	6b c0 72	 imul	 eax, 114		; 00000072H
  002c6	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002cc	8d 94 01 56 06
	01 00		 lea	 edx, DWORD PTR [ecx+eax+67158]
  002d3	89 15 a0 14 00
	00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5280, edx

; 4893 : 		break;

  002d9	e9 05 0d 00 00	 jmp	 $LN129@Find
$LN98@Find:

; 4894 : 
; 4895 : 	case FIND_DIAGNOSTIC:
; 4896 : 		FIND.Dgx.FlagsDgx= Trng.pGlobTomb4->pDiagnostica->FlagsDgx;

  002de	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002e3	8b 88 ec 20 1b
	00		 mov	 ecx, DWORD PTR [eax+1777900]
  002e9	66 8b 51 39	 mov	 dx, WORD PTR [ecx+57]
  002ed	66 89 15 a4 14
	00 00		 mov	 WORD PTR ?FIND@@3UStrFind@@A+5284, dx

; 4897 : 		FIND.Dgx.DgxExtra = Trng.pGlobTomb4->pDiagnostica->DgxExtra;

  002f4	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002f9	8b 88 ec 20 1b
	00		 mov	 ecx, DWORD PTR [eax+1777900]
  002ff	66 8b 51 3b	 mov	 dx, WORD PTR [ecx+59]
  00303	66 89 15 a6 14
	00 00		 mov	 WORD PTR ?FIND@@3UStrFind@@A+5286, dx

; 4898 : 		FIND.Dgx.pLogItem = &Trng.pGlobTomb4->pDiagnostica->LogItem;

  0030a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0030f	8b 88 ec 20 1b
	00		 mov	 ecx, DWORD PTR [eax+1777900]
  00315	81 c1 9d 0a 00
	00		 add	 ecx, 2717		; 00000a9dH
  0031b	89 0d a8 14 00
	00		 mov	 DWORD PTR ?FIND@@3UStrFind@@A+5288, ecx

; 4899 : 		break;

  00321	e9 bd 0c 00 00	 jmp	 $LN129@Find
$LN97@Find:

; 4900 : 		
; 4901 : 
; 4902 : 	case FIND_ITEM:
; 4903 : 		FIND.TotItems=0;

  00326	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, 0

; 4904 : 
; 4905 : 		// it will be very different the code in according wether RoomIndex has been suplied or less
; 4906 : 		if (RoomIndex != -1) {

  00330	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00334	83 f8 ff	 cmp	 eax, -1
  00337	0f 84 cb 00 00
	00		 je	 $LN96@Find

; 4907 : 			// RoomIndex has a valid value: looking for movables chain of given room
; 4908 : 			IndexNow = Trng.pGlobTomb4->pAdr->pVetRooms[RoomIndex].FirstItemIndex;

  0033d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00342	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00348	0f bf 55 10	 movsx	 edx, WORD PTR _RoomIndex$[ebp]
  0034c	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00352	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00355	0f bf 4c 10 48	 movsx	 ecx, WORD PTR [eax+edx+72]
  0035a	89 4d f8	 mov	 DWORD PTR _IndexNow$[ebp], ecx
$LN95@Find:

; 4909 : 			while (IndexNow != -1) {

  0035d	83 7d f8 ff	 cmp	 DWORD PTR _IndexNow$[ebp], -1
  00361	0f 84 8c 00 00
	00		 je	 $LN94@Find

; 4910 : 			
; 4911 : 				pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexNow];

  00367	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0036c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00372	8b 55 f8	 mov	 edx, DWORD PTR _IndexNow$[ebp]
  00375	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  0037b	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  0037e	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 4912 : 				// if this item has SlotType and Ocb as required store its index
; 4913 : 				TestOk=true;

  00381	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 4914 : 				
; 4915 : 				if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;

  00385	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00389	83 f8 ff	 cmp	 eax, -1
  0038c	74 13		 je	 SHORT $LN93@Find
  0038e	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00391	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00395	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00399	3b ca		 cmp	 ecx, edx
  0039b	74 04		 je	 SHORT $LN93@Find
  0039d	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN93@Find:

; 4916 : 				if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

  003a1	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  003a5	83 f8 ff	 cmp	 eax, -1
  003a8	74 13		 je	 SHORT $LN92@Find
  003aa	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  003ad	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  003b1	0f bf 55 14	 movsx	 edx, WORD PTR _Ocb$[ebp]
  003b5	3b ca		 cmp	 ecx, edx
  003b7	74 04		 je	 SHORT $LN92@Find
  003b9	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN92@Find:

; 4917 : 
; 4918 : 				if (TestOk == true) {

  003bd	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  003c1	83 f8 01	 cmp	 eax, 1
  003c4	75 1e		 jne	 SHORT $LN91@Find

; 4919 : 					FIND.VetItems[FIND.TotItems] = IndexNow;

  003c6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  003cb	66 8b 4d f8	 mov	 cx, WORD PTR _IndexNow$[ebp]
  003cf	66 89 0c 45 04
	00 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+4], cx

; 4920 : 					FIND.TotItems++;

  003d7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  003dc	83 c0 01	 add	 eax, 1
  003df	a3 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, eax
$LN91@Find:

; 4921 : 				}
; 4922 : 				// detect next moveable in this room
; 4923 : 				IndexNow= pItem->ItemIndexNext;

  003e4	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  003e7	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  003eb	89 4d f8	 mov	 DWORD PTR _IndexNow$[ebp], ecx

; 4924 : 			}

  003ee	e9 6a ff ff ff	 jmp	 $LN95@Find
$LN94@Find:

; 4925 : 
; 4926 : 			if (FIND.TotItems==0) return false;

  003f3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A, 0
  003fa	75 07		 jne	 SHORT $LN90@Find
  003fc	32 c0		 xor	 al, al
  003fe	e9 e2 0b 00 00	 jmp	 $LN131@Find
$LN90@Find:

; 4927 : 			break;

  00403	e9 db 0b 00 00	 jmp	 $LN129@Find
$LN96@Find:

; 4928 : 		}
; 4929 : 
; 4930 : 		// missing RoomIndex: looking for moveable in all moveable items of the level
; 4931 : 		pItem = &Trng.pGlobTomb4->pAdr->pVetItems[0];

  00408	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0040d	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00413	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00416	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 4932 : 		for (i=0;i< Trng.pGlobTomb4->pAdr->TotItemsMax;i++) {

  00419	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00420	eb 09		 jmp	 SHORT $LN89@Find
$LN88@Find:
  00422	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00425	83 c0 01	 add	 eax, 1
  00428	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN89@Find:
  0042b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00430	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00436	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00439	3b 91 0c 02 00
	00		 cmp	 edx, DWORD PTR [ecx+524]
  0043f	7d 73		 jge	 SHORT $LN87@Find

; 4933 : 			TestOk=true;

  00441	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 4934 : 
; 4935 : 			if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;

  00445	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00449	83 f8 ff	 cmp	 eax, -1
  0044c	74 13		 je	 SHORT $LN86@Find
  0044e	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00451	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00455	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00459	3b ca		 cmp	 ecx, edx
  0045b	74 04		 je	 SHORT $LN86@Find
  0045d	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN86@Find:

; 4936 : 
; 4937 : 			if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

  00461	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00465	83 f8 ff	 cmp	 eax, -1
  00468	74 13		 je	 SHORT $LN85@Find
  0046a	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  0046d	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  00471	0f bf 55 14	 movsx	 edx, WORD PTR _Ocb$[ebp]
  00475	3b ca		 cmp	 ecx, edx
  00477	74 04		 je	 SHORT $LN85@Find
  00479	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN85@Find:

; 4938 : 
; 4939 : 			if (TestOk == true) {

  0047d	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  00481	83 f8 01	 cmp	 eax, 1
  00484	75 1e		 jne	 SHORT $LN84@Find

; 4940 : 				FIND.VetItems[FIND.TotItems] = i;

  00486	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  0048b	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  0048f	66 89 0c 45 04
	00 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+4], cx

; 4941 : 				FIND.TotItems++;

  00497	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  0049c	83 c0 01	 add	 eax, 1
  0049f	a3 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, eax
$LN84@Find:

; 4942 : 								
; 4943 : 			}
; 4944 : 			pItem++; 

  004a4	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  004a7	05 f6 15 00 00	 add	 eax, 5622		; 000015f6H
  004ac	89 45 ec	 mov	 DWORD PTR _pItem$[ebp], eax

; 4945 : 		}

  004af	e9 6e ff ff ff	 jmp	 $LN88@Find
$LN87@Find:

; 4946 : 
; 4947 : 		if (FIND.TotItems==0) return false;

  004b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A, 0
  004bb	75 07		 jne	 SHORT $LN83@Find
  004bd	32 c0		 xor	 al, al
  004bf	e9 21 0b 00 00	 jmp	 $LN131@Find
$LN83@Find:

; 4948 : 		break;

  004c4	e9 1a 0b 00 00	 jmp	 $LN129@Find
$LN82@Find:

; 4949 : 	case FIND_STATICS_SECTOR:
; 4950 : 		FIND.TotStatics=0;

  004c9	c7 05 04 08 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2052, 0

; 4951 : 		pPos = (StrTriplePoint*) pPointer;

  004d3	8b 45 1c	 mov	 eax, DWORD PTR _pPointer$[ebp]
  004d6	89 85 5c ff ff
	ff		 mov	 DWORD PTR _pPos$[ebp], eax

; 4952 : 		if (RoomIndex == -1) {

  004dc	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  004e0	83 f8 ff	 cmp	 eax, -1
  004e3	75 14		 jne	 SHORT $LN81@Find

; 4953 : 			SendToLog("ERROR: in Get(FIND_STATICS_SECTOR,): missing valid room index");

  004e5	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@KCFEDCDJ@ERROR?3?5in?5Get?$CIFIND_STATICS_SECTO@
  004ea	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  004ef	83 c4 04	 add	 esp, 4

; 4954 : 			return false;

  004f2	32 c0		 xor	 al, al
  004f4	e9 ec 0a 00 00	 jmp	 $LN131@Find
$LN81@Find:

; 4955 : 		}
; 4956 : 		NewRoom = RoomIndex;

  004f9	66 8b 45 10	 mov	 ax, WORD PTR _RoomIndex$[ebp]
  004fd	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _NewRoom$[ebp], ax

; 4957 : 
; 4958 : 		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

  00504	8b f4		 mov	 esi, esp
  00506	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _NewRoom$[ebp]
  0050c	50		 push	 eax
  0050d	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pPos$[ebp]
  00513	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00516	52		 push	 edx
  00517	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  0051d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00520	51		 push	 ecx
  00521	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _pPos$[ebp]
  00527	8b 02		 mov	 eax, DWORD PTR [edx]
  00529	50		 push	 eax
  0052a	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetFloor@@3P6APAXKHKPAF@ZA ; GetFloor
  00530	83 c4 10	 add	 esp, 16			; 00000010H
  00533	3b f4		 cmp	 esi, esp
  00535	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4959 : 
; 4960 : 		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

  0053a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0053f	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00545	0f bf 95 50 ff
	ff ff		 movsx	 edx, WORD PTR _NewRoom$[ebp]
  0054c	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00552	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00555	89 55 b0	 mov	 DWORD PTR _pRoom$[ebp], edx

; 4961 : 
; 4962 : 		// compute the bondary coordinates of current sector
; 4963 : 		MinX = pPos->CordX & ~0x3ff;

  00558	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  0055e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00560	81 e1 00 fc ff
	ff		 and	 ecx, -1024		; fffffc00H
  00566	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _MinX$[ebp], ecx

; 4964 : 		MinZ = pPos->CordZ & ~0x3ff;

  0056c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  00572	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00575	81 e1 00 fc ff
	ff		 and	 ecx, -1024		; fffffc00H
  0057b	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _MinZ$[ebp], ecx

; 4965 : 
; 4966 : 		MaxX = MinX + 1023;

  00581	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _MinX$[ebp]
  00587	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  0058c	89 85 38 ff ff
	ff		 mov	 DWORD PTR _MaxX$[ebp], eax

; 4967 : 		MaxZ = MinZ + 1023;

  00592	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _MinZ$[ebp]
  00598	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  0059d	89 85 20 ff ff
	ff		 mov	 DWORD PTR _MaxZ$[ebp], eax

; 4968 : 
; 4969 : 		for (i=0;i<pRoom->TotStaticMesh;i++) {

  005a3	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  005aa	eb 09		 jmp	 SHORT $LN80@Find
$LN79@Find:
  005ac	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  005af	83 c0 01	 add	 eax, 1
  005b2	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN80@Find:
  005b5	8b 45 b0	 mov	 eax, DWORD PTR _pRoom$[ebp]
  005b8	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  005bc	39 4d d4	 cmp	 DWORD PTR _i$[ebp], ecx
  005bf	0f 8d 8b 00 00
	00		 jge	 $LN78@Find

; 4970 : 			pStatic = &pRoom->Ptr_StaticMesh[i];

  005c5	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  005c8	6b c0 14	 imul	 eax, 20			; 00000014H
  005cb	8b 4d b0	 mov	 ecx, DWORD PTR _pRoom$[ebp]
  005ce	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  005d1	89 85 74 ff ff
	ff		 mov	 DWORD PTR _pStatic$[ebp], eax

; 4971 : 
; 4972 : 			if (pStatic->x >= MinX && pStatic->x <= MaxX &&
; 4973 : 				pStatic->z >= MinZ && pStatic->z <= MaxZ) {

  005d7	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pStatic$[ebp]
  005dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  005df	3b 8d 44 ff ff
	ff		 cmp	 ecx, DWORD PTR _MinX$[ebp]
  005e5	72 64		 jb	 SHORT $LN77@Find
  005e7	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pStatic$[ebp]
  005ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  005ef	3b 8d 38 ff ff
	ff		 cmp	 ecx, DWORD PTR _MaxX$[ebp]
  005f5	77 54		 ja	 SHORT $LN77@Find
  005f7	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pStatic$[ebp]
  005fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00600	3b 8d 2c ff ff
	ff		 cmp	 ecx, DWORD PTR _MinZ$[ebp]
  00606	72 43		 jb	 SHORT $LN77@Find
  00608	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pStatic$[ebp]
  0060e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00611	3b 8d 20 ff ff
	ff		 cmp	 ecx, DWORD PTR _MaxZ$[ebp]
  00617	77 32		 ja	 SHORT $LN77@Find

; 4974 : 
; 4975 : 				FIND.VetStatics[FIND.TotStatics].ObjIndex = i;

  00619	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  0061e	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00622	66 89 0c 85 0a
	08 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2058], cx

; 4976 : 				FIND.VetStatics[FIND.TotStatics].RoomIndex = NewRoom;

  0062a	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  0062f	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _NewRoom$[ebp]
  00636	66 89 0c 85 08
	08 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2056], cx

; 4977 : 				FIND.TotStatics++;

  0063e	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  00643	83 c0 01	 add	 eax, 1
  00646	a3 04 08 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2052, eax
$LN77@Find:

; 4978 : 			}
; 4979 : 		}

  0064b	e9 5c ff ff ff	 jmp	 $LN79@Find
$LN78@Find:

; 4980 : 		if (FIND.TotStatics ==0) return false;

  00650	83 3d 04 08 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+2052, 0
  00657	75 07		 jne	 SHORT $LN76@Find
  00659	32 c0		 xor	 al, al
  0065b	e9 85 09 00 00	 jmp	 $LN131@Find
$LN76@Find:

; 4981 : 		break;

  00660	e9 7e 09 00 00	 jmp	 $LN129@Find
$LN75@Find:

; 4982 : 
; 4983 : 	case FIND_STATICS_NEARBY:
; 4984 : 		FIND.TotStatics=0;

  00665	c7 05 04 08 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2052, 0

; 4985 : 		pPos = (StrTriplePoint*) pPointer;

  0066f	8b 45 1c	 mov	 eax, DWORD PTR _pPointer$[ebp]
  00672	89 85 5c ff ff
	ff		 mov	 DWORD PTR _pPos$[ebp], eax

; 4986 : 		if (RoomIndex == -1) {

  00678	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  0067c	83 f8 ff	 cmp	 eax, -1
  0067f	75 14		 jne	 SHORT $LN74@Find

; 4987 : 			SendToLog("ERROR: in Get(FIND_STATICS_NEARBY,): missing valid room index");

  00681	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@HKNFJDMA@ERROR?3?5in?5Get?$CIFIND_STATICS_NEARB@
  00686	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0068b	83 c4 04	 add	 esp, 4

; 4988 : 			return false;

  0068e	32 c0		 xor	 al, al
  00690	e9 50 09 00 00	 jmp	 $LN131@Find
$LN74@Find:

; 4989 : 		}
; 4990 : 		NewRoom = RoomIndex;

  00695	66 8b 45 10	 mov	 ax, WORD PTR _RoomIndex$[ebp]
  00699	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _NewRoom$[ebp], ax

; 4991 : 
; 4992 : 		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

  006a0	8b f4		 mov	 esi, esp
  006a2	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _NewRoom$[ebp]
  006a8	50		 push	 eax
  006a9	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pPos$[ebp]
  006af	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  006b2	52		 push	 edx
  006b3	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  006b9	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  006bc	51		 push	 ecx
  006bd	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _pPos$[ebp]
  006c3	8b 02		 mov	 eax, DWORD PTR [edx]
  006c5	50		 push	 eax
  006c6	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetFloor@@3P6APAXKHKPAF@ZA ; GetFloor
  006cc	83 c4 10	 add	 esp, 16			; 00000010H
  006cf	3b f4		 cmp	 esi, esp
  006d1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 4993 : 
; 4994 : 		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

  006d6	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  006db	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  006e1	0f bf 95 50 ff
	ff ff		 movsx	 edx, WORD PTR _NewRoom$[ebp]
  006e8	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  006ee	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  006f1	89 55 b0	 mov	 DWORD PTR _pRoom$[ebp], edx

; 4995 : 		for (i=0;i<pRoom->TotStaticMesh;i++) {

  006f4	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  006fb	eb 09		 jmp	 SHORT $LN73@Find
$LN72@Find:
  006fd	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00700	83 c0 01	 add	 eax, 1
  00703	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN73@Find:
  00706	8b 45 b0	 mov	 eax, DWORD PTR _pRoom$[ebp]
  00709	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  0070d	39 4d d4	 cmp	 DWORD PTR _i$[ebp], ecx
  00710	0f 8d 90 00 00
	00		 jge	 $LN71@Find

; 4996 : 			pStatic = &pRoom->Ptr_StaticMesh[i];

  00716	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00719	6b c0 14	 imul	 eax, 20			; 00000014H
  0071c	8b 4d b0	 mov	 ecx, DWORD PTR _pRoom$[ebp]
  0071f	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00722	89 85 74 ff ff
	ff		 mov	 DWORD PTR _pStatic$[ebp], eax

; 4997 : 
; 4998 : 			if (GetDistanceXZY(pPos->CordX, pPos->CordY, pPos->CordZ, 
; 4999 : 				pStatic->x, pStatic->y, pStatic->z) <= Extra) {

  00728	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _pStatic$[ebp]
  0072e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00731	51		 push	 ecx
  00732	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR _pStatic$[ebp]
  00738	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0073b	50		 push	 eax
  0073c	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _pStatic$[ebp]
  00742	8b 11		 mov	 edx, DWORD PTR [ecx]
  00744	52		 push	 edx
  00745	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  0074b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0074e	51		 push	 ecx
  0074f	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _pPos$[ebp]
  00755	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00758	50		 push	 eax
  00759	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pPos$[ebp]
  0075f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00761	52		 push	 edx
  00762	e8 00 00 00 00	 call	 ?GetDistanceXZY@@YAHKHKKHK@Z ; GetDistanceXZY
  00767	83 c4 18	 add	 esp, 24			; 00000018H
  0076a	3b 45 18	 cmp	 eax, DWORD PTR _Extra$[ebp]
  0076d	7f 32		 jg	 SHORT $LN70@Find

; 5000 : 				FIND.VetStatics[FIND.TotStatics].ObjIndex = i;

  0076f	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  00774	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00778	66 89 0c 85 0a
	08 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2058], cx

; 5001 : 				FIND.VetStatics[FIND.TotStatics].RoomIndex = NewRoom;

  00780	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  00785	66 8b 8d 50 ff
	ff ff		 mov	 cx, WORD PTR _NewRoom$[ebp]
  0078c	66 89 0c 85 08
	08 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2056], cx

; 5002 : 				FIND.TotStatics++;

  00794	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  00799	83 c0 01	 add	 eax, 1
  0079c	a3 04 08 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2052, eax
$LN70@Find:

; 5003 : 			}
; 5004 : 		}

  007a1	e9 57 ff ff ff	 jmp	 $LN72@Find
$LN71@Find:

; 5005 : 		if (FIND.TotStatics ==0) return false;

  007a6	83 3d 04 08 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+2052, 0
  007ad	75 07		 jne	 SHORT $LN69@Find
  007af	32 c0		 xor	 al, al
  007b1	e9 2f 08 00 00	 jmp	 $LN131@Find
$LN69@Find:

; 5006 : 		break;

  007b6	e9 28 08 00 00	 jmp	 $LN129@Find
$LN68@Find:

; 5007 : 		
; 5008 : 	case FIND_ITEMS_NEARBY:
; 5009 : 		FIND.TotItems=0;

  007bb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, 0

; 5010 : 		pPos = (StrTriplePoint*) pPointer;

  007c5	8b 45 1c	 mov	 eax, DWORD PTR _pPointer$[ebp]
  007c8	89 85 5c ff ff
	ff		 mov	 DWORD PTR _pPos$[ebp], eax

; 5011 : 		if (RoomIndex == -1) {

  007ce	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  007d2	83 f8 ff	 cmp	 eax, -1
  007d5	75 14		 jne	 SHORT $LN67@Find

; 5012 : 			SendToLog("ERROR: in Get(FIND_ITEMS_NEARBY,): missing valid room index");

  007d7	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HFEHHMNJ@ERROR?3?5in?5Get?$CIFIND_ITEMS_NEARBY?0@
  007dc	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  007e1	83 c4 04	 add	 esp, 4

; 5013 : 			return false;

  007e4	32 c0		 xor	 al, al
  007e6	e9 fa 07 00 00	 jmp	 $LN131@Find
$LN67@Find:

; 5014 : 		}
; 5015 : 		NewRoom = RoomIndex;

  007eb	66 8b 45 10	 mov	 ax, WORD PTR _RoomIndex$[ebp]
  007ef	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _NewRoom$[ebp], ax

; 5016 : 
; 5017 : 		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

  007f6	8b f4		 mov	 esi, esp
  007f8	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _NewRoom$[ebp]
  007fe	50		 push	 eax
  007ff	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pPos$[ebp]
  00805	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00808	52		 push	 edx
  00809	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  0080f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00812	51		 push	 ecx
  00813	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _pPos$[ebp]
  00819	8b 02		 mov	 eax, DWORD PTR [edx]
  0081b	50		 push	 eax
  0081c	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetFloor@@3P6APAXKHKPAF@ZA ; GetFloor
  00822	83 c4 10	 add	 esp, 16			; 00000010H
  00825	3b f4		 cmp	 esi, esp
  00827	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 5018 : 
; 5019 : 		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

  0082c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00831	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00837	0f bf 95 50 ff
	ff ff		 movsx	 edx, WORD PTR _NewRoom$[ebp]
  0083e	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00844	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00847	89 55 b0	 mov	 DWORD PTR _pRoom$[ebp], edx

; 5020 : 
; 5021 : 		IndexNow =pRoom->FirstItemIndex;

  0084a	8b 45 b0	 mov	 eax, DWORD PTR _pRoom$[ebp]
  0084d	0f bf 48 48	 movsx	 ecx, WORD PTR [eax+72]
  00851	89 4d f8	 mov	 DWORD PTR _IndexNow$[ebp], ecx
$LN66@Find:

; 5022 : 
; 5023 : 		while (IndexNow != -1) {

  00854	83 7d f8 ff	 cmp	 DWORD PTR _IndexNow$[ebp], -1
  00858	0f 84 cb 00 00
	00		 je	 $LN65@Find

; 5024 : 		
; 5025 : 			pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexNow];

  0085e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00863	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00869	8b 55 f8	 mov	 edx, DWORD PTR _IndexNow$[ebp]
  0086c	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00872	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00875	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 5026 : 			// first to check if this item has SlotType and Ocb as required
; 5027 : 			TestOk=true;

  00878	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 5028 : 			
; 5029 : 			if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;

  0087c	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00880	83 f8 ff	 cmp	 eax, -1
  00883	74 13		 je	 SHORT $LN64@Find
  00885	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00888	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0088c	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00890	3b ca		 cmp	 ecx, edx
  00892	74 04		 je	 SHORT $LN64@Find
  00894	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN64@Find:

; 5030 : 			if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

  00898	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  0089c	83 f8 ff	 cmp	 eax, -1
  0089f	74 13		 je	 SHORT $LN63@Find
  008a1	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  008a4	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  008a8	0f bf 55 14	 movsx	 edx, WORD PTR _Ocb$[ebp]
  008ac	3b ca		 cmp	 ecx, edx
  008ae	74 04		 je	 SHORT $LN63@Find
  008b0	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN63@Find:

; 5031 : 
; 5032 : 			if (TestOk == true) {

  008b4	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  008b8	83 f8 01	 cmp	 eax, 1
  008bb	75 5d		 jne	 SHORT $LN62@Find

; 5033 : 				// verify distance
; 5034 : 
; 5035 : 				if (GetDistanceXZY(pPos->CordX, pPos->CordY, pPos->CordZ, 
; 5036 : 										pItem->CordX, pItem->CordY, pItem->CordZ) <= Extra) {

  008bd	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  008c0	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  008c3	51		 push	 ecx
  008c4	8b 55 ec	 mov	 edx, DWORD PTR _pItem$[ebp]
  008c7	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  008ca	50		 push	 eax
  008cb	8b 4d ec	 mov	 ecx, DWORD PTR _pItem$[ebp]
  008ce	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  008d1	52		 push	 edx
  008d2	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  008d8	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  008db	51		 push	 ecx
  008dc	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _pPos$[ebp]
  008e2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  008e5	50		 push	 eax
  008e6	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pPos$[ebp]
  008ec	8b 11		 mov	 edx, DWORD PTR [ecx]
  008ee	52		 push	 edx
  008ef	e8 00 00 00 00	 call	 ?GetDistanceXZY@@YAHKHKKHK@Z ; GetDistanceXZY
  008f4	83 c4 18	 add	 esp, 24			; 00000018H
  008f7	3b 45 18	 cmp	 eax, DWORD PTR _Extra$[ebp]
  008fa	7f 1e		 jg	 SHORT $LN62@Find

; 5037 : 
; 5038 : 					FIND.VetItems[FIND.TotItems] = IndexNow;

  008fc	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  00901	66 8b 4d f8	 mov	 cx, WORD PTR _IndexNow$[ebp]
  00905	66 89 0c 45 04
	00 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+4], cx

; 5039 : 					FIND.TotItems++;

  0090d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  00912	83 c0 01	 add	 eax, 1
  00915	a3 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, eax
$LN62@Find:

; 5040 : 				}
; 5041 : 			
; 5042 : 			}
; 5043 : 			// detect next moveable in this room
; 5044 : 			IndexNow= pItem->ItemIndexNext;

  0091a	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  0091d	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00921	89 4d f8	 mov	 DWORD PTR _IndexNow$[ebp], ecx

; 5045 : 		}

  00924	e9 2b ff ff ff	 jmp	 $LN66@Find
$LN65@Find:

; 5046 : 		if (FIND.TotItems == 0) return false;

  00929	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A, 0
  00930	75 07		 jne	 SHORT $LN60@Find
  00932	32 c0		 xor	 al, al
  00934	e9 ac 06 00 00	 jmp	 $LN131@Find
$LN60@Find:

; 5047 : 		break;

  00939	e9 a5 06 00 00	 jmp	 $LN129@Find
$LN59@Find:

; 5048 : 
; 5049 : 	case FIND_ITEMS_SECTOR:
; 5050 : 		FIND.TotItems=0;

  0093e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, 0

; 5051 : 		pPos = (StrTriplePoint*) pPointer;

  00948	8b 45 1c	 mov	 eax, DWORD PTR _pPointer$[ebp]
  0094b	89 85 5c ff ff
	ff		 mov	 DWORD PTR _pPos$[ebp], eax

; 5052 : 
; 5053 : 		if (RoomIndex == -1) {

  00951	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00955	83 f8 ff	 cmp	 eax, -1
  00958	75 14		 jne	 SHORT $LN58@Find

; 5054 : 			SendToLog("ERROR: in Get(FIND_ITEMS_SECTOR,): missing valid room index");

  0095a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@KNMGNNCA@ERROR?3?5in?5Get?$CIFIND_ITEMS_SECTOR?0@
  0095f	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00964	83 c4 04	 add	 esp, 4

; 5055 : 			return false;

  00967	32 c0		 xor	 al, al
  00969	e9 77 06 00 00	 jmp	 $LN131@Find
$LN58@Find:

; 5056 : 		}
; 5057 : 
; 5058 : 		NewRoom = RoomIndex;

  0096e	66 8b 45 10	 mov	 ax, WORD PTR _RoomIndex$[ebp]
  00972	66 89 85 50 ff
	ff ff		 mov	 WORD PTR _NewRoom$[ebp], ax

; 5059 : 
; 5060 : 		GetFloor(pPos->CordX, pPos->CordY, pPos->CordZ, &NewRoom);

  00979	8b f4		 mov	 esi, esp
  0097b	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _NewRoom$[ebp]
  00981	50		 push	 eax
  00982	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _pPos$[ebp]
  00988	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0098b	52		 push	 edx
  0098c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  00992	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00995	51		 push	 ecx
  00996	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR _pPos$[ebp]
  0099c	8b 02		 mov	 eax, DWORD PTR [edx]
  0099e	50		 push	 eax
  0099f	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetFloor@@3P6APAXKHKPAF@ZA ; GetFloor
  009a5	83 c4 10	 add	 esp, 16			; 00000010H
  009a8	3b f4		 cmp	 esi, esp
  009aa	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 5061 : 
; 5062 : 		pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[NewRoom];

  009af	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  009b4	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  009ba	0f bf 95 50 ff
	ff ff		 movsx	 edx, WORD PTR _NewRoom$[ebp]
  009c1	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  009c7	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  009ca	89 55 b0	 mov	 DWORD PTR _pRoom$[ebp], edx

; 5063 : 
; 5064 : 		// compute the bondary coordinates of current sector
; 5065 : 		MinX = pPos->CordX & ~0x3ff;

  009cd	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  009d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  009d5	81 e1 00 fc ff
	ff		 and	 ecx, -1024		; fffffc00H
  009db	89 8d 44 ff ff
	ff		 mov	 DWORD PTR _MinX$[ebp], ecx

; 5066 : 		MinZ = pPos->CordZ & ~0x3ff;

  009e1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _pPos$[ebp]
  009e7	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  009ea	81 e1 00 fc ff
	ff		 and	 ecx, -1024		; fffffc00H
  009f0	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _MinZ$[ebp], ecx

; 5067 : 
; 5068 : 		MaxX = MinX + 1023;

  009f6	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR _MinX$[ebp]
  009fc	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  00a01	89 85 38 ff ff
	ff		 mov	 DWORD PTR _MaxX$[ebp], eax

; 5069 : 		MaxZ = MinZ + 1023;

  00a07	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _MinZ$[ebp]
  00a0d	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  00a12	89 85 20 ff ff
	ff		 mov	 DWORD PTR _MaxZ$[ebp], eax

; 5070 : 
; 5071 : 
; 5072 : 		IndexNow =pRoom->FirstItemIndex;

  00a18	8b 45 b0	 mov	 eax, DWORD PTR _pRoom$[ebp]
  00a1b	0f bf 48 48	 movsx	 ecx, WORD PTR [eax+72]
  00a1f	89 4d f8	 mov	 DWORD PTR _IndexNow$[ebp], ecx
$LN57@Find:

; 5073 : 
; 5074 : 		while (IndexNow != -1) {

  00a22	83 7d f8 ff	 cmp	 DWORD PTR _IndexNow$[ebp], -1
  00a26	0f 84 c4 00 00
	00		 je	 $LN56@Find

; 5075 : 		
; 5076 : 			pItem = &Trng.pGlobTomb4->pAdr->pVetItems[IndexNow];

  00a2c	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00a31	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00a37	8b 55 f8	 mov	 edx, DWORD PTR _IndexNow$[ebp]
  00a3a	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00a40	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00a43	89 55 ec	 mov	 DWORD PTR _pItem$[ebp], edx

; 5077 : 			// first to check if this item has SlotType and Ocb as required
; 5078 : 			TestOk=true;

  00a46	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 5079 : 			
; 5080 : 			if (SlotType != -1 && pItem->SlotID != SlotType) TestOk=false;

  00a4a	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00a4e	83 f8 ff	 cmp	 eax, -1
  00a51	74 13		 je	 SHORT $LN55@Find
  00a53	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00a56	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00a5a	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00a5e	3b ca		 cmp	 ecx, edx
  00a60	74 04		 je	 SHORT $LN55@Find
  00a62	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN55@Find:

; 5081 : 			if (Ocb != -1 && pItem->OcbCode != Ocb) TestOk=false;

  00a66	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00a6a	83 f8 ff	 cmp	 eax, -1
  00a6d	74 13		 je	 SHORT $LN54@Find
  00a6f	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00a72	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  00a76	0f bf 55 14	 movsx	 edx, WORD PTR _Ocb$[ebp]
  00a7a	3b ca		 cmp	 ecx, edx
  00a7c	74 04		 je	 SHORT $LN54@Find
  00a7e	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN54@Find:

; 5082 : 
; 5083 : 			if (TestOk == true) {

  00a82	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  00a86	83 f8 01	 cmp	 eax, 1
  00a89	75 56		 jne	 SHORT $LN53@Find

; 5084 : 				// verify if the item is in boundaries of current sector
; 5085 : 
; 5086 : 				if (pItem->CordX >= MinX && pItem->CordX <= MaxX && 
; 5087 : 					pItem->CordZ >= MinZ && pItem->CordZ <= MaxZ) {

  00a8b	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00a8e	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00a91	3b 8d 44 ff ff
	ff		 cmp	 ecx, DWORD PTR _MinX$[ebp]
  00a97	72 48		 jb	 SHORT $LN53@Find
  00a99	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00a9c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00a9f	3b 8d 38 ff ff
	ff		 cmp	 ecx, DWORD PTR _MaxX$[ebp]
  00aa5	77 3a		 ja	 SHORT $LN53@Find
  00aa7	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00aaa	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00aad	3b 8d 2c ff ff
	ff		 cmp	 ecx, DWORD PTR _MinZ$[ebp]
  00ab3	72 2c		 jb	 SHORT $LN53@Find
  00ab5	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00ab8	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00abb	3b 8d 20 ff ff
	ff		 cmp	 ecx, DWORD PTR _MaxZ$[ebp]
  00ac1	77 1e		 ja	 SHORT $LN53@Find

; 5088 : 
; 5089 : 					FIND.VetItems[FIND.TotItems] = IndexNow;

  00ac3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  00ac8	66 8b 4d f8	 mov	 cx, WORD PTR _IndexNow$[ebp]
  00acc	66 89 0c 45 04
	00 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+4], cx

; 5090 : 					FIND.TotItems++;

  00ad4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A
  00ad9	83 c0 01	 add	 eax, 1
  00adc	a3 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A, eax
$LN53@Find:

; 5091 : 				}
; 5092 : 			
; 5093 : 			}
; 5094 : 			// detect next moveable in this room
; 5095 : 			IndexNow= pItem->ItemIndexNext;

  00ae1	8b 45 ec	 mov	 eax, DWORD PTR _pItem$[ebp]
  00ae4	0f bf 48 1a	 movsx	 ecx, WORD PTR [eax+26]
  00ae8	89 4d f8	 mov	 DWORD PTR _IndexNow$[ebp], ecx

; 5096 : 		}

  00aeb	e9 32 ff ff ff	 jmp	 $LN57@Find
$LN56@Find:

; 5097 : 		if (FIND.TotItems == 0) return false;

  00af0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A, 0
  00af7	75 07		 jne	 SHORT $LN51@Find
  00af9	32 c0		 xor	 al, al
  00afb	e9 e5 04 00 00	 jmp	 $LN131@Find
$LN51@Find:

; 5098 : 		break;

  00b00	e9 de 04 00 00	 jmp	 $LN129@Find
$LN50@Find:

; 5099 : 
; 5100 : 	case FIND_STATIC:
; 5101 : 		FIND.TotStatics=0;

  00b05	c7 05 04 08 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2052, 0

; 5102 : 		// if it has been supplied the RoomIndex, looking for static only in that room
; 5103 : 		if (RoomIndex != -1) {

  00b0f	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00b13	83 f8 ff	 cmp	 eax, -1
  00b16	74 13		 je	 SHORT $LN49@Find

; 5104 : 			FirstRoomIndex = RoomIndex;

  00b18	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00b1c	89 45 a4	 mov	 DWORD PTR _FirstRoomIndex$[ebp], eax

; 5105 : 			LastRoomIndex = RoomIndex +1;

  00b1f	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00b23	83 c0 01	 add	 eax, 1
  00b26	89 45 8c	 mov	 DWORD PTR _LastRoomIndex$[ebp], eax

; 5106 : 		}else {

  00b29	eb 1e		 jmp	 SHORT $LN48@Find
$LN49@Find:

; 5107 : 			// otherwise, looking in all rooms
; 5108 : 			FirstRoomIndex = 0;

  00b2b	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _FirstRoomIndex$[ebp], 0

; 5109 : 			LastRoomIndex = *Trng.pGlobTomb4->pAdr->pTotRooms;

  00b32	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00b37	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00b3d	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  00b43	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00b46	89 45 8c	 mov	 DWORD PTR _LastRoomIndex$[ebp], eax
$LN48@Find:

; 5110 : 		}
; 5111 : 
; 5112 : 		for (i=FirstRoomIndex;i<LastRoomIndex; i++) {

  00b49	8b 45 a4	 mov	 eax, DWORD PTR _FirstRoomIndex$[ebp]
  00b4c	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
  00b4f	eb 09		 jmp	 SHORT $LN47@Find
$LN46@Find:
  00b51	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00b54	83 c0 01	 add	 eax, 1
  00b57	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN47@Find:
  00b5a	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00b5d	3b 45 8c	 cmp	 eax, DWORD PTR _LastRoomIndex$[ebp]
  00b60	0f 8d d6 00 00
	00		 jge	 $LN45@Find

; 5113 : 			pRoom = &Trng.pGlobTomb4->pAdr->pVetRooms[i];

  00b66	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00b6b	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00b71	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00b74	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00b7a	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00b7d	89 55 b0	 mov	 DWORD PTR _pRoom$[ebp], edx

; 5114 : 
; 5115 : 			// parse all statics of this room
; 5116 : 
; 5117 : 			for (j=0;j< pRoom->TotStaticMesh;j++) {

  00b80	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00b87	eb 09		 jmp	 SHORT $LN44@Find
$LN43@Find:
  00b89	8b 45 80	 mov	 eax, DWORD PTR _j$[ebp]
  00b8c	83 c0 01	 add	 eax, 1
  00b8f	89 45 80	 mov	 DWORD PTR _j$[ebp], eax
$LN44@Find:
  00b92	8b 45 b0	 mov	 eax, DWORD PTR _pRoom$[ebp]
  00b95	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  00b99	39 4d 80	 cmp	 DWORD PTR _j$[ebp], ecx
  00b9c	0f 8d 95 00 00
	00		 jge	 $LN42@Find

; 5118 : 				
; 5119 : 				pStatic = &pRoom->Ptr_StaticMesh[j];

  00ba2	8b 45 80	 mov	 eax, DWORD PTR _j$[ebp]
  00ba5	6b c0 14	 imul	 eax, 20			; 00000014H
  00ba8	8b 4d b0	 mov	 ecx, DWORD PTR _pRoom$[ebp]
  00bab	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00bae	89 85 74 ff ff
	ff		 mov	 DWORD PTR _pStatic$[ebp], eax

; 5120 : 
; 5121 : 				TestOk=true;

  00bb4	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 5122 : 
; 5123 : 				if (SlotType != -1 && SlotType != pStatic->SlotId) TestOk=false;

  00bb8	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00bbc	83 f8 ff	 cmp	 eax, -1
  00bbf	74 16		 je	 SHORT $LN41@Find
  00bc1	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00bc5	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _pStatic$[ebp]
  00bcb	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  00bcf	3b c2		 cmp	 eax, edx
  00bd1	74 04		 je	 SHORT $LN41@Find
  00bd3	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN41@Find:

; 5124 : 
; 5125 : 				if (Ocb != -1 && Ocb != pStatic->OCB) TestOk=false;

  00bd7	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00bdb	83 f8 ff	 cmp	 eax, -1
  00bde	74 16		 je	 SHORT $LN40@Find
  00be0	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00be4	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _pStatic$[ebp]
  00bea	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00bee	3b c2		 cmp	 eax, edx
  00bf0	74 04		 je	 SHORT $LN40@Find
  00bf2	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN40@Find:

; 5126 : 
; 5127 : 				if (TestOk==true) {

  00bf6	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  00bfa	83 f8 01	 cmp	 eax, 1
  00bfd	75 33		 jne	 SHORT $LN39@Find

; 5128 : 					// save the indices
; 5129 : 					z= FIND.TotStatics;

  00bff	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  00c04	89 45 bc	 mov	 DWORD PTR _z$[ebp], eax

; 5130 : 
; 5131 : 					FIND.VetStatics[z].RoomIndex = i;

  00c07	8b 45 bc	 mov	 eax, DWORD PTR _z$[ebp]
  00c0a	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00c0e	66 89 0c 85 08
	08 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2056], cx

; 5132 : 					FIND.VetStatics[z].ObjIndex = j;

  00c16	8b 45 bc	 mov	 eax, DWORD PTR _z$[ebp]
  00c19	66 8b 4d 80	 mov	 cx, WORD PTR _j$[ebp]
  00c1d	66 89 0c 85 0a
	08 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2058], cx

; 5133 : 					FIND.TotStatics++;

  00c25	a1 04 08 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2052
  00c2a	83 c0 01	 add	 eax, 1
  00c2d	a3 04 08 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2052, eax
$LN39@Find:

; 5134 : 
; 5135 : 				}
; 5136 : 			}

  00c32	e9 52 ff ff ff	 jmp	 $LN43@Find
$LN42@Find:

; 5137 : 
; 5138 : 		}

  00c37	e9 15 ff ff ff	 jmp	 $LN46@Find
$LN45@Find:

; 5139 : 		if (FIND.TotStatics == 0) return false;

  00c3c	83 3d 04 08 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+2052, 0
  00c43	75 07		 jne	 SHORT $LN38@Find
  00c45	32 c0		 xor	 al, al
  00c47	e9 99 03 00 00	 jmp	 $LN131@Find
$LN38@Find:

; 5140 : 		break;

  00c4c	e9 92 03 00 00	 jmp	 $LN129@Find
$LN37@Find:

; 5141 : 	case FIND_AI:
; 5142 : 		FIND.TotAI=0;

  00c51	c7 05 9c 0d 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+3484, 0

; 5143 : 
; 5144 : 		pAI= &Trng.pGlobTomb4->pAdr->pVetAIData[0];

  00c5b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00c60	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00c66	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00c6c	89 95 68 ff ff
	ff		 mov	 DWORD PTR _pAI$[ebp], edx

; 5145 : 
; 5146 : 		for (i=0;i<*Trng.pGlobTomb4->pAdr->pTotAIData;i++) {

  00c72	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00c79	eb 09		 jmp	 SHORT $LN36@Find
$LN35@Find:
  00c7b	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00c7e	83 c0 01	 add	 eax, 1
  00c81	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN36@Find:
  00c84	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00c89	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00c8f	8b 91 84 00 00
	00		 mov	 edx, DWORD PTR [ecx+132]
  00c95	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00c98	3b 02		 cmp	 eax, DWORD PTR [edx]
  00c9a	0f 8d 9b 00 00
	00		 jge	 $LN34@Find

; 5147 : 			TestOk=true;

  00ca0	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 5148 : 
; 5149 : 			if (RoomIndex != -1 && RoomIndex != pAI->RoomIndex) TestOk=false;

  00ca4	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00ca8	83 f8 ff	 cmp	 eax, -1
  00cab	74 16		 je	 SHORT $LN33@Find
  00cad	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00cb1	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _pAI$[ebp]
  00cb7	0f b7 51 02	 movzx	 edx, WORD PTR [ecx+2]
  00cbb	3b c2		 cmp	 eax, edx
  00cbd	74 04		 je	 SHORT $LN33@Find
  00cbf	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN33@Find:

; 5150 : 
; 5151 : 			if (Ocb != -1 && Ocb != pAI->Ocb) TestOk = false;

  00cc3	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00cc7	83 f8 ff	 cmp	 eax, -1
  00cca	74 16		 je	 SHORT $LN32@Find
  00ccc	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00cd0	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _pAI$[ebp]
  00cd6	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00cda	3b c2		 cmp	 eax, edx
  00cdc	74 04		 je	 SHORT $LN32@Find
  00cde	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN32@Find:

; 5152 : 
; 5153 : 			if (SlotType != -1 && SlotType != pAI->SlotAI) TestOk=false;

  00ce2	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00ce6	83 f8 ff	 cmp	 eax, -1
  00ce9	74 15		 je	 SHORT $LN31@Find
  00ceb	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00cef	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _pAI$[ebp]
  00cf5	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00cf8	3b c2		 cmp	 eax, edx
  00cfa	74 04		 je	 SHORT $LN31@Find
  00cfc	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN31@Find:

; 5154 : 
; 5155 : 			if (TestOk == true) {

  00d00	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  00d04	83 f8 01	 cmp	 eax, 1
  00d07	75 1e		 jne	 SHORT $LN30@Find

; 5156 : 				FIND.VetAI[FIND.TotAI] = i;

  00d09	a1 9c 0d 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+3484
  00d0e	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00d12	66 89 0c 45 a0
	0d 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+3488], cx

; 5157 : 				FIND.TotAI++;

  00d1a	a1 9c 0d 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+3484
  00d1f	83 c0 01	 add	 eax, 1
  00d22	a3 9c 0d 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+3484, eax
$LN30@Find:

; 5158 : 			}
; 5159 : 			pAI++;

  00d27	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _pAI$[ebp]
  00d2d	83 c0 18	 add	 eax, 24			; 00000018H
  00d30	89 85 68 ff ff
	ff		 mov	 DWORD PTR _pAI$[ebp], eax

; 5160 : 
; 5161 : 		}

  00d36	e9 40 ff ff ff	 jmp	 $LN35@Find
$LN34@Find:

; 5162 : 		
; 5163 : 		if (FIND.TotAI == 0) return false;

  00d3b	83 3d 9c 0d 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+3484, 0
  00d42	75 07		 jne	 SHORT $LN29@Find
  00d44	32 c0		 xor	 al, al
  00d46	e9 9a 02 00 00	 jmp	 $LN131@Find
$LN29@Find:

; 5164 : 		break;

  00d4b	e9 93 02 00 00	 jmp	 $LN129@Find
$LN28@Find:

; 5165 : 	case FIND_LIGHT:
; 5166 : 		FIND.TotLights=0;

  00d50	c7 05 98 09 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2456, 0

; 5167 : 		// if it has been supplied the RoomIndex, looking for lights only in that room
; 5168 : 		if (RoomIndex != -1) {

  00d5a	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00d5e	83 f8 ff	 cmp	 eax, -1
  00d61	74 13		 je	 SHORT $LN27@Find

; 5169 : 			FirstRoomIndex = RoomIndex;

  00d63	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00d67	89 45 a4	 mov	 DWORD PTR _FirstRoomIndex$[ebp], eax

; 5170 : 			LastRoomIndex = RoomIndex +1;

  00d6a	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00d6e	83 c0 01	 add	 eax, 1
  00d71	89 45 8c	 mov	 DWORD PTR _LastRoomIndex$[ebp], eax

; 5171 : 		}else {

  00d74	eb 1e		 jmp	 SHORT $LN26@Find
$LN27@Find:

; 5172 : 			// otherwise, looking in all rooms
; 5173 : 			FirstRoomIndex = 0;

  00d76	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _FirstRoomIndex$[ebp], 0

; 5174 : 			LastRoomIndex = *Trng.pGlobTomb4->pAdr->pTotRooms;

  00d7d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00d82	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00d88	8b 91 d0 00 00
	00		 mov	 edx, DWORD PTR [ecx+208]
  00d8e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00d91	89 45 8c	 mov	 DWORD PTR _LastRoomIndex$[ebp], eax
$LN26@Find:

; 5175 : 		}
; 5176 : 
; 5177 : 		for (i=FirstRoomIndex;i<LastRoomIndex;i++) {

  00d94	8b 45 a4	 mov	 eax, DWORD PTR _FirstRoomIndex$[ebp]
  00d97	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
  00d9a	eb 09		 jmp	 SHORT $LN25@Find
$LN24@Find:
  00d9c	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00d9f	83 c0 01	 add	 eax, 1
  00da2	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN25@Find:
  00da5	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00da8	3b 45 8c	 cmp	 eax, DWORD PTR _LastRoomIndex$[ebp]
  00dab	0f 8d 94 00 00
	00		 jge	 $LN23@Find

; 5178 : 			pRoom= &Trng.pGlobTomb4->pAdr->pVetRooms[i];

  00db1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00db6	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00dbc	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00dbf	69 d2 94 00 00
	00		 imul	 edx, 148		; 00000094H
  00dc5	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00dc8	89 55 b0	 mov	 DWORD PTR _pRoom$[ebp], edx

; 5179 : 
; 5180 : 
; 5181 : 			for (j=0;j<pRoom->TotLights;j++) {

  00dcb	c7 45 80 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
  00dd2	eb 09		 jmp	 SHORT $LN22@Find
$LN21@Find:
  00dd4	8b 45 80	 mov	 eax, DWORD PTR _j$[ebp]
  00dd7	83 c0 01	 add	 eax, 1
  00dda	89 45 80	 mov	 DWORD PTR _j$[ebp], eax
$LN22@Find:
  00ddd	8b 45 b0	 mov	 eax, DWORD PTR _pRoom$[ebp]
  00de0	0f b7 48 30	 movzx	 ecx, WORD PTR [eax+48]
  00de4	39 4d 80	 cmp	 DWORD PTR _j$[ebp], ecx
  00de7	7d 57		 jge	 SHORT $LN20@Find

; 5182 : 				if (SlotType==-1 || pRoom->pLights[j].LightType == SlotType) {

  00de9	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00ded	83 f8 ff	 cmp	 eax, -1
  00df0	74 19		 je	 SHORT $LN18@Find
  00df2	8b 45 80	 mov	 eax, DWORD PTR _j$[ebp]
  00df5	6b c0 2e	 imul	 eax, 46			; 0000002eH
  00df8	8b 4d b0	 mov	 ecx, DWORD PTR _pRoom$[ebp]
  00dfb	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00dfe	0f b6 44 02 0f	 movzx	 eax, BYTE PTR [edx+eax+15]
  00e03	0f bf 4d 0c	 movsx	 ecx, WORD PTR _SlotType$[ebp]
  00e07	3b c1		 cmp	 eax, ecx
  00e09	75 33		 jne	 SHORT $LN19@Find
$LN18@Find:

; 5183 : 					z= FIND.TotLights;

  00e0b	a1 98 09 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2456
  00e10	89 45 bc	 mov	 DWORD PTR _z$[ebp], eax

; 5184 : 
; 5185 : 					FIND.VetLights[z].RoomIndex = i;

  00e13	8b 45 bc	 mov	 eax, DWORD PTR _z$[ebp]
  00e16	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00e1a	66 89 0c 85 9c
	09 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2460], cx

; 5186 : 					FIND.VetLights[z].ObjIndex = j;

  00e22	8b 45 bc	 mov	 eax, DWORD PTR _z$[ebp]
  00e25	66 8b 4d 80	 mov	 cx, WORD PTR _j$[ebp]
  00e29	66 89 0c 85 9e
	09 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*4+2462], cx

; 5187 : 					FIND.TotLights++;

  00e31	a1 98 09 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+2456
  00e36	83 c0 01	 add	 eax, 1
  00e39	a3 98 09 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+2456, eax
$LN19@Find:

; 5188 : 				}
; 5189 : 			}

  00e3e	eb 94		 jmp	 SHORT $LN21@Find
$LN20@Find:

; 5190 : 		}

  00e40	e9 57 ff ff ff	 jmp	 $LN24@Find
$LN23@Find:

; 5191 : 		if (FIND.TotLights==0) return false;

  00e45	83 3d 98 09 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+2456, 0
  00e4c	75 07		 jne	 SHORT $LN17@Find
  00e4e	32 c0		 xor	 al, al
  00e50	e9 90 01 00 00	 jmp	 $LN131@Find
$LN17@Find:

; 5192 : 
; 5193 : 		break;

  00e55	e9 89 01 00 00	 jmp	 $LN129@Find
$LN16@Find:

; 5194 : 		
; 5195 : 	case FIND_CAMERA_FIXED:
; 5196 : 		FIND.TotCameraFix=0;

  00e5a	c7 05 a0 0f 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4000, 0

; 5197 : 		
; 5198 : 		for (i=0;i< *Trng.pGlobTomb4->pAdr->Camera.pTotCameras;i++) {

  00e64	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00e6b	eb 09		 jmp	 SHORT $LN15@Find
$LN14@Find:
  00e6d	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00e70	83 c0 01	 add	 eax, 1
  00e73	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN15@Find:
  00e76	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00e7b	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00e81	8b 91 00 01 00
	00		 mov	 edx, DWORD PTR [ecx+256]
  00e87	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00e8a	3b 02		 cmp	 eax, DWORD PTR [edx]
  00e8c	7d 44		 jge	 SHORT $LN13@Find

; 5199 : 			if (Trng.pGlobTomb4->pAdr->Camera.pVetCamera[i].Room == RoomIndex) {

  00e8e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00e93	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00e99	8b 55 d4	 mov	 edx, DWORD PTR _i$[ebp]
  00e9c	c1 e2 04	 shl	 edx, 4
  00e9f	8b 81 d4 00 00
	00		 mov	 eax, DWORD PTR [ecx+212]
  00ea5	0f b7 4c 10 0c	 movzx	 ecx, WORD PTR [eax+edx+12]
  00eaa	0f bf 55 10	 movsx	 edx, WORD PTR _RoomIndex$[ebp]
  00eae	3b ca		 cmp	 ecx, edx
  00eb0	75 1e		 jne	 SHORT $LN12@Find

; 5200 : 				FIND.VetCameraFix[FIND.TotCameraFix]= i;

  00eb2	a1 a0 0f 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+4000
  00eb7	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00ebb	66 89 0c 45 a4
	0f 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+4004], cx

; 5201 : 				FIND.TotCameraFix++;

  00ec3	a1 a0 0f 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+4000
  00ec8	83 c0 01	 add	 eax, 1
  00ecb	a3 a0 0f 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4000, eax
$LN12@Find:

; 5202 : 			}
; 5203 : 		}

  00ed0	eb 9b		 jmp	 SHORT $LN14@Find
$LN13@Find:

; 5204 : 		if (FIND.TotCameraFix==0) return false;

  00ed2	83 3d a0 0f 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+4000, 0
  00ed9	75 07		 jne	 SHORT $LN11@Find
  00edb	32 c0		 xor	 al, al
  00edd	e9 03 01 00 00	 jmp	 $LN131@Find
$LN11@Find:

; 5205 : 		break;

  00ee2	e9 fc 00 00 00	 jmp	 $LN129@Find
$LN10@Find:

; 5206 : 		
; 5207 : 	case FIND_CAMERA_FLY:
; 5208 : 		FIND.TotCameraFly=0;

  00ee7	c7 05 6c 10 00
	00 00 00 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4204, 0

; 5209 : 
; 5210 : 		pFly= &Trng.pGlobTomb4->pAdr->pVetFlyBy[0];

  00ef1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00ef6	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00efc	8b 91 10 01 00
	00		 mov	 edx, DWORD PTR [ecx+272]
  00f02	89 55 98	 mov	 DWORD PTR _pFly$[ebp], edx

; 5211 : 		
; 5212 : 		for (i=0;i< *Trng.pGlobTomb4->pAdr->pTotFlyBy;i++) {

  00f05	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00f0c	eb 09		 jmp	 SHORT $LN9@Find
$LN8@Find:
  00f0e	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00f11	83 c0 01	 add	 eax, 1
  00f14	89 45 d4	 mov	 DWORD PTR _i$[ebp], eax
$LN9@Find:
  00f17	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00f1c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00f22	8b 91 0c 01 00
	00		 mov	 edx, DWORD PTR [ecx+268]
  00f28	8b 45 d4	 mov	 eax, DWORD PTR _i$[ebp]
  00f2b	3b 02		 cmp	 eax, DWORD PTR [edx]
  00f2d	0f 8d a3 00 00
	00		 jge	 $LN7@Find

; 5213 : 
; 5214 : 			TestOk=true;

  00f33	c6 45 e3 01	 mov	 BYTE PTR _TestOk$[ebp], 1

; 5215 : 
; 5216 : 			if (RoomIndex != -1 && pFly->RoomIndex != RoomIndex) TestOk=false;

  00f37	0f bf 45 10	 movsx	 eax, WORD PTR _RoomIndex$[ebp]
  00f3b	83 f8 ff	 cmp	 eax, -1
  00f3e	74 13		 je	 SHORT $LN6@Find
  00f40	8b 45 98	 mov	 eax, DWORD PTR _pFly$[ebp]
  00f43	0f b7 48 24	 movzx	 ecx, WORD PTR [eax+36]
  00f47	0f bf 55 10	 movsx	 edx, WORD PTR _RoomIndex$[ebp]
  00f4b	3b ca		 cmp	 ecx, edx
  00f4d	74 04		 je	 SHORT $LN6@Find
  00f4f	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN6@Find:

; 5217 : 			if (Ocb != -1 && pFly->CameraButtons != Ocb) TestOk=false;

  00f53	0f bf 45 14	 movsx	 eax, WORD PTR _Ocb$[ebp]
  00f57	83 f8 ff	 cmp	 eax, -1
  00f5a	74 13		 je	 SHORT $LN5@Find
  00f5c	8b 45 98	 mov	 eax, DWORD PTR _pFly$[ebp]
  00f5f	0f b7 48 22	 movzx	 ecx, WORD PTR [eax+34]
  00f63	0f bf 55 14	 movsx	 edx, WORD PTR _Ocb$[ebp]
  00f67	3b ca		 cmp	 ecx, edx
  00f69	74 04		 je	 SHORT $LN5@Find
  00f6b	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN5@Find:

; 5218 : 			if (SlotType != -1 && pFly->Seq != SlotType) TestOk=false;

  00f6f	0f bf 45 0c	 movsx	 eax, WORD PTR _SlotType$[ebp]
  00f73	83 f8 ff	 cmp	 eax, -1
  00f76	74 13		 je	 SHORT $LN4@Find
  00f78	8b 45 98	 mov	 eax, DWORD PTR _pFly$[ebp]
  00f7b	0f b6 48 18	 movzx	 ecx, BYTE PTR [eax+24]
  00f7f	0f bf 55 0c	 movsx	 edx, WORD PTR _SlotType$[ebp]
  00f83	3b ca		 cmp	 ecx, edx
  00f85	74 04		 je	 SHORT $LN4@Find
  00f87	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN4@Find:

; 5219 : 			if (Extra != -1 && pFly->Num != Extra) TestOk=false;

  00f8b	83 7d 18 ff	 cmp	 DWORD PTR _Extra$[ebp], -1
  00f8f	74 10		 je	 SHORT $LN3@Find
  00f91	8b 45 98	 mov	 eax, DWORD PTR _pFly$[ebp]
  00f94	0f b6 48 19	 movzx	 ecx, BYTE PTR [eax+25]
  00f98	3b 4d 18	 cmp	 ecx, DWORD PTR _Extra$[ebp]
  00f9b	74 04		 je	 SHORT $LN3@Find
  00f9d	c6 45 e3 00	 mov	 BYTE PTR _TestOk$[ebp], 0
$LN3@Find:

; 5220 : 
; 5221 : 			if (TestOk == true) {

  00fa1	0f b6 45 e3	 movzx	 eax, BYTE PTR _TestOk$[ebp]
  00fa5	83 f8 01	 cmp	 eax, 1
  00fa8	75 1e		 jne	 SHORT $LN2@Find

; 5222 : 				FIND.VetCameraFly[FIND.TotCameraFly] = i;

  00faa	a1 6c 10 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+4204
  00faf	66 8b 4d d4	 mov	 cx, WORD PTR _i$[ebp]
  00fb3	66 89 0c 45 70
	10 00 00	 mov	 WORD PTR ?FIND@@3UStrFind@@A[eax*2+4208], cx

; 5223 : 				FIND.TotCameraFly++;

  00fbb	a1 6c 10 00 00	 mov	 eax, DWORD PTR ?FIND@@3UStrFind@@A+4204
  00fc0	83 c0 01	 add	 eax, 1
  00fc3	a3 6c 10 00 00	 mov	 DWORD PTR ?FIND@@3UStrFind@@A+4204, eax
$LN2@Find:

; 5224 : 			}
; 5225 : 			pFly++;

  00fc8	8b 45 98	 mov	 eax, DWORD PTR _pFly$[ebp]
  00fcb	83 c0 28	 add	 eax, 40			; 00000028H
  00fce	89 45 98	 mov	 DWORD PTR _pFly$[ebp], eax

; 5226 : 		}

  00fd1	e9 38 ff ff ff	 jmp	 $LN8@Find
$LN7@Find:

; 5227 : 		if (FIND.TotCameraFly == 0) return false;

  00fd6	83 3d 6c 10 00
	00 00		 cmp	 DWORD PTR ?FIND@@3UStrFind@@A+4204, 0
  00fdd	75 04		 jne	 SHORT $LN129@Find
  00fdf	32 c0		 xor	 al, al
  00fe1	eb 02		 jmp	 SHORT $LN131@Find
$LN129@Find:

; 5228 : 		break;
; 5229 : 		
; 5230 : 
; 5231 : 	}
; 5232 : 
; 5233 : 	return true;

  00fe3	b0 01		 mov	 al, 1
$LN131@Find:

; 5234 : 
; 5235 : }

  00fe5	52		 push	 edx
  00fe6	8b cd		 mov	 ecx, ebp
  00fe8	50		 push	 eax
  00fe9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN135@Find
  00fef	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00ff4	58		 pop	 eax
  00ff5	5a		 pop	 edx
  00ff6	5f		 pop	 edi
  00ff7	5e		 pop	 esi
  00ff8	5b		 pop	 ebx
  00ff9	81 c4 a8 01 00
	00		 add	 esp, 424		; 000001a8H
  00fff	3b ec		 cmp	 ebp, esp
  01001	e8 00 00 00 00	 call	 __RTC_CheckEsp
  01006	8b e5		 mov	 esp, ebp
  01008	5d		 pop	 ebp
  01009	c3		 ret	 0
  0100a	8b ff		 npad	 2
$LN135@Find:
  0100c	01 00 00 00	 DD	 1
  01010	00 00 00 00	 DD	 $LN134@Find
$LN134@Find:
  01014	50 ff ff ff	 DD	 -176			; ffffff50H
  01018	02 00 00 00	 DD	 2
  0101c	00 00 00 00	 DD	 $LN133@Find
$LN133@Find:
  01020	4e		 DB	 78			; 0000004eH
  01021	65		 DB	 101			; 00000065H
  01022	77		 DB	 119			; 00000077H
  01023	52		 DB	 82			; 00000052H
  01024	6f		 DB	 111			; 0000006fH
  01025	6f		 DB	 111			; 0000006fH
  01026	6d		 DB	 109			; 0000006dH
  01027	00		 DB	 0
$LN136@Find:
  01028	00 00 00 00	 DD	 $LN97@Find
  0102c	00 00 00 00	 DD	 $LN50@Find
  01030	00 00 00 00	 DD	 $LN37@Find
  01034	00 00 00 00	 DD	 $LN28@Find
  01038	00 00 00 00	 DD	 $LN16@Find
  0103c	00 00 00 00	 DD	 $LN10@Find
  01040	00 00 00 00	 DD	 $LN68@Find
  01044	00 00 00 00	 DD	 $LN59@Find
  01048	00 00 00 00	 DD	 $LN75@Find
  0104c	00 00 00 00	 DD	 $LN82@Find
  01050	00 00 00 00	 DD	 $LN108@Find
  01054	00 00 00 00	 DD	 $LN102@Find
  01058	00 00 00 00	 DD	 $LN100@Find
  0105c	00 00 00 00	 DD	 $LN98@Find
  01060	00 00 00 00	 DD	 $LN122@Find
  01064	00 00 00 00	 DD	 $LN115@Find
  01068	00 00 00 00	 DD	 $LN128@Find
?Find@@YA_NHFFFHPAX@Z ENDP				; Find
_TEXT	ENDS
PUBLIC	?DetectedGlobalTriggerEvent@@YA_NHH_N@Z		; DetectedGlobalTriggerEvent
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?DetectedGlobalTriggerEvent@@YA_NHH_N@Z
_TEXT	SEGMENT
_RetValue$ = -8						; size = 4
_GT_Event$ = 8						; size = 4
_Parameter$ = 12					; size = 4
_TestIgnoreParameter$ = 16				; size = 1
?DetectedGlobalTriggerEvent@@YA_NHH_N@Z PROC		; DetectedGlobalTriggerEvent, COMDAT

; 5243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 5244 : 	int RetValue;
; 5245 : 
; 5246 : 	RetValue = Service(SRV_F_DetectedGlobalTriggerEvent, GT_Event, Parameter, TestIgnoreParameter);

  0001e	0f b6 45 10	 movzx	 eax, BYTE PTR _TestIgnoreParameter$[ebp]
  00022	50		 push	 eax
  00023	8b 4d 0c	 mov	 ecx, DWORD PTR _Parameter$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR _GT_Event$[ebp]
  0002a	52		 push	 edx
  0002b	6a 10		 push	 16			; 00000010H
  0002d	e8 00 00 00 00	 call	 ?Service@@YAHKZZ	; Service
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	89 45 f8	 mov	 DWORD PTR _RetValue$[ebp], eax

; 5247 : 	if (RetValue != 0) return true;

  00038	83 7d f8 00	 cmp	 DWORD PTR _RetValue$[ebp], 0
  0003c	74 04		 je	 SHORT $LN1@DetectedGl
  0003e	b0 01		 mov	 al, 1
  00040	eb 02		 jmp	 SHORT $LN2@DetectedGl
$LN1@DetectedGl:

; 5248 : 	
; 5249 : 	return false;

  00042	32 c0		 xor	 al, al
$LN2@DetectedGl:

; 5250 : 
; 5251 : }

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004d	3b ec		 cmp	 ebp, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?DetectedGlobalTriggerEvent@@YA_NHH_N@Z ENDP		; DetectedGlobalTriggerEvent
_TEXT	ENDS
PUBLIC	?GetDirection@@YAGKKKK@Z			; GetDirection
EXTRN	?mGetAngle@@3P6AHKKKK@ZA:DWORD			; mGetAngle
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetDirection@@YAGKKKK@Z
_TEXT	SEGMENT
_Orient$ = -8						; size = 2
_SourceX$ = 8						; size = 4
_SourceZ$ = 12						; size = 4
_TargetX$ = 16						; size = 4
_TargetZ$ = 20						; size = 4
?GetDirection@@YAGKKKK@Z PROC				; GetDirection, COMDAT

; 5255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 5256 : 	WORD Orient;
; 5257 : 
; 5258 : 	Orient = mGetAngle(SourceX, SourceZ, TargetX, TargetZ);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 14	 mov	 eax, DWORD PTR _TargetZ$[ebp]
  00023	50		 push	 eax
  00024	8b 4d 10	 mov	 ecx, DWORD PTR _TargetX$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 0c	 mov	 edx, DWORD PTR _SourceZ$[ebp]
  0002b	52		 push	 edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR _SourceX$[ebp]
  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR ?mGetAngle@@3P6AHKKKK@ZA ; mGetAngle
  00036	83 c4 10	 add	 esp, 16			; 00000010H
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	66 89 45 f8	 mov	 WORD PTR _Orient$[ebp], ax

; 5259 : 	Orient += 0x4000;

  00044	0f b7 45 f8	 movzx	 eax, WORD PTR _Orient$[ebp]
  00048	05 00 40 00 00	 add	 eax, 16384		; 00004000H
  0004d	66 89 45 f8	 mov	 WORD PTR _Orient$[ebp], ax

; 5260 : 
; 5261 : 	return Orient;

  00051	66 8b 45 f8	 mov	 ax, WORD PTR _Orient$[ebp]

; 5262 : 
; 5263 : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
?GetDirection@@YAGKKKK@Z ENDP				; GetDirection
_TEXT	ENDS
PUBLIC	?CheckDirection@@YA_NPAUStrItemTr4@@HHHFF@Z	; CheckDirection
EXTRN	?ObjectOnLOS2@@3P6AHPAUGAME_VECTOR@@0PAUStrPosizione@@PAPAUStrMeshInfo@@@ZA:DWORD ; ObjectOnLOS2
EXTRN	?LOS@@3P6AHPAUGAME_VECTOR@@0@ZA:DWORD		; LOS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CheckDirection@@YA_NPAUStrItemTr4@@HHHFF@Z
_TEXT	SEGMENT
_HOrient$ = -92						; size = 2
_MyTolleranza$ = -80					; size = 2
_Beta$ = -68						; size = 4
_Alfa$ = -56						; size = 4
_pTarget$ = -44						; size = 4
_Index$ = -32						; size = 4
_Indice$ = -20						; size = 4
_Orient$ = -8						; size = 2
_pSourceItem$ = 8					; size = 4
_OffSourceY$ = 12					; size = 4
_TargetIndex$ = 16					; size = 4
_OffTargetY$ = 20					; size = 4
_TolleranceH$ = 24					; size = 2
_TolleranceV$ = 28					; size = 2
?CheckDirection@@YA_NPAUStrItemTr4@@HHHFF@Z PROC	; CheckDirection, COMDAT

; 5274 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 01 00
	00		 sub	 esp, 288		; 00000120H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd e0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-288]
  00012	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 5275 : 	
; 5276 : 
; 5277 : 	short Orient;
; 5278 : 	int Indice;
; 5279 : 	int Index;
; 5280 : 	StrItemTr4 *pTarget;
; 5281 : 	DWORD  Alfa, Beta;
; 5282 : 	short MyTolleranza;
; 5283 : 	short HOrient;
; 5284 : 
; 5285 : 	ClearMemory(&LOF, sizeof(StrLOFData));

  0001e	6a 36		 push	 54			; 00000036H
  00020	68 00 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A ; LOF
  00025	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  0002a	83 c4 08	 add	 esp, 8

; 5286 : 
; 5287 : 	if (TargetIndex & NGLE_INDEX) {

  0002d	8b 45 10	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00030	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00035	74 27		 je	 SHORT $LN14@CheckDirec

; 5288 : 		Index = TargetIndex & MASK_NGLE_INDEX;

  00037	8b 45 10	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0003a	25 ff 3f 00 00	 and	 eax, 16383		; 00003fffH
  0003f	89 45 e0	 mov	 DWORD PTR _Index$[ebp], eax

; 5289 : 		TargetIndex = FromNgleIndexToTomb4Index(Index);

  00042	8b 45 e0	 mov	 eax, DWORD PTR _Index$[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?FromNgleIndexToTomb4Index@@YAHH@Z ; FromNgleIndexToTomb4Index
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 45 10	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 5290 : 		if (TargetIndex==-1) return false;

  00051	83 7d 10 ff	 cmp	 DWORD PTR _TargetIndex$[ebp], -1
  00055	75 07		 jne	 SHORT $LN14@CheckDirec
  00057	32 c0		 xor	 al, al
  00059	e9 16 03 00 00	 jmp	 $LN15@CheckDirec
$LN14@CheckDirec:

; 5291 : 	}
; 5292 : 	pTarget = &Trng.pGlobTomb4->pAdr->pVetItems[TargetIndex];

  0005e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00063	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00069	8b 55 10	 mov	 edx, DWORD PTR _TargetIndex$[ebp]
  0006c	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  00072	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00075	89 55 d4	 mov	 DWORD PTR _pTarget$[ebp], edx

; 5293 : 
; 5294 : 	MyTolleranza= TolleranceV;

  00078	66 8b 45 1c	 mov	 ax, WORD PTR _TolleranceV$[ebp]
  0007c	66 89 45 b0	 mov	 WORD PTR _MyTolleranza$[ebp], ax

; 5295 : 	Orient= GetDirection(pSourceItem->CordX, pSourceItem->CordZ, pTarget->CordX, pTarget->CordZ);

  00080	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00083	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00086	51		 push	 ecx
  00087	8b 55 d4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  0008a	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0008d	50		 push	 eax
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _pSourceItem$[ebp]
  00091	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  00098	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 ?GetDirection@@YAGKKKK@Z ; GetDirection
  000a1	83 c4 10	 add	 esp, 16			; 00000010H
  000a4	66 89 45 f8	 mov	 WORD PTR _Orient$[ebp], ax

; 5296 : 	LOF.OrientingH = Orient;

  000a8	66 8b 45 f8	 mov	 ax, WORD PTR _Orient$[ebp]
  000ac	66 a3 14 00 00
	00		 mov	 WORD PTR ?LOF@@3UStrLOFData@@A+20, ax

; 5297 : 
; 5298 : 	// calcolarlo angolo orizzontale 
; 5299 : 	if (TolleranceH > 0) {

  000b2	0f bf 45 18	 movsx	 eax, WORD PTR _TolleranceH$[ebp]
  000b6	85 c0		 test	 eax, eax
  000b8	7e 2c		 jle	 SHORT $LN12@CheckDirec

; 5300 : 
; 5301 : 
; 5302 : 		HOrient=Orient;

  000ba	66 8b 45 f8	 mov	 ax, WORD PTR _Orient$[ebp]
  000be	66 89 45 a4	 mov	 WORD PTR _HOrient$[ebp], ax

; 5303 : 		// ora calcolare differenza con facing di enemy
; 5304 : 		if (AbsDiffO(Orient, pSourceItem->OrientationH) > TolleranceH) return false;

  000c2	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  000c5	0f b7 48 4e	 movzx	 ecx, WORD PTR [eax+78]
  000c9	51		 push	 ecx
  000ca	0f b7 55 f8	 movzx	 edx, WORD PTR _Orient$[ebp]
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  000d4	83 c4 08	 add	 esp, 8
  000d7	0f bf 4d 18	 movsx	 ecx, WORD PTR _TolleranceH$[ebp]
  000db	3b c1		 cmp	 eax, ecx
  000dd	7e 07		 jle	 SHORT $LN12@CheckDirec
  000df	32 c0		 xor	 al, al
  000e1	e9 8e 02 00 00	 jmp	 $LN15@CheckDirec
$LN12@CheckDirec:

; 5305 : 
; 5306 : 	}
; 5307 : 
; 5308 : 	// stesso calcolo per differenza verticale
; 5309 : 	if (MyTolleranza > 0) {

  000e6	0f bf 45 b0	 movsx	 eax, WORD PTR _MyTolleranza$[ebp]
  000ea	85 c0		 test	 eax, eax
  000ec	0f 8e 04 01 00
	00		 jle	 $LN10@CheckDirec

; 5310 : 		// vedere se usare x o z
; 5311 : 		// scegliere l'asse dove c'e' la distanza maggiore
; 5312 : 		if (AbsDiff(pTarget->CordX, pSourceItem->CordX) > AbsDiff(pTarget->CordZ, pSourceItem->CordZ)) {

  000f2	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  000f5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000f8	51		 push	 ecx
  000f9	8b 55 d4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  000fc	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 ?AbsDiff@@YAHKK@Z	; AbsDiff
  00105	83 c4 08	 add	 esp, 8
  00108	8b f0		 mov	 esi, eax
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _pSourceItem$[ebp]
  0010d	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00110	52		 push	 edx
  00111	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00114	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 ?AbsDiff@@YAHKK@Z	; AbsDiff
  0011d	83 c4 08	 add	 esp, 8
  00120	3b f0		 cmp	 esi, eax
  00122	7e 14		 jle	 SHORT $LN9@CheckDirec

; 5313 : 			// distanza x e' maggiore, usare  X
; 5314 : 			Alfa = pSourceItem->CordX;

  00124	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  00127	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0012a	89 4d c8	 mov	 DWORD PTR _Alfa$[ebp], ecx

; 5315 : 			Beta = pTarget->CordX;

  0012d	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00130	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00133	89 4d bc	 mov	 DWORD PTR _Beta$[ebp], ecx

; 5316 : 		}else {

  00136	eb 12		 jmp	 SHORT $LN8@CheckDirec
$LN9@CheckDirec:

; 5317 : 			// e' maggiore z usare Z
; 5318 : 			Alfa = pSourceItem->CordZ;

  00138	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  0013b	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0013e	89 4d c8	 mov	 DWORD PTR _Alfa$[ebp], ecx

; 5319 : 			Beta = pTarget->CordZ;

  00141	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00144	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00147	89 4d bc	 mov	 DWORD PTR _Beta$[ebp], ecx
$LN8@CheckDirec:

; 5320 : 		}
; 5321 : 		if (GetMaxDistance(&pSourceItem->CordX, &pTarget->CordX,true) < 2048) {

  0014a	6a 01		 push	 1
  0014c	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0014f	83 c0 40	 add	 eax, 64			; 00000040H
  00152	50		 push	 eax
  00153	8b 4d 08	 mov	 ecx, DWORD PTR _pSourceItem$[ebp]
  00156	83 c1 40	 add	 ecx, 64			; 00000040H
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 ?GetMaxDistance@@YAHPAK0_N@Z ; GetMaxDistance
  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00162	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00167	7d 0a		 jge	 SHORT $LN7@CheckDirec

; 5322 : 			// aumentare la tolleranza se sono molto vicini
; 5323 : 			MyTolleranza = MyTolleranza << 1;

  00169	0f bf 45 b0	 movsx	 eax, WORD PTR _MyTolleranza$[ebp]
  0016d	d1 e0		 shl	 eax, 1
  0016f	66 89 45 b0	 mov	 WORD PTR _MyTolleranza$[ebp], ax
$LN7@CheckDirec:

; 5324 : 		}
; 5325 : 		Orient = mGetAngle(Alfa, pSourceItem->CordY+OffSourceY, Beta, pTarget->CordY+OffTargetY);

  00173	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00176	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00179	03 4d 14	 add	 ecx, DWORD PTR _OffTargetY$[ebp]
  0017c	8b f4		 mov	 esi, esp
  0017e	51		 push	 ecx
  0017f	8b 55 bc	 mov	 edx, DWORD PTR _Beta$[ebp]
  00182	52		 push	 edx
  00183	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  00186	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00189	03 4d 0c	 add	 ecx, DWORD PTR _OffSourceY$[ebp]
  0018c	51		 push	 ecx
  0018d	8b 55 c8	 mov	 edx, DWORD PTR _Alfa$[ebp]
  00190	52		 push	 edx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR ?mGetAngle@@3P6AHKKKK@ZA ; mGetAngle
  00197	83 c4 10	 add	 esp, 16			; 00000010H
  0019a	3b f4		 cmp	 esi, esp
  0019c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a1	66 89 45 f8	 mov	 WORD PTR _Orient$[ebp], ax

; 5326 : 		if (Orient > 4096 || Orient < -4096) Orient += (short) 32767;	

  001a5	0f bf 45 f8	 movsx	 eax, WORD PTR _Orient$[ebp]
  001a9	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  001ae	7f 0b		 jg	 SHORT $LN5@CheckDirec
  001b0	0f bf 45 f8	 movsx	 eax, WORD PTR _Orient$[ebp]
  001b4	3d 00 f0 ff ff	 cmp	 eax, -4096		; fffff000H
  001b9	7d 0d		 jge	 SHORT $LN6@CheckDirec
$LN5@CheckDirec:
  001bb	0f bf 45 f8	 movsx	 eax, WORD PTR _Orient$[ebp]
  001bf	05 ff 7f 00 00	 add	 eax, 32767		; 00007fffH
  001c4	66 89 45 f8	 mov	 WORD PTR _Orient$[ebp], ax
$LN6@CheckDirec:

; 5327 : 		LOF.OrientingV = Orient;

  001c8	66 8b 45 f8	 mov	 ax, WORD PTR _Orient$[ebp]
  001cc	66 a3 16 00 00
	00		 mov	 WORD PTR ?LOF@@3UStrLOFData@@A+22, ax

; 5328 : 		if (AbsDiffO(Orient, pSourceItem->OrientationV) > MyTolleranza) return false;

  001d2	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  001d5	0f b7 48 4c	 movzx	 ecx, WORD PTR [eax+76]
  001d9	51		 push	 ecx
  001da	0f b7 55 f8	 movzx	 edx, WORD PTR _Orient$[ebp]
  001de	52		 push	 edx
  001df	e8 00 00 00 00	 call	 ?AbsDiffO@@YAHFF@Z	; AbsDiffO
  001e4	83 c4 08	 add	 esp, 8
  001e7	0f bf 4d b0	 movsx	 ecx, WORD PTR _MyTolleranza$[ebp]
  001eb	3b c1		 cmp	 eax, ecx
  001ed	7e 07		 jle	 SHORT $LN10@CheckDirec
  001ef	32 c0		 xor	 al, al
  001f1	e9 7e 01 00 00	 jmp	 $LN15@CheckDirec
$LN10@CheckDirec:

; 5329 : 
; 5330 : 	}
; 5331 : 	// la distanza tra lara e il nemico non deve superare i 10 blocchi
; 5332 : 	if (GetDistanceXZ(pSourceItem->CordX, pSourceItem->CordZ, 
; 5333 : 							pTarget->CordX, pTarget->CordZ) > 10240) return false;

  001f6	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  001f9	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  001fc	51		 push	 ecx
  001fd	8b 55 d4	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00200	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00203	50		 push	 eax
  00204	8b 4d 08	 mov	 ecx, DWORD PTR _pSourceItem$[ebp]
  00207	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0020a	52		 push	 edx
  0020b	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  0020e	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00211	51		 push	 ecx
  00212	e8 00 00 00 00	 call	 ?GetDistanceXZ@@YAHKKKK@Z ; GetDistanceXZ
  00217	83 c4 10	 add	 esp, 16			; 00000010H
  0021a	3d 00 28 00 00	 cmp	 eax, 10240		; 00002800H
  0021f	7e 07		 jle	 SHORT $LN3@CheckDirec
  00221	32 c0		 xor	 al, al
  00223	e9 4c 01 00 00	 jmp	 $LN15@CheckDirec
$LN3@CheckDirec:

; 5334 : 
; 5335 : 	// l'orientamento generico va bene
; 5336 : 	// ora vedere se non ci sono ostacoli 
; 5337 : 
; 5338 : 
; 5339 : 	LOF.Src.CordX = pSourceItem->CordX;

  00228	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  0022b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0022e	89 0d 1a 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+26, ecx

; 5340 : 	LOF.Src.CordZ = pSourceItem->CordZ;

  00234	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  00237	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0023a	89 0d 22 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+34, ecx

; 5341 : 	LOF.Src.CordY = pSourceItem->CordY + OffSourceY;

  00240	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  00243	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00246	03 4d 0c	 add	 ecx, DWORD PTR _OffSourceY$[ebp]
  00249	89 0d 1e 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+30, ecx

; 5342 : 	LOF.Src.Room = pSourceItem->Room;

  0024f	8b 45 08	 mov	 eax, DWORD PTR _pSourceItem$[ebp]
  00252	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  00256	66 89 0d 26 00
	00 00		 mov	 WORD PTR ?LOF@@3UStrLOFData@@A+38, cx

; 5343 : 
; 5344 : 	LOF.Dest.CordX = pTarget->CordX;

  0025d	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00260	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00263	89 0d 28 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+40, ecx

; 5345 : 	LOF.Dest.CordZ = pTarget->CordZ;

  00269	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0026c	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0026f	89 0d 30 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+48, ecx

; 5346 : 	LOF.Dest.CordY = pTarget->CordY + OffTargetY;

  00275	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00278	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0027b	03 4d 14	 add	 ecx, DWORD PTR _OffTargetY$[ebp]
  0027e	89 0d 2c 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+44, ecx

; 5347 : 	LOF.Dest.Room = pTarget->Room;

  00284	8b 45 d4	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00287	66 8b 48 18	 mov	 cx, WORD PTR [eax+24]
  0028b	66 89 0d 34 00
	00 00		 mov	 WORD PTR ?LOF@@3UStrLOFData@@A+52, cx

; 5348 : 
; 5349 : 
; 5350 : 	if (LOS(&LOF.Src,&LOF.Dest)==false) {

  00292	8b f4		 mov	 esi, esp
  00294	68 28 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A+40
  00299	68 1a 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A+26
  0029e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LOS@@3P6AHPAUGAME_VECTOR@@0@ZA ; LOS
  002a4	83 c4 08	 add	 esp, 8
  002a7	3b f4		 cmp	 esi, esp
  002a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ae	85 c0		 test	 eax, eax
  002b0	75 41		 jne	 SHORT $LN2@CheckDirec

; 5351 : 		LOF.PointFinal.OrgX = Trng.pGlobTomb4->DummyX;

  002b2	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002b7	8b 88 d1 e7 00
	00		 mov	 ecx, DWORD PTR [eax+59345]
  002bd	89 0d 08 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+8, ecx

; 5352 : 		LOF.PointFinal.OrgY = Trng.pGlobTomb4->DummyY;

  002c3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002c8	8b 88 d5 e7 00
	00		 mov	 ecx, DWORD PTR [eax+59349]
  002ce	89 0d 0c 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+12, ecx

; 5353 : 		LOF.PointFinal.OrgZ = Trng.pGlobTomb4->DummyZ;

  002d4	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002d9	8b 88 d9 e7 00
	00		 mov	 ecx, DWORD PTR [eax+59353]
  002df	89 0d 10 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+16, ecx

; 5354 : 		LOF.TestWall=true;

  002e5	c6 05 19 00 00
	00 01		 mov	 BYTE PTR ?LOF@@3UStrLOFData@@A+25, 1

; 5355 : 		return false;

  002ec	32 c0		 xor	 al, al
  002ee	e9 81 00 00 00	 jmp	 $LN15@CheckDirec
$LN2@CheckDirec:

; 5356 : 	}
; 5357 : 
; 5358 : 	Trng.pGlobTomb4->pItemAdrToIgnoreLOF = pSourceItem;

  002f3	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  002f8	8b 4d 08	 mov	 ecx, DWORD PTR _pSourceItem$[ebp]
  002fb	89 88 25 51 21
	00		 mov	 DWORD PTR [eax+2183461], ecx

; 5359 : 
; 5360 : 	Indice = ObjectOnLOS2(&LOF.Src, &LOF.Dest, &LOF.PointFinal , &LOF.pStaticFound);

  00301	8b f4		 mov	 esi, esp
  00303	68 00 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A ; LOF
  00308	68 08 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A+8
  0030d	68 28 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A+40
  00312	68 1a 00 00 00	 push	 OFFSET ?LOF@@3UStrLOFData@@A+26
  00317	ff 15 00 00 00
	00		 call	 DWORD PTR ?ObjectOnLOS2@@3P6AHPAUGAME_VECTOR@@0PAUStrPosizione@@PAPAUStrMeshInfo@@@ZA ; ObjectOnLOS2
  0031d	83 c4 10	 add	 esp, 16			; 00000010H
  00320	3b f4		 cmp	 esi, esp
  00322	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00327	89 45 ec	 mov	 DWORD PTR _Indice$[ebp], eax

; 5361 : 	Trng.pGlobTomb4->pItemAdrToIgnoreLOF = NULL;

  0032a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0032f	c7 80 25 51 21
	00 00 00 00 00	 mov	 DWORD PTR [eax+2183461], 0

; 5362 : 
; 5363 : 	if (Indice != 999 && Indice != TargetIndex) {

  00339	81 7d ec e7 03
	00 00		 cmp	 DWORD PTR _Indice$[ebp], 999 ; 000003e7H
  00340	74 29		 je	 SHORT $LN1@CheckDirec
  00342	8b 45 ec	 mov	 eax, DWORD PTR _Indice$[ebp]
  00345	3b 45 10	 cmp	 eax, DWORD PTR _TargetIndex$[ebp]
  00348	74 21		 je	 SHORT $LN1@CheckDirec

; 5364 : 		LOF.pItemFound = &Trng.pGlobTomb4->pAdr->pVetItems[Indice];

  0034a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0034f	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00355	8b 55 ec	 mov	 edx, DWORD PTR _Indice$[ebp]
  00358	69 d2 f6 15 00
	00		 imul	 edx, 5622		; 000015f6H
  0035e	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00361	89 15 04 00 00
	00		 mov	 DWORD PTR ?LOF@@3UStrLOFData@@A+4, edx

; 5365 : 		return false;

  00367	32 c0		 xor	 al, al
  00369	eb 09		 jmp	 SHORT $LN15@CheckDirec
$LN1@CheckDirec:

; 5366 : 	}
; 5367 : 
; 5368 : 	// non c'e'nessun oggetto diverso da quello scandito in mezzo
; 5369 : 	// quindi ok
; 5370 : 	LOF.TestFreeLine=true;

  0036b	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?LOF@@3UStrLOFData@@A+24, 1

; 5371 : 	return true;

  00372	b0 01		 mov	 al, 1
$LN15@CheckDirec:

; 5372 : 
; 5373 : 
; 5374 : 	
; 5375 : 
; 5376 : }

  00374	5f		 pop	 edi
  00375	5e		 pop	 esi
  00376	5b		 pop	 ebx
  00377	81 c4 20 01 00
	00		 add	 esp, 288		; 00000120H
  0037d	3b ec		 cmp	 ebp, esp
  0037f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00384	8b e5		 mov	 esp, ebp
  00386	5d		 pop	 ebp
  00387	c3		 ret	 0
?CheckDirection@@YA_NPAUStrItemTr4@@HHHFF@Z ENDP	; CheckDirection
_TEXT	ENDS
PUBLIC	?GetSlopeDirection@@YAFXZ			; GetSlopeDirection
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetSlopeDirection@@YAFXZ
_TEXT	SEGMENT
?GetSlopeDirection@@YAFXZ PROC				; GetSlopeDirection, COMDAT

; 5383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 5384 : 
; 5385 : 	// verifiy if is is a diagonal slope: in this case we'll return an invalid value to quit
; 5386 : 	if (FLOOR.SlopeX !=0 && FLOOR.SlopeZ != 0) {

  0001e	83 3d 43 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, 0
  00025	74 62		 je	 SHORT $LN8@GetSlopeDi
  00027	83 3d 47 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, 0
  0002e	74 59		 je	 SHORT $LN8@GetSlopeDi

; 5387 : 		// the sector is inclinated on two axis: diagonal direction
; 5388 : 		if (FLOOR.SlopeZ > 0 && FLOOR.SlopeX > 0) {

  00030	83 3d 47 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, 0
  00037	7e 14		 jle	 SHORT $LN7@GetSlopeDi
  00039	83 3d 43 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, 0
  00040	7e 0b		 jle	 SHORT $LN7@GetSlopeDi

; 5389 : 			// south-east direction
; 5390 : 			return enumORIENT.SOUTH_EAST;

  00042	66 a1 10 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+16
  00048	e9 85 00 00 00	 jmp	 $LN9@GetSlopeDi
$LN7@GetSlopeDi:

; 5391 : 		}
; 5392 : 
; 5393 : 		if (FLOOR.SlopeZ > 0 && FLOOR.SlopeX < 0) {

  0004d	83 3d 47 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, 0
  00054	7e 11		 jle	 SHORT $LN6@GetSlopeDi
  00056	83 3d 43 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, 0
  0005d	7d 08		 jge	 SHORT $LN6@GetSlopeDi

; 5394 : 			return enumORIENT.NORTH_EAST;

  0005f	66 a1 14 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+20
  00065	eb 6b		 jmp	 SHORT $LN9@GetSlopeDi
$LN6@GetSlopeDi:

; 5395 : 		}
; 5396 : 		if (FLOOR.SlopeZ < 0 && FLOOR.SlopeX > 0) {

  00067	83 3d 47 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, 0
  0006e	7d 11		 jge	 SHORT $LN5@GetSlopeDi
  00070	83 3d 43 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, 0
  00077	7e 08		 jle	 SHORT $LN5@GetSlopeDi

; 5397 : 			return enumORIENT.SOUTH_WEST;

  00079	66 a1 18 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+24
  0007f	eb 51		 jmp	 SHORT $LN9@GetSlopeDi
$LN5@GetSlopeDi:

; 5398 : 		}
; 5399 : 
; 5400 : 		// it has to be north-west
; 5401 : 		return enumORIENT.NORTH_WEST;

  00081	66 a1 1c 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+28
  00087	eb 49		 jmp	 SHORT $LN9@GetSlopeDi
$LN8@GetSlopeDi:

; 5402 : 
; 5403 : 		
; 5404 : 	}
; 5405 : 
; 5406 : 	if (FLOOR.SlopeX > 0) {

  00089	83 3d 43 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, 0
  00090	7e 08		 jle	 SHORT $LN4@GetSlopeDi

; 5407 : 		// south
; 5408 : 		return enumORIENT.SOUTH;

  00092	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+4
  00098	eb 38		 jmp	 SHORT $LN9@GetSlopeDi
$LN4@GetSlopeDi:

; 5409 : 	}
; 5410 : 
; 5411 : 	if (FLOOR.SlopeX < 0) {

  0009a	83 3d 43 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, 0
  000a1	7d 08		 jge	 SHORT $LN3@GetSlopeDi

; 5412 : 		// north
; 5413 : 		return enumORIENT.NORTH;

  000a3	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A
  000a9	eb 27		 jmp	 SHORT $LN9@GetSlopeDi
$LN3@GetSlopeDi:

; 5414 : 	}
; 5415 : 
; 5416 : 	if (FLOOR.SlopeZ > 0) {

  000ab	83 3d 47 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, 0
  000b2	7e 08		 jle	 SHORT $LN2@GetSlopeDi

; 5417 : 		// east
; 5418 : 		return enumORIENT.EAST;

  000b4	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+8
  000ba	eb 16		 jmp	 SHORT $LN9@GetSlopeDi
$LN2@GetSlopeDi:

; 5419 : 	}
; 5420 : 
; 5421 : 	if (FLOOR.SlopeZ < 0) {

  000bc	83 3d 47 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, 0
  000c3	7d 08		 jge	 SHORT $LN1@GetSlopeDi

; 5422 : 		// west
; 5423 : 		return enumORIENT.WEST;

  000c5	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ?enumORIENT@@3UStrEnumORIENT@@A+12
  000cb	eb 05		 jmp	 SHORT $LN9@GetSlopeDi
$LN1@GetSlopeDi:

; 5424 : 	}
; 5425 : 
; 5426 : 	// there is no slope, so neither a directio for the rise. Return an invalid value
; 5427 : 	return 9999;

  000cd	b8 0f 27 00 00	 mov	 eax, 9999		; 0000270fH
$LN9@GetSlopeDi:

; 5428 : 
; 5429 : }

  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?GetSlopeDirection@@YAFXZ ENDP				; GetSlopeDirection
_TEXT	ENDS
PUBLIC	?CheckFloor@@YA_NKHKH@Z				; CheckFloor
EXTRN	?GetWaterHeight@@3P6AHKHKF@ZA:DWORD		; GetWaterHeight
EXTRN	?GetWaterDepth@@3P6AHKHKF@ZA:DWORD		; GetWaterDepth
EXTRN	?GetCeiling@@3P6AHPAXKHK@ZA:DWORD		; GetCeiling
EXTRN	?GetHeight@@3P6AHPAXKHK@ZA:DWORD		; GetHeight
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CheckFloor@@YA_NKHKH@Z
_TEXT	SEGMENT
_ClickGrade$ = -32					; size = 2
_OrgZ$ = -20						; size = 4
_OrgX$ = -8						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_RoomIndex$ = 20					; size = 4
?CheckFloor@@YA_NKHKH@Z PROC				; CheckFloor, COMDAT

; 5441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 5442 : 	DWORD OrgX;
; 5443 : 	DWORD OrgZ;
; 5444 : 	WORD ClickGrade;
; 5445 : 	
; 5446 : 	ClearMemory(&FLOOR, sizeof(StrFloorAnalyse));

  0001e	6a 4b		 push	 75			; 0000004bH
  00020	68 00 00 00 00	 push	 OFFSET ?FLOOR@@3UStrFloorAnalyse@@A ; FLOOR
  00025	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  0002a	83 c4 08	 add	 esp, 8

; 5447 : 
; 5448 : 	OrgX = x & ~0x3ff;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00030	25 00 fc ff ff	 and	 eax, -1024		; fffffc00H
  00035	89 45 f8	 mov	 DWORD PTR _OrgX$[ebp], eax

; 5449 : 	OrgZ = z & ~0x3ff;

  00038	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  0003b	25 00 fc ff ff	 and	 eax, -1024		; fffffc00H
  00040	89 45 ec	 mov	 DWORD PTR _OrgZ$[ebp], eax

; 5450 : 
; 5451 : 	FLOOR.SectorCoords.WestZ = OrgZ;

  00043	8b 45 ec	 mov	 eax, DWORD PTR _OrgZ$[ebp]
  00046	a3 19 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+25, eax

; 5452 : 	FLOOR.SectorCoords.SouthX = OrgX+1023;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _OrgX$[ebp]
  0004e	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  00053	a3 25 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+37, eax

; 5453 : 	FLOOR.SectorCoords.EastZ = OrgZ + 1023;

  00058	8b 45 ec	 mov	 eax, DWORD PTR _OrgZ$[ebp]
  0005b	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  00060	a3 1d 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+29, eax

; 5454 : 	FLOOR.SectorCoords.NorthX = OrgX;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _OrgX$[ebp]
  00068	a3 21 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+33, eax

; 5455 : 	FLOOR.SectorCoords.MiddleX = OrgX + 511;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _OrgX$[ebp]
  00070	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  00075	a3 29 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+41, eax

; 5456 : 	FLOOR.SectorCoords.MiddleZ = OrgZ + 511;

  0007a	8b 45 ec	 mov	 eax, DWORD PTR _OrgZ$[ebp]
  0007d	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  00082	a3 2d 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+45, eax

; 5457 : 	FLOOR.SectorCoords.Radius = GetDistanceXZ(x, z, OrgX+511, OrgZ+511);

  00087	8b 45 ec	 mov	 eax, DWORD PTR _OrgZ$[ebp]
  0008a	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  0008f	50		 push	 eax
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _OrgX$[ebp]
  00093	81 c1 ff 01 00
	00		 add	 ecx, 511		; 000001ffH
  00099	51		 push	 ecx
  0009a	8b 55 10	 mov	 edx, DWORD PTR _z$[ebp]
  0009d	52		 push	 edx
  0009e	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?GetDistanceXZ@@YAHKKKK@Z ; GetDistanceXZ
  000a7	83 c4 10	 add	 esp, 16			; 00000010H
  000aa	a3 31 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+49, eax

; 5458 : 	FLOOR.RoomIndex = RoomIndex;

  000af	66 8b 45 14	 mov	 ax, WORD PTR _RoomIndex$[ebp]
  000b3	66 a3 17 00 00
	00		 mov	 WORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+23, ax

; 5459 : 
; 5460 : 	FLOOR.pFloor = (WORD *) GetFloor(x,y,z, &FLOOR.RoomIndex);

  000b9	8b f4		 mov	 esi, esp
  000bb	68 17 00 00 00	 push	 OFFSET ?FLOOR@@3UStrFloorAnalyse@@A+23
  000c0	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  000c3	50		 push	 eax
  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  000c7	51		 push	 ecx
  000c8	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  000cb	52		 push	 edx
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetFloor@@3P6APAXKHKPAF@ZA ; GetFloor
  000d2	83 c4 10	 add	 esp, 16			; 00000010H
  000d5	3b f4		 cmp	 esi, esp
  000d7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000dc	a3 35 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53, eax

; 5461 : 
; 5462 : 	if (FLOOR.pFloor == NULL) {

  000e1	83 3d 35 00 00
	00 00		 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53, 0
  000e8	75 0e		 jne	 SHORT $LN4@CheckFloor

; 5463 : 		FLOOR.TestFullWall=true;

  000ea	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?FLOOR@@3UStrFloorAnalyse@@A, 1

; 5464 : 		return false;

  000f1	32 c0		 xor	 al, al
  000f3	e9 b4 01 00 00	 jmp	 $LN5@CheckFloor
$LN4@CheckFloor:

; 5465 : 	}
; 5466 : 
; 5467 : 	FLOOR.FloorHeight = GetHeight(FLOOR.pFloor , x,y,z);

  000f8	8b f4		 mov	 esi, esp
  000fa	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  000fd	50		 push	 eax
  000fe	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00101	51		 push	 ecx
  00102	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00105	52		 push	 edx
  00106	a1 35 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53
  0010b	50		 push	 eax
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetHeight@@3P6AHPAXKHK@ZA ; GetHeight
  00112	83 c4 10	 add	 esp, 16			; 00000010H
  00115	3b f4		 cmp	 esi, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	a3 07 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+7, eax

; 5468 : 	
; 5469 : 	if (FLOOR.FloorHeight == WALL_FLOOR) {

  00121	81 3d 07 00 00
	00 00 81 ff ff	 cmp	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+7, -32512 ; ffff8100H
  0012b	75 0e		 jne	 SHORT $LN3@CheckFloor

; 5470 : 		FLOOR.TestFullWall=true;

  0012d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?FLOOR@@3UStrFloorAnalyse@@A, 1

; 5471 : 		return false;

  00134	32 c0		 xor	 al, al
  00136	e9 71 01 00 00	 jmp	 $LN5@CheckFloor
$LN3@CheckFloor:

; 5472 : 	}
; 5473 : 
; 5474 : 	FLOOR.CeilingHeight = GetCeiling(FLOOR.pFloor, x, y, z);

  0013b	8b f4		 mov	 esi, esp
  0013d	8b 45 10	 mov	 eax, DWORD PTR _z$[ebp]
  00140	50		 push	 eax
  00141	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  00144	51		 push	 ecx
  00145	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00148	52		 push	 edx
  00149	a1 35 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53
  0014e	50		 push	 eax
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetCeiling@@3P6AHPAXKHK@ZA ; GetCeiling
  00155	83 c4 10	 add	 esp, 16			; 00000010H
  00158	3b f4		 cmp	 esi, esp
  0015a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015f	a3 0b 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+11, eax

; 5475 : 
; 5476 : 	FLOOR.WaterDepth = GetWaterDepth(x,y,z, FLOOR.RoomIndex);

  00164	8b f4		 mov	 esi, esp
  00166	0f b7 05 17 00
	00 00		 movzx	 eax, WORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+23
  0016d	50		 push	 eax
  0016e	8b 4d 10	 mov	 ecx, DWORD PTR _z$[ebp]
  00171	51		 push	 ecx
  00172	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  00175	52		 push	 edx
  00176	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00179	50		 push	 eax
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetWaterDepth@@3P6AHKHKF@ZA ; GetWaterDepth
  00180	83 c4 10	 add	 esp, 16			; 00000010H
  00183	3b f4		 cmp	 esi, esp
  00185	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018a	a3 0f 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+15, eax

; 5477 : 	FLOOR.WaterHeight = GetWaterHeight(x,y,z, FLOOR.RoomIndex);

  0018f	8b f4		 mov	 esi, esp
  00191	0f b7 05 17 00
	00 00		 movzx	 eax, WORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+23
  00198	50		 push	 eax
  00199	8b 4d 10	 mov	 ecx, DWORD PTR _z$[ebp]
  0019c	51		 push	 ecx
  0019d	8b 55 0c	 mov	 edx, DWORD PTR _y$[ebp]
  001a0	52		 push	 edx
  001a1	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?GetWaterHeight@@3P6AHKHKF@ZA ; GetWaterHeight
  001ab	83 c4 10	 add	 esp, 16			; 00000010H
  001ae	3b f4		 cmp	 esi, esp
  001b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b5	a3 13 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+19, eax

; 5478 : 
; 5479 : 	FLOOR.TestGraySector = IsGraySector(FLOOR.pFloor);

  001ba	a1 35 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?IsGraySector@@YA_NPAX@Z ; IsGraySector
  001c5	83 c4 04	 add	 esp, 4
  001c8	a2 01 00 00 00	 mov	 BYTE PTR ?FLOOR@@3UStrFloorAnalyse@@A+1, al

; 5480 : 
; 5481 : 	FLOOR.ClimbStatus = FindClimbStatus(FLOOR.pFloor);

  001cd	a1 35 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?FindClimbStatus@@YAGPAG@Z ; FindClimbStatus
  001d8	83 c4 04	 add	 esp, 4
  001db	66 a3 05 00 00
	00		 mov	 WORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+5, ax

; 5482 : 
; 5483 : 	if (FLOOR.ClimbStatus != 0) FLOOR.TestClimb=true;

  001e1	0f b7 05 05 00
	00 00		 movzx	 eax, WORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+5
  001e8	85 c0		 test	 eax, eax
  001ea	74 07		 je	 SHORT $LN2@CheckFloor
  001ec	c6 05 02 00 00
	00 01		 mov	 BYTE PTR ?FLOOR@@3UStrFloorAnalyse@@A+2, 1
$LN2@CheckFloor:

; 5484 : 
; 5485 : 	FLOOR.TestDeath = FindFloorType(FLOOR.pFloor, 5);

  001f3	6a 05		 push	 5
  001f5	a1 35 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53
  001fa	50		 push	 eax
  001fb	e8 00 00 00 00	 call	 ?FindFloorType@@YA_NPAGG@Z ; FindFloorType
  00200	83 c4 08	 add	 esp, 8
  00203	a2 04 00 00 00	 mov	 BYTE PTR ?FLOOR@@3UStrFloorAnalyse@@A+4, al

; 5486 : 	FLOOR.TestMonkey = FindFloorType(FLOOR.pFloor, 0x13);

  00208	6a 13		 push	 19			; 00000013H
  0020a	a1 35 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+53
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 ?FindFloorType@@YA_NPAGG@Z ; FindFloorType
  00215	83 c4 08	 add	 esp, 8
  00218	a2 03 00 00 00	 mov	 BYTE PTR ?FLOOR@@3UStrFloorAnalyse@@A+3, al

; 5487 : 
; 5488 : 	FLOOR.SlopeType = *Trng.pGlobTomb4->pAdr->pSlopeType;

  0021d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00222	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00228	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0022b	8b 02		 mov	 eax, DWORD PTR [edx]
  0022d	a3 39 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+57, eax

; 5489 : 	FLOOR.SlopeX = *Trng.pGlobTomb4->pAdr->pSlopeX;

  00232	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00237	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0023d	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00240	8b 02		 mov	 eax, DWORD PTR [edx]
  00242	a3 43 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67, eax

; 5490 : 	FLOOR.SlopeZ = *Trng.pGlobTomb4->pAdr->pSlopeZ;

  00247	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0024c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00252	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00255	8b 02		 mov	 eax, DWORD PTR [edx]
  00257	a3 47 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71, eax

; 5491 : 
; 5492 : 	FLOOR.SlopeOrienting = GetSlopeDirection();

  0025c	e8 00 00 00 00	 call	 ?GetSlopeDirection@@YAFXZ ; GetSlopeDirection
  00261	66 a3 3d 00 00
	00		 mov	 WORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+61, ax

; 5493 : 	ClickGrade = abs(FLOOR.SlopeX);

  00267	a1 43 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+67
  0026c	50		 push	 eax
  0026d	e8 00 00 00 00	 call	 _abs
  00272	83 c4 04	 add	 esp, 4
  00275	66 89 45 e0	 mov	 WORD PTR _ClickGrade$[ebp], ax

; 5494 : 	if (abs(FLOOR.SlopeZ) > ClickGrade) {

  00279	a1 47 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 _abs
  00284	83 c4 04	 add	 esp, 4
  00287	0f b7 4d e0	 movzx	 ecx, WORD PTR _ClickGrade$[ebp]
  0028b	3b c1		 cmp	 eax, ecx
  0028d	7e 12		 jle	 SHORT $LN1@CheckFloor

; 5495 : 		ClickGrade = abs(FLOOR.SlopeZ);

  0028f	a1 47 00 00 00	 mov	 eax, DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+71
  00294	50		 push	 eax
  00295	e8 00 00 00 00	 call	 _abs
  0029a	83 c4 04	 add	 esp, 4
  0029d	66 89 45 e0	 mov	 WORD PTR _ClickGrade$[ebp], ax
$LN1@CheckFloor:

; 5496 : 	}
; 5497 : 	FLOOR.SlopeClickGrade = ClickGrade;

  002a1	0f b7 45 e0	 movzx	 eax, WORD PTR _ClickGrade$[ebp]
  002a5	a3 3f 00 00 00	 mov	 DWORD PTR ?FLOOR@@3UStrFloorAnalyse@@A+63, eax

; 5498 : 
; 5499 : 	return true;

  002aa	b0 01		 mov	 al, 1
$LN5@CheckFloor:

; 5500 : 
; 5501 : }

  002ac	5f		 pop	 edi
  002ad	5e		 pop	 esi
  002ae	5b		 pop	 ebx
  002af	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  002b5	3b ec		 cmp	 ebp, esp
  002b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bc	8b e5		 mov	 esp, ebp
  002be	5d		 pop	 ebp
  002bf	c3		 ret	 0
?CheckFloor@@YA_NKHKH@Z ENDP				; CheckFloor
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@3f800000
;	COMDAT __real@3ff0000000000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT
tv92 = -228						; size = 4
tv82 = -224						; size = 8
__Z$46639 = -20						; size = 4
__N$ = -8						; size = 4
__X$ = 8						; size = 4
__Y$ = 12						; size = 4
??$_Pow_int@M@@YAMMH@Z PROC				; _Pow_int<float>, COMDAT

; 484  :         {unsigned int _N;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 485  :         if (_Y >= 0)

  0001e	83 7d 0c 00	 cmp	 DWORD PTR __Y$[ebp], 0
  00022	7c 08		 jl	 SHORT $LN7@Pow_int

; 486  :                 _N = (unsigned int)_Y;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Y$[ebp]
  00027	89 45 f8	 mov	 DWORD PTR __N$[ebp], eax

; 487  :         else

  0002a	eb 08		 jmp	 SHORT $LN6@Pow_int
$LN7@Pow_int:

; 488  :                 _N = (unsigned int)(-_Y);

  0002c	8b 45 0c	 mov	 eax, DWORD PTR __Y$[ebp]
  0002f	f7 d8		 neg	 eax
  00031	89 45 f8	 mov	 DWORD PTR __N$[ebp], eax
$LN6@Pow_int:

; 489  :         for (_Ty _Z = _Ty(1); ; _X *= _X)

  00034	d9 e8		 fld1
  00036	d9 5d ec	 fstp	 DWORD PTR __Z$46639[ebp]
  00039	eb 09		 jmp	 SHORT $LN5@Pow_int
$LN4@Pow_int:
  0003b	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  0003e	d8 4d 08	 fmul	 DWORD PTR __X$[ebp]
  00041	d9 5d 08	 fstp	 DWORD PTR __X$[ebp]
$LN5@Pow_int:

; 490  :                 {if ((_N & 1) != 0)

  00044	8b 45 f8	 mov	 eax, DWORD PTR __N$[ebp]
  00047	83 e0 01	 and	 eax, 1
  0004a	74 09		 je	 SHORT $LN2@Pow_int

; 491  :                         _Z *= _X;

  0004c	d9 45 ec	 fld	 DWORD PTR __Z$46639[ebp]
  0004f	d8 4d 08	 fmul	 DWORD PTR __X$[ebp]
  00052	d9 5d ec	 fstp	 DWORD PTR __Z$46639[ebp]
$LN2@Pow_int:

; 492  :                 if ((_N >>= 1) == 0)

  00055	8b 45 f8	 mov	 eax, DWORD PTR __N$[ebp]
  00058	d1 e8		 shr	 eax, 1
  0005a	89 45 f8	 mov	 DWORD PTR __N$[ebp], eax
  0005d	75 32		 jne	 SHORT $LN1@Pow_int

; 493  :                         return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

  0005f	83 7d 0c 00	 cmp	 DWORD PTR __Y$[ebp], 0
  00063	7d 0f		 jge	 SHORT $LN10@Pow_int
  00065	d9 45 ec	 fld	 DWORD PTR __Z$46639[ebp]
  00068	d9 e8		 fld1
  0006a	de f1		 fdivrp	 ST(1), ST(0)
  0006c	dd 9d 20 ff ff
	ff		 fstp	 QWORD PTR tv82[ebp]
  00072	eb 09		 jmp	 SHORT $LN11@Pow_int
$LN10@Pow_int:
  00074	d9 45 ec	 fld	 DWORD PTR __Z$46639[ebp]
  00077	dd 9d 20 ff ff
	ff		 fstp	 QWORD PTR tv82[ebp]
$LN11@Pow_int:
  0007d	dd 85 20 ff ff
	ff		 fld	 QWORD PTR tv82[ebp]
  00083	d9 9d 1c ff ff
	ff		 fstp	 DWORD PTR tv92[ebp]
  00089	d9 85 1c ff ff
	ff		 fld	 DWORD PTR tv92[ebp]
  0008f	eb 02		 jmp	 SHORT $LN3@Pow_int
$LN1@Pow_int:
  00091	eb a8		 jmp	 SHORT $LN4@Pow_int
$LN3@Pow_int:
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$_Pow_int@M@@YAMMH@Z ENDP				; _Pow_int<float>
_TEXT	ENDS
END
