; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	C:\Users\Dominik\Google Drive\TLD\Script\Plugin_Renaissance\Source\Plugin_Renaissance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?OldZoom@@3HA					; OldZoom
PUBLIC	?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
PUBLIC	?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
PUBLIC	?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
PUBLIC	?MyData@@3UStrMyData@@A				; MyData
PUBLIC	?StepRight@@3_NA				; StepRight
PUBLIC	?NoFlyby@@3HA					; NoFlyby
PUBLIC	?TexMyPluginName@@3PADA				; TexMyPluginName
PUBLIC	?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
PUBLIC	?TriggerLightningGlow@@3P6AXKHKK@ZA		; TriggerLightningGlow
PUBLIC	?TriggerFlareSparks@@3P6AXHHHHHHKK@ZA		; TriggerFlareSparks
PUBLIC	?RemoveActiveItem@@3P6AXF@ZA			; RemoveActiveItem
PUBLIC	?ItemNearLara@@3P6A_NPAXH@ZA			; ItemNearLara
PUBLIC	?TriggerSuperJetFlame@@3P6AXPAUStrItemTr4@@HH@ZA ; TriggerSuperJetFlame
PUBLIC	?StopSoundEffect@@3P6AXF@ZA			; StopSoundEffect
PUBLIC	?LaraTorch@@3P6AXPAUStrMovePosition@@0GH@ZA	; LaraTorch
PUBLIC	?TriggerDynamic@@3P6AXHHHHEEE@ZA		; TriggerDynamic
PUBLIC	?have_i_got_object@@3P6A_NH@ZA			; have_i_got_object
PUBLIC	?SOUND_EndScene@@3P6AXXZA			; SOUND_EndScene
PUBLIC	?IsComandoPremuto@@3P6A_NH@ZA			; IsComandoPremuto
PUBLIC	?S_DumpScreen@@3P6AXXZA				; S_DumpScreen
PUBLIC	?CreateMonoScreen@@3P6AXXZA			; CreateMonoScreen
PUBLIC	?FreeMonoScreen@@3P6AXXZA			; FreeMonoScreen
PUBLIC	?TIME_Init@@3P6AXXZA				; TIME_Init
PUBLIC	?SetD3DViewMatrix@@3P6AXXZA			; SetD3DViewMatrix
PUBLIC	?IsRoomOutside@@3P6AXKHK@ZA			; IsRoomOutside
PUBLIC	?UpdateLaraRoom@@3P6AXPAUStrItemTr4@@H@ZA	; UpdateLaraRoom
PUBLIC	?DoFlareLight@@3P6AXPAUStrMovePosition@@H@ZA	; DoFlareLight
PUBLIC	?KillActiveBaddies@@3P6AXPAUStrItemTr4@@@ZA	; KillActiveBaddies
PUBLIC	?AnimateItem@@3P6AXPAUStrItemTr4@@@ZA		; AnimateItem
PUBLIC	?InitialiseCamera@@3P6AXXZA			; InitialiseCamera
PUBLIC	?SetMapRoom@@3P6AXXZA				; SetMapRoom
PUBLIC	?MoveLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA ; MoveLaraPosition
PUBLIC	?TestLaraPosition@@3P6A_NPAUStrTestPosition@@PAUStrItemTr4@@1@ZA ; TestLaraPosition
PUBLIC	?GetBoundsAccurate@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA ; GetBoundsAccurate
PUBLIC	?GetStringLength@@3P6AHPADPAF1@ZA		; GetStringLength
PUBLIC	?freeTr4@@3P6AXPAX@ZA				; freeTr4
PUBLIC	?GetFlameTorch@@3P6AXXZA			; GetFlameTorch
PUBLIC	?SetFogColor@@3P6AXHHH@ZA			; SetFogColor
PUBLIC	?ExplosionFX@@3P6AXXZA				; ExplosionFX
PUBLIC	?ShatterObject@@3P6AXPAXPAUStrMeshInfo@@GGH@ZA	; ShatterObject
PUBLIC	?S_UpdateInput@@3P6AXXZA			; S_UpdateInput
PUBLIC	?S_CDStop@@3P6AXXZA				; S_CDStop
PUBLIC	?FlipMap@@3P6AXH@ZA				; FlipMap
PUBLIC	?InitialiseSpotCam@@3P6AXG@ZA			; InitialiseSpotCam
PUBLIC	?RefreshCamera@@3P6AXGPAG@ZA			; RefreshCamera
PUBLIC	?TestBoundCollide@@3P6A_NPAUStrItemTr4@@0H@ZA	; TestBoundCollide
PUBLIC	?GetCollidedObjects@@3P6AHPAUStrItemTr4@@H_NQAPAU1@PAUStrMeshInfo@@1@ZA ; GetCollidedObjects
PUBLIC	?TestBlockPush@@3P6A_NPAUStrItemTr4@@HF@ZA	; TestBlockPush
PUBLIC	?SetFade@@3P6AXHH@ZA				; SetFade
PUBLIC	?BikeCollideStaticObjects@@3P6AXKHKFH@ZA	; BikeCollideStaticObjects
PUBLIC	?BikeBaddieCollision@@3P6AXPAUStrItemTr4@@@ZA	; BikeBaddieCollision
PUBLIC	?Splash@@3P6AXPAUStrItemTr4@@@ZA		; Splash
PUBLIC	?GetWaterHeight@@3P6AHKHKF@ZA			; GetWaterHeight
PUBLIC	?TestTriggers@@3P6AXPAXHH@ZA			; TestTriggers
PUBLIC	?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA ; GetBestFrame
PUBLIC	?sgSaveGame@@3P6AXXZA				; sgSaveGame
PUBLIC	?S_InitialisePolyList@@3P6AXXZA			; S_InitialisePolyList
PUBLIC	?S_LoadGame@@3P6AXH@ZA				; S_LoadGame
PUBLIC	?S_SaveGame@@3P6AXH@ZA				; S_SaveGame
PUBLIC	?LaraTestClimbPos@@3P6A_NPAUStrItemTr4@@HHHHPAH@ZA ; LaraTestClimbPos
PUBLIC	?lara_col_climbright@@3P6AXPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; lara_col_climbright
PUBLIC	?LaraCheckForLetGo@@3P6A_NPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; LaraCheckForLetGo
PUBLIC	?LaraClimbRightCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; LaraClimbRightCornerTest
PUBLIC	?LaraClimbLeftCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; LaraClimbLeftCornerTest
PUBLIC	?LaraHangRightCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; LaraHangRightCornerTest
PUBLIC	?LaraHangLeftCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; LaraHangLeftCornerTest
PUBLIC	?CanLaraHangSideways@@3P6A_NPAUStrItemTr4@@PAUStrCollisionLara@@H@ZA ; CanLaraHangSideways
PUBLIC	?KillEffect@@3P6AXG@ZA				; KillEffect
PUBLIC	?AddDisplayPickup@@3P6AXH@ZA			; AddDisplayPickup
PUBLIC	?Draw2DSprite@@3P6AXHHHKH@ZA			; Draw2DSprite
PUBLIC	?phd_RotY@@3P6AXG@ZA				; phd_RotY
PUBLIC	?TriggerActive@@3P6A_NPAUStrItemTr4@@@ZA	; TriggerActive
PUBLIC	?ItemPushLara@@3P6AXPAUStrItemTr4@@0PAUStrCollisionLara@@_NH@ZA ; ItemPushLara
PUBLIC	?TriggerExhaustSmoke@@3P6AXKHKGHH@ZA		; TriggerExhaustSmoke
PUBLIC	?AddFire@@3P6AXKHKHGH@ZA			; AddFire
PUBLIC	?TriggerGunSmoke@@3P6AXKHKHHHHHH@ZA		; TriggerGunSmoke
PUBLIC	?GetJointAbsPosition@@3P6AXPAUStrItemTr4@@PAUStrMovePosition@@H@ZA ; GetJointAbsPosition
PUBLIC	?GetRandomControl@@3P6AHXZA			; GetRandomControl
PUBLIC	?DoBloodSplat@@3P6AXKHKHGG@ZA			; DoBloodSplat
PUBLIC	?DoLotsOfBlood@@3P6AXKHKHGGH@ZA			; DoLotsOfBlood
PUBLIC	?GetCeiling@@3P6AHPAXKHK@ZA			; GetCeiling
PUBLIC	?S_OutputPolyList@@3P6AXXZA			; S_OutputPolyList
PUBLIC	?OnTwoBlockPlatform@@3P6A_NPAUStrItemTr4@@KK@ZA	; OnTwoBlockPlatform
PUBLIC	?SoundStopAllSamples@@3P6AXXZA			; SoundStopAllSamples
PUBLIC	?WinFrameRate@@3P6AHXZA				; WinFrameRate
PUBLIC	?ItemNewRoom@@3P6AXHG@ZA			; ItemNewRoom
PUBLIC	?AddActiveItem@@3P6AXF@ZA			; AddActiveItem
PUBLIC	?SetCutSceneCamera@@3P6AXPAUStrItemTr4@@@ZA	; SetCutSceneCamera
PUBLIC	?AlterFOV@@3P6AXG@ZA				; AlterFOV
PUBLIC	?SetScreenFadeOut@@3P6AXGH@ZA			; SetScreenFadeOut
PUBLIC	?SetScreenFadeIn@@3P6AXG@ZA			; SetScreenFadeIn
PUBLIC	?CreatureActive@@3P6A_NF@ZA			; CreatureActive
PUBLIC	?ScaleCurrentMatrix@@3P6AXPAUStrTripla@@@ZA	; ScaleCurrentMatrix
PUBLIC	?convert_obj_to_invobj@@3P6AHF@ZA		; convert_obj_to_invobj
PUBLIC	?DrawThreeDeeObject2D@@3P6AXHHHHHHHHH@ZA	; DrawThreeDeeObject2D
PUBLIC	?GetHeight@@3P6AHPAXKHK@ZA			; GetHeight
PUBLIC	?GetFloor@@3P6APAXKHKPAF@ZA			; GetFloor
PUBLIC	?AlterFloorHeight@@3P6AXPAUStrItemTr4@@H@ZA	; AlterFloorHeight
PUBLIC	?CreatureDie@@3P6AXH_N@ZA			; CreatureDie
PUBLIC	?KillItem@@3P6AXG@ZA				; KillItem
PUBLIC	?TriggerUnderwaterExplosion@@3P6AXPAUStrItemTr4@@_N@ZA ; TriggerUnderwaterExplosion
PUBLIC	?TriggerExplosionSparks@@3P6AXKHKHHHH@ZA	; TriggerExplosionSparks
PUBLIC	?DoBar@@3P6AHHHHHHKK@ZA				; DoBar
PUBLIC	?StopAllSounds@@3P6AXXZA			; StopAllSounds
PUBLIC	?IsChannelPlaying@@3P6A_NH@ZA			; IsChannelPlaying
PUBLIC	?StopEffect@@3P6AXH@ZA				; StopEffect
PUBLIC	?SoundEffect@@3P6AXHPAXH@ZA			; SoundEffect
PUBLIC	?S_CDPlay@@3P6AXHH@ZA				; S_CDPlay
PUBLIC	?PrintString@@3P6AXHHGPADG@ZA			; PrintString
PUBLIC	?LaraBurn@@3P6AXXZA				; LaraBurn
PUBLIC	?BikeExplode@@3P6AXPAUStrItemTr4@@@ZA		; BikeExplode
PUBLIC	?ControlJeep@@3P6AHF@ZA				; ControlJeep
PUBLIC	?ControlSideCar@@3P6AHF@ZA			; ControlSideCar
PUBLIC	?MuoviTelecamera@@3P6AHPAXH@ZA			; MuoviTelecamera
PUBLIC	?GestioneTitleEMenu@@3P6AXHH@ZA			; GestioneTitleEMenu
PUBLIC	?tombRilocaCambiaStanzaDiCamera@@3P6AXH@ZA	; tombRilocaCambiaStanzaDiCamera
PUBLIC	?tombCicloPrincipale@@3P6AHHH@ZA		; tombCicloPrincipale
PUBLIC	?tombInviaLog@@3P6AXHPAD@ZA			; tombInviaLog
PUBLIC	?pcMostraMessaggio@@3P6AXPAD@ZA			; pcMostraMessaggio
PUBLIC	?DrawFlash@@3P6AXXZA				; DrawFlash
PUBLIC	?InviaMessaggioLog@@3P6AXHQAD@ZA		; InviaMessaggioLog
PUBLIC	?phd_PushMatrix@@3P6AXXZA			; phd_PushMatrix
PUBLIC	?phd_TranslateAbs@@3P6AXKHK@ZA			; phd_TranslateAbs
PUBLIC	?phd_RotYXZ@@3P6AXFFF@ZA			; phd_RotYXZ
PUBLIC	?phd_PutPolygons_train@@3P6AXPAUStrMeshTr4@@H@ZA ; phd_PutPolygons_train
PUBLIC	?GetFreeScarab@@3P6AHXZA			; GetFreeScarab
PUBLIC	?LOS@@3P6AHPAUGAME_VECTOR@@0@ZA			; LOS
PUBLIC	?mGetAngle@@3P6AHKKKK@ZA			; mGetAngle
PUBLIC	?TriggerSmallSplash@@3P6AXKHKH@ZA		; TriggerSmallSplash
PUBLIC	?CreateBubble@@3P6AXPAUStrPosizione@@GHH@ZA	; CreateBubble
PUBLIC	?SetupRipple@@3P6AXKHKHH@ZA			; SetupRipple
PUBLIC	?insert_object_into_list_v2@@3P6AXH@ZA		; insert_object_into_list_v2
PUBLIC	?AlignLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA ; AlignLaraPosition
PUBLIC	?GetWaterDepth@@3P6AHKHKF@ZA			; GetWaterDepth
PUBLIC	?S_GetObjectBounds@@3P6APAHPAUStrBoxCollisione@@@ZA ; S_GetObjectBounds
PUBLIC	?ACMSetVolume@@3P6AXXZA				; ACMSetVolume
PUBLIC	?EffettoShockwaveBaboon@@3P6AXPAUStrItemTr4@@@ZA ; EffettoShockwaveBaboon
PUBLIC	?ControlMineHelicopter@@3P6AXHPAX@ZA		; ControlMineHelicopter
PUBLIC	?DoHarpyEffects@@3P6AXPAUStrItemTr4@@H@ZA	; DoHarpyEffects
PUBLIC	?TriggerRiseEffect@@3P6AXPAUStrItemTr4@@@ZA	; TriggerRiseEffect
PUBLIC	?DrawSprite@@3P6AXHHHKKK@ZA			; DrawSprite
PUBLIC	?TriggerLightning@@3P6AXPAUStrPosizione@@0EKHHH@ZA ; TriggerLightning
PUBLIC	?SubBridgeTilt@@3P6AHPAUStrItemTr4@@KK@ZA	; SubBridgeTilt
PUBLIC	?GetTiltType@@3P6AGPAXKHK@ZA			; GetTiltType
PUBLIC	?S_SoundSampleIsPlaying@@3P6A_NG@ZA		; S_SoundSampleIsPlaying
PUBLIC	?TestCollision@@3P6AKPAUStrItemTr4@@0@ZA	; TestCollision
PUBLIC	?ObjectOnLOS2@@3P6AHPAUGAME_VECTOR@@0PAUStrPosizione@@PAPAUStrMeshInfo@@@ZA ; ObjectOnLOS2
PUBLIC	?DoSlider@@3P6AXHHHHHKKK@ZA			; DoSlider
PUBLIC	?DisableBaddieAI@@3P6AXF@ZA			; DisableBaddieAI
PUBLIC	?EnableBaddieAI@@3P6AHFH@ZA			; EnableBaddieAI
PUBLIC	?GetAITarget@@3P6AXPAUcreature_info@@@ZA	; GetAITarget
PUBLIC	?CreatureAIInfo@@3P6AXPAUStrItemTr4@@PAUAI_info@@@ZA ; CreatureAIInfo
PUBLIC	?phd_atan@@3P6AHHH@ZA				; phd_atan
PUBLIC	?GetCreatureMood@@3P6AXPAUStrItemTr4@@PAUAI_info@@H@ZA ; GetCreatureMood
PUBLIC	?CreatureMood@@3P6AXPAUStrItemTr4@@PAUAI_info@@H@ZA ; CreatureMood
PUBLIC	?AlertAllGuards@@3P6AXF@ZA			; AlertAllGuards
PUBLIC	?CreatureEffect@@3P6AFPAUStrItemTr4@@PAUbite_info@@P6AFKHKHGG@Z@ZA ; CreatureEffect
PUBLIC	?CreatureTilt@@3P6AXPAUStrItemTr4@@F@ZA		; CreatureTilt
PUBLIC	?CreatureJoint@@3P6AXPAUStrItemTr4@@FF@ZA	; CreatureJoint
PUBLIC	?CreatureAnimation@@3P6AHFFF@ZA			; CreatureAnimation
PUBLIC	?CreatureTurn@@3P6AFPAUStrItemTr4@@F@ZA		; CreatureTurn
PUBLIC	?CreatureUnderwater@@3P6AXPAUStrItemTr4@@H@ZA	; CreatureUnderwater
PUBLIC	?CreatureFloat@@3P6AXF@ZA			; CreatureFloat
PUBLIC	?BadFloor@@3P6AHHHHHHFPAUlot_info@@@ZA		; BadFloor
PUBLIC	?CreatureCreature@@3P6AHF@ZA			; CreatureCreature
PUBLIC	?ValidBox@@3P6AHPAUStrItemTr4@@FF@ZA		; ValidBox
PUBLIC	?EscapeBox@@3P6AXPAUStrItemTr4@@0F@ZA		; EscapeBox
PUBLIC	?TargetBox@@3P6AXPAUlot_info@@F@ZA		; TargetBox
PUBLIC	?SearchLOT@@3P6AHPAUlot_info@@H@ZA		; SearchLOT
PUBLIC	?UpdateLOT@@3P6AHPAUlot_info@@H@ZA		; UpdateLOT
PUBLIC	?InitialiseCreature@@3P6AXF@ZA			; InitialiseCreature
PUBLIC	?CreatureVault@@3P6AHFFHH@ZA			; CreatureVault
PUBLIC	?CreatureKill@@3P6AXPAUStrItemTr4@@HHH@ZA	; CreatureKill
PUBLIC	?AlertNearbyGuards@@3P6AXPAUStrItemTr4@@@ZA	; AlertNearbyGuards
PUBLIC	?AIGuard@@3P6AFPAUcreature_info@@@ZA		; AIGuard
PUBLIC	?SameZone@@3P6AFPAUcreature_info@@PAUStrItemTr4@@@ZA ; SameZone
PUBLIC	?AdjustStopperFlag@@3P6AXPAUStrItemTr4@@JJ@ZA	; AdjustStopperFlag
PUBLIC	?CreateEffect@@3P6AFF@ZA			; CreateEffect
PUBLIC	?TargetVisible@@3P6AHPAUStrItemTr4@@PAUAI_info@@@ZA ; TargetVisible
PUBLIC	?Targetable@@3P6AHPAUStrItemTr4@@PAUAI_info@@@ZA ; Targetable
PUBLIC	?GunShot@@3P6AFHHHFFF@ZA			; GunShot
PUBLIC	?GunHit@@3P6AFHHHFFF@ZA				; GunHit
PUBLIC	?GunMiss@@3P6AFHHHFFF@ZA			; GunMiss
PUBLIC	?ShotLara@@3P6AHPAUStrItemTr4@@PAUAI_info@@PAUbite_info@@FH@ZA ; ShotLara
PUBLIC	?phd_TranslateRel@@3P6AXHHH@ZA			; phd_TranslateRel
PUBLIC	?phd_RotX@@3P6AXF@ZA				; phd_RotX
PUBLIC	?phd_RotZ@@3P6AXF@ZA				; phd_RotZ
PUBLIC	?gar_RotYXZsuperpack@@3P6AXPAPAFH@ZA		; gar_RotYXZsuperpack
PUBLIC	?ShiftItem@@3P6AXPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; ShiftItem
PUBLIC	?LaraBaddieCollision@@3P6AXPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; LaraBaddieCollision
PUBLIC	?CreatureCollision@@3P6AXFPAUStrItemTr4@@PAUStrCollisionLara@@@ZA ; CreatureCollision
PUBLIC	?DetachSpark@@3P6AXJJ@ZA			; DetachSpark
PUBLIC	?GetFreeSpark@@3P6AJXZA				; GetFreeSpark
PUBLIC	?MyDllInstance@@3PAUHINSTANCE__@@A		; MyDllInstance
PUBLIC	?MyTomb4PatcherAddress@@3KA			; MyTomb4PatcherAddress
PUBLIC	?SubPatchArray@@3PAPAXA				; SubPatchArray
_BSS	SEGMENT
?OldZoom@@3HA DD 01H DUP (?)				; OldZoom
?SearchObject4TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject4TestPosition
?SearchObject2TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject2TestPosition
?SearchObject1TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject1TestPosition
?MyData@@3UStrMyData@@A DB 0fbeH DUP (?)		; MyData
	ALIGN	4

?StepRight@@3_NA DB 01H DUP (?)				; StepRight
	ALIGN	4

?NoFlyby@@3HA DD 01H DUP (?)				; NoFlyby
?TexMyPluginName@@3PADA DB 050H DUP (?)			; TexMyPluginName
?SearchObject3TestPosition@@3UStrTestPositionCmd@@A DB 020H DUP (?) ; SearchObject3TestPosition
?MyDllInstance@@3PAUHINSTANCE__@@A DD 01H DUP (?)	; MyDllInstance
?MyTomb4PatcherAddress@@3KA DD 01H DUP (?)		; MyTomb4PatcherAddress
?SubPatchArray@@3PAPAXA DD 01H DUP (?)			; SubPatchArray
_BSS	ENDS
_DATA	SEGMENT
?TriggerLightningGlow@@3P6AXKHKK@ZA DD 043acc0H		; TriggerLightningGlow
?TriggerFlareSparks@@3P6AXHHHHHHKK@ZA DD 0434200H	; TriggerFlareSparks
?RemoveActiveItem@@3P6AXF@ZA DD 0453ac0H		; RemoveActiveItem
?ItemNearLara@@3P6A_NPAXH@ZA DD 0436aa0H		; ItemNearLara
?TriggerSuperJetFlame@@3P6AXPAUStrItemTr4@@HH@ZA DD 0434fe0H ; TriggerSuperJetFlame
?StopSoundEffect@@3P6AXF@ZA DD 045ebf0H			; StopSoundEffect
?LaraTorch@@3P6AXPAUStrMovePosition@@0GH@ZA DD 0445040H	; LaraTorch
?TriggerDynamic@@3P6AXHHHHEEE@ZA DD 0435bf0H		; TriggerDynamic
?have_i_got_object@@3P6A_NH@ZA DD 043e760H		; have_i_got_object
?SOUND_EndScene@@3P6AXXZA DD 045eb40H			; SOUND_EndScene
?IsComandoPremuto@@3P6A_NH@ZA DD 0475890H		; IsComandoPremuto
?S_DumpScreen@@3P6AXXZA DD 047dcb0H			; S_DumpScreen
?CreateMonoScreen@@3P6AXXZA DD 04780e0H			; CreateMonoScreen
?FreeMonoScreen@@3P6AXXZA DD 0478100H			; FreeMonoScreen
?TIME_Init@@3P6AXXZA DD 048c580H			; TIME_Init
?SetD3DViewMatrix@@3P6AXXZA DD 048e7b0H			; SetD3DViewMatrix
?IsRoomOutside@@3P6AXKHK@ZA DD 044c050H			; IsRoomOutside
?UpdateLaraRoom@@3P6AXPAUStrItemTr4@@H@ZA DD 0446740H	; UpdateLaraRoom
?DoFlareLight@@3P6AXPAUStrMovePosition@@H@ZA DD 042f0a0H ; DoFlareLight
?KillActiveBaddies@@3P6AXPAUStrItemTr4@@@ZA DD 0437380H	; KillActiveBaddies
?AnimateItem@@3P6AXPAUStrItemTr4@@@ZA DD 0449280H	; AnimateItem
?InitialiseCamera@@3P6AXXZA DD 0442630H			; InitialiseCamera
?SetMapRoom@@3P6AXXZA DD 04863d0H			; SetMapRoom
?MoveLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA DD 0447b50H ; MoveLaraPosition
?TestLaraPosition@@3P6A_NPAUStrTestPosition@@PAUStrItemTr4@@1@ZA DD 04476a0H ; TestLaraPosition
?GetBoundsAccurate@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA DD 04504e0H ; GetBoundsAccurate
?GetStringLength@@3P6AHPADPAF1@ZA DD 0462b90H		; GetStringLength
?freeTr4@@3P6AXPAX@ZA DD 049e22dH			; freeTr4
?GetFlameTorch@@3P6AXXZA DD 041f940H			; GetFlameTorch
?SetFogColor@@3P6AXHHH@ZA DD 0475090H			; SetFogColor
?ExplosionFX@@3P6AXXZA DD 0437270H			; ExplosionFX
?ShatterObject@@3P6AXPAXPAUStrMeshInfo@@GGH@ZA DD 0432f00H ; ShatterObject
?S_UpdateInput@@3P6AXXZA DD 0475a80H			; S_UpdateInput
?S_CDStop@@3P6AXXZA DD 046bdc0H				; S_CDStop
?FlipMap@@3P6AXH@ZA DD 044bbf0H				; FlipMap
?InitialiseSpotCam@@3P6AXG@ZA DD 045f600H		; InitialiseSpotCam
?RefreshCamera@@3P6AXGPAG@ZA DD 044a0c0H		; RefreshCamera
?TestBoundCollide@@3P6A_NPAUStrItemTr4@@0H@ZA DD 0447270H ; TestBoundCollide
?GetCollidedObjects@@3P6AHPAUStrItemTr4@@H_NQAPAU1@PAUStrMeshInfo@@1@ZA DD 04484e0H ; GetCollidedObjects
?TestBlockPush@@3P6A_NPAUStrItemTr4@@HF@ZA DD 0409af0H	; TestBlockPush
?SetFade@@3P6AXHH@ZA DD 048a000H			; SetFade
?BikeCollideStaticObjects@@3P6AXKHKFH@ZA DD 0464fd0H	; BikeCollideStaticObjects
?BikeBaddieCollision@@3P6AXPAUStrItemTr4@@@ZA DD 04652d0H ; BikeBaddieCollision
?Splash@@3P6AXPAUStrItemTr4@@@ZA DD 0436cf0H		; Splash
?GetWaterHeight@@3P6AHKHKF@ZA DD 0449a50H		; GetWaterHeight
?TestTriggers@@3P6AXPAXHH@ZA DD 044a1f0H		; TestTriggers
?GetBestFrame@@3P6APAUStrBoxCollisione@@PAUStrItemTr4@@@ZA DD 0450560H ; GetBestFrame
?sgSaveGame@@3P6AXXZA DD 04596c0H			; sgSaveGame
?S_InitialisePolyList@@3P6AXXZA DD 047b6e0H		; S_InitialisePolyList
?S_LoadGame@@3P6AXH@ZA DD 04757d0H			; S_LoadGame
?S_SaveGame@@3P6AXH@ZA DD 0475630H			; S_SaveGame
?LaraTestClimbPos@@3P6A_NPAUStrItemTr4@@HHHHPAH@ZA DD 042bff0H ; LaraTestClimbPos
?lara_col_climbright@@3P6AXPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 042d010H ; lara_col_climbright
?LaraCheckForLetGo@@3P6A_NPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 042c5a0H ; LaraCheckForLetGo
?LaraClimbRightCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 042cd60H ; LaraClimbRightCornerTest
?LaraClimbLeftCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 042cae0H ; LaraClimbLeftCornerTest
?LaraHangRightCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 0426010H ; LaraHangRightCornerTest
?LaraHangLeftCornerTest@@3P6AHPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 04264a0H ; LaraHangLeftCornerTest
?CanLaraHangSideways@@3P6A_NPAUStrItemTr4@@PAUStrCollisionLara@@H@ZA DD 0426830H ; CanLaraHangSideways
?KillEffect@@3P6AXG@ZA DD 0453e40H			; KillEffect
?AddDisplayPickup@@3P6AXH@ZA DD 0452530H		; AddDisplayPickup
?Draw2DSprite@@3P6AXHHHKH@ZA DD 048b1a0H		; Draw2DSprite
?phd_RotY@@3P6AXG@ZA DD 048e130H			; phd_RotY
?TriggerActive@@3P6A_NPAUStrItemTr4@@@ZA DD 044acb0H	; TriggerActive
?ItemPushLara@@3P6AXPAUStrItemTr4@@0PAUStrCollisionLara@@_NH@ZA DD 0446ec0H ; ItemPushLara
?TriggerExhaustSmoke@@3P6AXKHKGHH@ZA DD 04643a0H	; TriggerExhaustSmoke
?AddFire@@3P6AXKHKHGH@ZA DD 0437f40H			; AddFire
?TriggerGunSmoke@@3P6AXKHKHHHHHH@ZA DD 0438340H		; TriggerGunSmoke
?GetJointAbsPosition@@3P6AXPAUStrItemTr4@@PAUStrMovePosition@@H@ZA DD 045f160H ; GetJointAbsPosition
?GetRandomControl@@3P6AHXZA DD 048eb50H			; GetRandomControl
?DoBloodSplat@@3P6AXKHKHGG@ZA DD 0436bd0H		; DoBloodSplat
?DoLotsOfBlood@@3P6AXKHKHGGH@ZA DD 0436c40H		; DoLotsOfBlood
?GetCeiling@@3P6AHPAXKHK@ZA DD 044ad20H			; GetCeiling
?S_OutputPolyList@@3P6AXXZA DD 047d990H			; S_OutputPolyList
?OnTwoBlockPlatform@@3P6A_NPAUStrItemTr4@@KK@ZA DD 0415a10H ; OnTwoBlockPlatform
?SoundStopAllSamples@@3P6AXXZA DD 0471e80H		; SoundStopAllSamples
?WinFrameRate@@3P6AHXZA DD 048d4d0H			; WinFrameRate
?ItemNewRoom@@3P6AXHG@ZA DD 0453c80H			; ItemNewRoom
?AddActiveItem@@3P6AXF@ZA DD 0453c10H			; AddActiveItem
?SetCutSceneCamera@@3P6AXPAUStrItemTr4@@@ZA DD 0418bb0H	; SetCutSceneCamera
?AlterFOV@@3P6AXG@ZA DD 048d660H			; AlterFOV
?SetScreenFadeOut@@3P6AXGH@ZA DD 0439740H		; SetScreenFadeOut
?SetScreenFadeIn@@3P6AXG@ZA DD 0439790H			; SetScreenFadeIn
?CreatureActive@@3P6A_NF@ZA DD 043f370H			; CreatureActive
?ScaleCurrentMatrix@@3P6AXPAUStrTripla@@@ZA DD 048d7f0H	; ScaleCurrentMatrix
?convert_obj_to_invobj@@3P6AHF@ZA DD 043e950H		; convert_obj_to_invobj
?DrawThreeDeeObject2D@@3P6AXHHHHHHHHH@ZA DD 043b710H	; DrawThreeDeeObject2D
?GetHeight@@3P6AHPAXKHK@ZA DD 0449bd0H			; GetHeight
?GetFloor@@3P6APAXKHKPAF@ZA DD 0449880H			; GetFloor
?AlterFloorHeight@@3P6AXPAUStrItemTr4@@H@ZA DD 04497c0H	; AlterFloorHeight
?CreatureDie@@3P6AXH_N@ZA DD 0440840H			; CreatureDie
?KillItem@@3P6AXG@ZA DD 0453690H			; KillItem
?TriggerUnderwaterExplosion@@3P6AXPAUStrItemTr4@@_N@ZA DD 042b080H ; TriggerUnderwaterExplosion
?TriggerExplosionSparks@@3P6AXKHKHHHH@ZA DD 0434480H	; TriggerExplosionSparks
?DoBar@@3P6AHHHHHHKK@ZA DD 047af60H			; DoBar
?StopAllSounds@@3P6AXXZA DD 045ec50H			; StopAllSounds
?IsChannelPlaying@@3P6A_NH@ZA DD 0471f60H		; IsChannelPlaying
?StopEffect@@3P6AXH@ZA DD 0471ea0H			; StopEffect
?SoundEffect@@3P6AXHPAXH@ZA DD 045e440H			; SoundEffect
?S_CDPlay@@3P6AXHH@ZA DD 046bd20H			; S_CDPlay
?PrintString@@3P6AXHHGPADG@ZA DD 0462d00H		; PrintString
?LaraBurn@@3P6AXXZA DD 0414d90H				; LaraBurn
?BikeExplode@@3P6AXPAUStrItemTr4@@@ZA DD 0466d40H	; BikeExplode
?ControlJeep@@3P6AHF@ZA DD 0466610H			; ControlJeep
?ControlSideCar@@3P6AHF@ZA DD 0463e00H			; ControlSideCar
?MuoviTelecamera@@3P6AHPAXH@ZA DD 0442700H		; MuoviTelecamera
?GestioneTitleEMenu@@3P6AXHH@ZA DD 0451440H		; GestioneTitleEMenu
?tombRilocaCambiaStanzaDiCamera@@3P6AXH@ZA DD 04508a0H	; tombRilocaCambiaStanzaDiCamera
?tombCicloPrincipale@@3P6AHHH@ZA DD 0448b10H		; tombCicloPrincipale
?tombInviaLog@@3P6AXHPAD@ZA DD 0499ec0H			; tombInviaLog
?pcMostraMessaggio@@3P6AXPAD@ZA DD 04064e1H		; pcMostraMessaggio
?DrawFlash@@3P6AXXZA DD 048a3b0H			; DrawFlash
?InviaMessaggioLog@@3P6AXHQAD@ZA DD 0499ec0H		; InviaMessaggioLog
?phd_PushMatrix@@3P6AXXZA DD 048df30H			; phd_PushMatrix
?phd_TranslateAbs@@3P6AXKHK@ZA DD 048e690H		; phd_TranslateAbs
?phd_RotYXZ@@3P6AXFFF@ZA DD 048e4a0H			; phd_RotYXZ
?phd_PutPolygons_train@@3P6AXPAUStrMeshTr4@@H@ZA DD 047e340H ; phd_PutPolygons_train
?GetFreeScarab@@3P6AHXZA DD 040e180H			; GetFreeScarab
?LOS@@3P6AHPAUGAME_VECTOR@@0@ZA DD 044b260H		; LOS
?mGetAngle@@3P6AHKKKK@ZA DD 048d9c0H			; mGetAngle
?TriggerSmallSplash@@3P6AXKHKH@ZA DD 0439030H		; TriggerSmallSplash
?CreateBubble@@3P6AXPAUStrPosizione@@GHH@ZA DD 04391a0H	; CreateBubble
?SetupRipple@@3P6AXKHKHH@ZA DD 04355d0H			; SetupRipple
?insert_object_into_list_v2@@3P6AXH@ZA DD 043bf30H	; insert_object_into_list_v2
?AlignLaraPosition@@3P6A_NPAUStrMovePosition@@PAUStrItemTr4@@1@ZA DD 04477e0H ; AlignLaraPosition
?GetWaterDepth@@3P6AHKHKF@ZA DD 0432700H		; GetWaterDepth
?S_GetObjectBounds@@3P6APAHPAUStrBoxCollisione@@@ZA DD 047dd00H ; S_GetObjectBounds
?ACMSetVolume@@3P6AXXZA DD 046beb0H			; ACMSetVolume
?EffettoShockwaveBaboon@@3P6AXPAUStrItemTr4@@@ZA DD 0402950H ; EffettoShockwaveBaboon
?ControlMineHelicopter@@3P6AXHPAX@ZA DD 0417c70H	; ControlMineHelicopter
?DoHarpyEffects@@3P6AXPAUStrItemTr4@@H@ZA DD 0407390H	; DoHarpyEffects
?TriggerRiseEffect@@3P6AXPAUStrItemTr4@@@ZA DD 0411470H	; TriggerRiseEffect
?DrawSprite@@3P6AXHHHKKK@ZA DD 0489840H			; DrawSprite
?TriggerLightning@@3P6AXPAUStrPosizione@@0EKHHH@ZA DD 043a7e0H ; TriggerLightning
?SubBridgeTilt@@3P6AHPAUStrItemTr4@@KK@ZA DD 0455390H	; SubBridgeTilt
?GetTiltType@@3P6AGPAXKHK@ZA DD 04467a0H		; GetTiltType
?S_SoundSampleIsPlaying@@3P6A_NG@ZA DD 0471f60H		; S_SoundSampleIsPlaying
?TestCollision@@3P6AKPAUStrItemTr4@@0@ZA DD 045ed00H	; TestCollision
?ObjectOnLOS2@@3P6AHPAUGAME_VECTOR@@0PAUStrPosizione@@PAPAUStrMeshInfo@@@ZA DD 044c270H ; ObjectOnLOS2
?DoSlider@@3P6AXHHHHHKKK@ZA DD 0478d20H			; DoSlider
?DisableBaddieAI@@3P6AXF@ZA DD 0454750H			; DisableBaddieAI
?EnableBaddieAI@@3P6AHFH@ZA DD 0454790H			; EnableBaddieAI
?GetAITarget@@3P6AXPAUcreature_info@@@ZA DD 0441ee0H	; GetAITarget
?CreatureAIInfo@@3P6AXPAUStrItemTr4@@PAUAI_info@@@ZA DD 043f3e0H ; CreatureAIInfo
?phd_atan@@3P6AHHH@ZA DD 048de90H			; phd_atan
?GetCreatureMood@@3P6AXPAUStrItemTr4@@PAUAI_info@@H@ZA DD 043fbd0H ; GetCreatureMood
?CreatureMood@@3P6AXPAUStrItemTr4@@PAUAI_info@@H@ZA DD 043fe10H ; CreatureMood
?AlertAllGuards@@3P6AXF@ZA DD 0441d10H			; AlertAllGuards
?CreatureEffect@@3P6AFPAUStrItemTr4@@PAUbite_info@@P6AFKHKHGG@Z@ZA DD 04418e0H ; CreatureEffect
?CreatureTilt@@3P6AXPAUStrItemTr4@@F@ZA DD 04416b0H	; CreatureTilt
?CreatureJoint@@3P6AXPAUStrItemTr4@@FF@ZA DD 04416f0H	; CreatureJoint
?CreatureAnimation@@3P6AHFFF@ZA DD 04409f0H		; CreatureAnimation
?CreatureTurn@@3P6AFPAUStrItemTr4@@F@ZA DD 0441430H	; CreatureTurn
?CreatureUnderwater@@3P6AXPAUStrItemTr4@@H@ZA DD 0441850H ; CreatureUnderwater
?CreatureFloat@@3P6AXF@ZA DD 0441750H			; CreatureFloat
?BadFloor@@3P6AHHHHHHFPAUlot_info@@@ZA DD 0440790H	; BadFloor
?CreatureCreature@@3P6AHF@ZA DD 0440220H		; CreatureCreature
?ValidBox@@3P6AHPAUStrItemTr4@@FF@ZA DD 043fb20H	; ValidBox
?EscapeBox@@3P6AXPAUStrItemTr4@@0F@ZA DD 043fa70H	; EscapeBox
?TargetBox@@3P6AXPAUlot_info@@F@ZA DD 043f9d0H		; TargetBox
?SearchLOT@@3P6AHPAUlot_info@@H@ZA DD 043f760H		; SearchLOT
?UpdateLOT@@3P6AHPAUlot_info@@H@ZA DD 043f7d0H		; UpdateLOT
?InitialiseCreature@@3P6AXF@ZA DD 043f330H		; InitialiseCreature
?CreatureVault@@3P6AHFFHH@ZA DD 04419a0H		; CreatureVault
?CreatureKill@@3P6AXPAUStrItemTr4@@HHH@ZA DD 04419a0H	; CreatureKill
?AlertNearbyGuards@@3P6AXPAUStrItemTr4@@@ZA DD 0441d90H	; AlertNearbyGuards
?AIGuard@@3P6AFPAUcreature_info@@@ZA DD 0441e30H	; AIGuard
?SameZone@@3P6AFPAUcreature_info@@PAUStrItemTr4@@@ZA DD 0442220H ; SameZone
?AdjustStopperFlag@@3P6AXPAUStrItemTr4@@JJ@ZA DD 0442400H ; AdjustStopperFlag
?CreateEffect@@3P6AFF@ZA DD 0453dd0H			; CreateEffect
?TargetVisible@@3P6AHPAUStrItemTr4@@PAUAI_info@@@ZA DD 040adf0H ; TargetVisible
?Targetable@@3P6AHPAUStrItemTr4@@PAUAI_info@@@ZA DD 040aec0H ; Targetable
?GunShot@@3P6AFHHHFFF@ZA DD 040af90H			; GunShot
?GunHit@@3P6AFHHHFFF@ZA DD 040afa0H			; GunHit
?GunMiss@@3P6AFHHHFFF@ZA DD 040b060H			; GunMiss
?ShotLara@@3P6AHPAUStrItemTr4@@PAUAI_info@@PAUbite_info@@FH@ZA DD 040b110H ; ShotLara
?phd_TranslateRel@@3P6AXHHH@ZA DD 048dfd0H		; phd_TranslateRel
?phd_RotX@@3P6AXF@ZA DD 048e080H			; phd_RotX
?phd_RotZ@@3P6AXF@ZA DD 048e1e0H			; phd_RotZ
?gar_RotYXZsuperpack@@3P6AXPAPAFH@ZA DD 044fe00H	; gar_RotYXZsuperpack
?ShiftItem@@3P6AXPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 0446700H ; ShiftItem
?LaraBaddieCollision@@3P6AXPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 0446940H ; LaraBaddieCollision
?CreatureCollision@@3P6AXFPAUStrItemTr4@@PAUStrCollisionLara@@@ZA DD 0446be0H ; CreatureCollision
?DetachSpark@@3P6AXJJ@ZA DD 0433770H			; DetachSpark
?GetFreeSpark@@3P6AJXZA DD 0433830H			; GetFreeSpark
_DATA	ENDS
PUBLIC	?CreateMyCodePatches@@YA_NXZ			; CreateMyCodePatches
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\users\dominik\google drive\tld\script\plugin_renaissance\source\plugin_renaissance.cpp
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu /ZI
rtc$IMZ	ENDS
;	COMDAT ?CreateMyCodePatches@@YA_NXZ
_TEXT	SEGMENT
?CreateMyCodePatches@@YA_NXZ PROC			; CreateMyCodePatches, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 115  : 	// the call of the code patch to TYPE_HERE:
; 116  : 	// example: 
; 117  : 	// SET_PATCH(Path_RedirCollision)
; 118  : 	// to call the function Patch_RedirCollision() created with TrngPatcher program (command Assmembly->Create Dynamic Patch Generator)
; 119  : 
; 120  : 	return true;

  0001e	b0 01		 mov	 al, 1

; 121  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?CreateMyCodePatches@@YA_NXZ ENDP			; CreateMyCodePatches
_TEXT	ENDS
PUBLIC	?MainPatcher@@YAHXZ				; MainPatcher
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?MainPatcher@@YAHXZ
_TEXT	SEGMENT
?MainPatcher@@YAHXZ PROC				; MainPatcher, COMDAT

; 146  : 	and eax, 0ffffh

  00000	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 147  : 	mov eax, dword ptr [SubPatchArray+eax*4];

  00005	8b 04 85 00 00
	00 00		 mov	 eax, DWORD PTR ?SubPatchArray@@3PAPAXA[eax*4]

; 148  : 	jmp eax

  0000c	ff e0		 jmp	 eax
?MainPatcher@@YAHXZ ENDP				; MainPatcher
_TEXT	ENDS
PUBLIC	?cbInitProgram@@YAXHQAPAD@Z			; cbInitProgram
EXTRN	?ClearMemory@@YAXPAXK@Z:PROC			; ClearMemory
EXTRN	?Trng@@3UStrTrngInfos@@A:BYTE			; Trng
EXTRN	__RTC_CheckEsp:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbInitProgram@@YAXHQAPAD@Z
_TEXT	SEGMENT
_NumberLoadedPlugins$ = 8				; size = 4
_VetPluginNames$ = 12					; size = 4
?cbInitProgram@@YAXHQAPAD@Z PROC			; cbInitProgram, COMDAT

; 158  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 159  : 
; 160  : 	// save number of plugins (enclosed yours and the tomb_nextgeneration.dll ) and their names
; 161  : 	// these data will be used to locate IDs of any loaded plugins using FindPluginID() function
; 162  : 	Trng.TotPlugins = NumberLoadedPlugins;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _NumberLoadedPlugins$[ebp]
  00021	a3 28 00 00 00	 mov	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+40, eax

; 163  : 	Trng.pVetPluginNames = VetPluginNames;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _VetPluginNames$[ebp]
  00029	a3 2c 00 00 00	 mov	 DWORD PTR ?Trng@@3UStrTrngInfos@@A+44, eax

; 164  : 
; 165  : 	// clear all my global variables
; 166  : 	ClearMemory(&MyData, sizeof(StrMyData));

  0002e	68 be 0f 00 00	 push	 4030			; 00000fbeH
  00033	68 00 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A ; MyData
  00038	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  0003d	83 c4 08	 add	 esp, 8

; 167  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?cbInitProgram@@YAXHQAPAD@Z ENDP			; cbInitProgram
_TEXT	ENDS
PUBLIC	?cbInitGame@@YAXXZ				; cbInitGame
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbInitGame@@YAXXZ
_TEXT	SEGMENT
?cbInitGame@@YAXXZ PROC					; cbInitGame, COMDAT

; 171  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 172  : 	// here you can initialize your global data for whole adventure
; 173  : 	// this procedure will be called only once, before loading title level
; 174  : 
; 175  : 
; 176  : }

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?cbInitGame@@YAXXZ ENDP					; cbInitGame
_TEXT	ENDS
PUBLIC	?cbInitLevel@@YAXHHK@Z				; cbInitLevel
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbInitLevel@@YAXHHK@Z
_TEXT	SEGMENT
_LevelNow$ = 8						; size = 4
_LevelOld$ = 12						; size = 4
_FIL_Flags$ = 16					; size = 4
?cbInitLevel@@YAXHHK@Z PROC				; cbInitLevel, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 180  : 	// here you can initialize specific items of currnet level.
; 181  : 	// it will be called only once for level, when all items has been already initialized
; 182  : 	// and just a moment before entering in main game cycle.
; 183  : 	NoFlyby = *Trng.pGlobTomb4->pAdr->pTestFlybyInProgress; // For FOV Fix

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 91 14 01 00
	00		 mov	 edx, DWORD PTR [ecx+276]
  0002f	8b 02		 mov	 eax, DWORD PTR [edx]
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?NoFlyby@@3HA, eax ; NoFlyby

; 184  : }

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	5b		 pop	 ebx
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?cbInitLevel@@YAXHHK@Z ENDP				; cbInitLevel
_TEXT	ENDS
PUBLIC	?cbSaveMyData@@YAKPAPAEH@Z			; cbSaveMyData
EXTRN	?AddTokenFinalSequence@@YAXPAPAGPAH@Z:PROC	; AddTokenFinalSequence
EXTRN	?AddNGToken@@YAXGKKPAXPAPAGPAH@Z:PROC		; AddNGToken
EXTRN	?GetMemory@@YAPAXK@Z:PROC			; GetMemory
EXTRN	?FreeMemory@@YAXPAX@Z:PROC			; FreeMemory
EXTRN	@_RTC_CheckStackVars@8:PROC
_BSS	SEGMENT
?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA DD 01H DUP (?) ; `cbSaveMyData'::`2'::pVetExtras
; Function compile flags: /Odtp /RTCsu /ZI
_BSS	ENDS
;	COMDAT ?cbSaveMyData@@YAKPAPAEH@Z
_TEXT	SEGMENT
_TotNewActions$ = -44					; size = 4
_TotNWords$ = -32					; size = 4
_i$ = -20						; size = 4
_SizeData$ = -8						; size = 4
_pAdrZone$ = 8						; size = 4
_SavingType$ = 12					; size = 4
?cbSaveMyData@@YAKPAPAEH@Z PROC				; cbSaveMyData, COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 195  : 	DWORD SizeData;
; 196  : 	int i;
; 197  : 	static WORD *pVetExtras;
; 198  : 	int TotNWords;
; 199  : 	int TotNewActions;
; 200  : 
; 201  : 
; 202  : 	if (SavingType & SAVT_COMPLETED) {

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _SavingType$[ebp]
  00021	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00026	74 28		 je	 SHORT $LN8@cbSaveMyDa

; 203  : 		// this call is not to save data but only it is a confirm that the previous saving has been completed
; 204  : 		// now we can free the temporary memory used to save the data in previous call
; 205  : 		if (pVetExtras != NULL) {

  00028	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, 0
  0002f	74 18		 je	 SHORT $LN7@cbSaveMyDa

; 206  : 			FreeMemory(pVetExtras);

  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?FreeMemory@@YAXPAX@Z	; FreeMemory
  0003c	83 c4 04	 add	 esp, 4

; 207  : 			pVetExtras=NULL;

  0003f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, 0
$LN7@cbSaveMyDa:

; 208  : 		}
; 209  : 
; 210  : 		return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 3e 01 00 00	 jmp	 $LN9@cbSaveMyDa
$LN8@cbSaveMyDa:

; 211  : 	}
; 212  : 
; 213  : 
; 214  : 	TotNWords=0;

  00050	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _TotNWords$[ebp], 0

; 215  : 	pVetExtras = (WORD *) GetMemory(16);

  00057	6a 10		 push	 16			; 00000010H
  00059	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  0005e	83 c4 04	 add	 esp, 4
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA, eax

; 216  : 	// save id of my plugin in first word
; 217  : 
; 218  : 	pVetExtras[TotNWords++] = Trng.IdMyPlugin;

  00066	8b 45 e0	 mov	 eax, DWORD PTR _TotNWords$[ebp]
  00069	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  0006f	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?Trng@@3UStrTrngInfos@@A
  00076	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  0007a	8b 45 e0	 mov	 eax, DWORD PTR _TotNWords$[ebp]
  0007d	83 c0 01	 add	 eax, 1
  00080	89 45 e0	 mov	 DWORD PTR _TotNWords$[ebp], eax

; 219  : 
; 220  : 	if (SavingType & SAVT_LOCAL_DATA) {

  00083	8b 45 0c	 mov	 eax, DWORD PTR _SavingType$[ebp]
  00086	83 e0 01	 and	 eax, 1
  00089	0f 84 b1 00 00
	00		 je	 $LN6@cbSaveMyDa

; 221  : 		// save local data
; 222  : 
; 223  : 		// save Local structure
; 224  : 		AddNGToken(NGTAG_LOCAL_DATA, NO_ARRAY, sizeof(StrSavegameLocalData), &MyData.Save.Local, 
; 225  : 						&pVetExtras, &TotNWords);

  0008f	8d 45 e0	 lea	 eax, DWORD PTR _TotNWords$[ebp]
  00092	50		 push	 eax
  00093	68 00 00 00 00	 push	 OFFSET ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00098	68 01 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+1
  0009d	6a 01		 push	 1
  0009f	68 00 00 01 00	 push	 65536			; 00010000H
  000a4	6a 02		 push	 2
  000a6	e8 00 00 00 00	 call	 ?AddNGToken@@YAXGKKPAXPAPAGPAH@Z ; AddNGToken
  000ab	83 c4 18	 add	 esp, 24			; 00000018H

; 226  : 
; 227  : 
; 228  : 		// save all (currently enabled) progressive actions
; 229  : 		// before saving, compact progressive action array to remove intermediate free records
; 230  : 		TotNewActions=0;

  000ae	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _TotNewActions$[ebp], 0

; 231  : 
; 232  : 		for (i=0;i<MyData.TotProgrActions;i++) {

  000b5	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000bc	eb 09		 jmp	 SHORT $LN5@cbSaveMyDa
$LN4@cbSaveMyDa:
  000be	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000c1	83 c0 01	 add	 eax, 1
  000c4	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN5@cbSaveMyDa:
  000c7	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000ca	3b 05 02 00 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  000d0	7d 3b		 jge	 SHORT $LN3@cbSaveMyDa

; 233  : 			if (MyData.VetProgrActions[i].ActionType != AXN_FREE) {

  000d2	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000d5	c1 e0 05	 shl	 eax, 5
  000d8	0f b7 88 0a 00
	00 00		 movzx	 ecx, WORD PTR ?MyData@@3UStrMyData@@A[eax+10]
  000df	85 c9		 test	 ecx, ecx
  000e1	74 28		 je	 SHORT $LN2@cbSaveMyDa

; 234  : 
; 235  : 				MyData.VetProgrActions[TotNewActions] = MyData.VetProgrActions[i];

  000e3	8b 75 ec	 mov	 esi, DWORD PTR _i$[ebp]
  000e6	c1 e6 05	 shl	 esi, 5
  000e9	81 c6 0a 00 00
	00		 add	 esi, OFFSET ?MyData@@3UStrMyData@@A+10
  000ef	8b 7d d4	 mov	 edi, DWORD PTR _TotNewActions$[ebp]
  000f2	c1 e7 05	 shl	 edi, 5
  000f5	81 c7 0a 00 00
	00		 add	 edi, OFFSET ?MyData@@3UStrMyData@@A+10
  000fb	b9 08 00 00 00	 mov	 ecx, 8
  00100	f3 a5		 rep movsd

; 236  : 
; 237  : 				TotNewActions++;

  00102	8b 45 d4	 mov	 eax, DWORD PTR _TotNewActions$[ebp]
  00105	83 c0 01	 add	 eax, 1
  00108	89 45 d4	 mov	 DWORD PTR _TotNewActions$[ebp], eax
$LN2@cbSaveMyDa:

; 238  : 			}
; 239  : 		}

  0010b	eb b1		 jmp	 SHORT $LN4@cbSaveMyDa
$LN3@cbSaveMyDa:

; 240  : 		// update new valuese after recompatting
; 241  : 		MyData.LastProgrActionIndex =0;

  0010d	c7 05 06 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+6, 0

; 242  : 		MyData.TotProgrActions= TotNewActions;

  00117	8b 45 d4	 mov	 eax, DWORD PTR _TotNewActions$[ebp]
  0011a	a3 02 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+2, eax

; 243  : 
; 244  : 		// store all progressive action records
; 245  : 		AddNGToken(NGTAG_PROGRESSIVE_ACTIONS, MyData.TotProgrActions, sizeof(StrProgressiveAction), 
; 246  : 				&MyData.VetProgrActions[0], &pVetExtras, &TotNWords);

  0011f	8d 45 e0	 lea	 eax, DWORD PTR _TotNWords$[ebp]
  00122	50		 push	 eax
  00123	68 00 00 00 00	 push	 OFFSET ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00128	68 0a 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+10
  0012d	6a 20		 push	 32			; 00000020H
  0012f	8b 0d 02 00 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+2
  00135	51		 push	 ecx
  00136	6a 01		 push	 1
  00138	e8 00 00 00 00	 call	 ?AddNGToken@@YAXGKKPAXPAPAGPAH@Z ; AddNGToken
  0013d	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@cbSaveMyDa:

; 247  : 
; 248  : 	}
; 249  : 
; 250  : 	if (SavingType & SAVT_GLOBAL_DATA) {

  00140	8b 45 0c	 mov	 eax, DWORD PTR _SavingType$[ebp]
  00143	83 e0 02	 and	 eax, 2
  00146	74 1f		 je	 SHORT $LN1@cbSaveMyDa

; 251  : 		// save global data
; 252  : 		AddNGToken(NGTAG_GLOBAL_DATA, NO_ARRAY, sizeof(StrSavegameGlobalData), &MyData.Save.Global , 
; 253  : 						&pVetExtras, &TotNWords);

  00148	8d 45 e0	 lea	 eax, DWORD PTR _TotNWords$[ebp]
  0014b	50		 push	 eax
  0014c	68 00 00 00 00	 push	 OFFSET ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00151	68 00 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A ; MyData
  00156	6a 01		 push	 1
  00158	68 00 00 01 00	 push	 65536			; 00010000H
  0015d	6a 03		 push	 3
  0015f	e8 00 00 00 00	 call	 ?AddNGToken@@YAXGKKPAXPAPAGPAH@Z ; AddNGToken
  00164	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@cbSaveMyDa:

; 254  : 	}
; 255  : 	// write final sequence
; 256  : 	AddTokenFinalSequence(&pVetExtras, &TotNWords);

  00167	8d 45 e0	 lea	 eax, DWORD PTR _TotNWords$[ebp]
  0016a	50		 push	 eax
  0016b	68 00 00 00 00	 push	 OFFSET ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00170	e8 00 00 00 00	 call	 ?AddTokenFinalSequence@@YAXPAPAGPAH@Z ; AddTokenFinalSequence
  00175	83 c4 08	 add	 esp, 8

; 257  : 
; 258  : 	// return to trng the infos about start of memory where there are our data and their size:
; 259  : 	*pAdrZone = (BYTE *) pVetExtras;

  00178	8b 45 08	 mov	 eax, DWORD PTR _pAdrZone$[ebp]
  0017b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pVetExtras@?1??cbSaveMyData@@YAKPAPAEH@Z@4PAGA
  00181	89 08		 mov	 DWORD PTR [eax], ecx

; 260  : 	SizeData = TotNWords * 2;

  00183	8b 45 e0	 mov	 eax, DWORD PTR _TotNWords$[ebp]
  00186	d1 e0		 shl	 eax, 1
  00188	89 45 f8	 mov	 DWORD PTR _SizeData$[ebp], eax

; 261  : 
; 262  : 	return SizeData;

  0018b	8b 45 f8	 mov	 eax, DWORD PTR _SizeData$[ebp]
$LN9@cbSaveMyDa:

; 263  : 	
; 264  : 
; 265  : }

  0018e	52		 push	 edx
  0018f	8b cd		 mov	 ecx, ebp
  00191	50		 push	 eax
  00192	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN13@cbSaveMyDa
  00198	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0019d	58		 pop	 eax
  0019e	5a		 pop	 edx
  0019f	5f		 pop	 edi
  001a0	5e		 pop	 esi
  001a1	5b		 pop	 ebx
  001a2	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  001a8	3b ec		 cmp	 ebp, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001af	8b e5		 mov	 esp, ebp
  001b1	5d		 pop	 ebp
  001b2	c3		 ret	 0
  001b3	90		 npad	 1
$LN13@cbSaveMyDa:
  001b4	01 00 00 00	 DD	 1
  001b8	00 00 00 00	 DD	 $LN12@cbSaveMyDa
$LN12@cbSaveMyDa:
  001bc	e0 ff ff ff	 DD	 -32			; ffffffe0H
  001c0	04 00 00 00	 DD	 4
  001c4	00 00 00 00	 DD	 $LN11@cbSaveMyDa
$LN11@cbSaveMyDa:
  001c8	54		 DB	 84			; 00000054H
  001c9	6f		 DB	 111			; 0000006fH
  001ca	74		 DB	 116			; 00000074H
  001cb	4e		 DB	 78			; 0000004eH
  001cc	57		 DB	 87			; 00000057H
  001cd	6f		 DB	 111			; 0000006fH
  001ce	72		 DB	 114			; 00000072H
  001cf	64		 DB	 100			; 00000064H
  001d0	73		 DB	 115			; 00000073H
  001d1	00		 DB	 0
?cbSaveMyData@@YAKPAPAEH@Z ENDP				; cbSaveMyData
_TEXT	ENDS
PUBLIC	?cbLoadMyData@@YAXPAEK@Z			; cbLoadMyData
EXTRN	_memcpy:PROC
EXTRN	?ParseNgField@@YA_NPAGKPAUStrParseNGField@@@Z:PROC ; ParseNgField
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbLoadMyData@@YAXPAEK@Z
_TEXT	SEGMENT
tv71 = -272						; size = 4
_TotActions$ = -72					; size = 2
_i$ = -60						; size = 4
_Indice$ = -48						; size = 4
_ParseField$ = -36					; size = 18
_pVetExtras$ = -8					; size = 4
_pAdrZone$ = 8						; size = 4
_SizeData$ = 12						; size = 4
?cbLoadMyData@@YAXPAEK@Z PROC				; cbLoadMyData, COMDAT

; 272  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 01 00
	00		 sub	 esp, 272		; 00000110H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00012	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 273  : 
; 274  : 	WORD *pVetExtras;
; 275  : 	StrParseNGField  ParseField;
; 276  : 	int Indice;
; 277  : 	int i;
; 278  : 	WORD TotActions;
; 279  : 
; 280  : 	
; 281  : 	pVetExtras = (WORD*) pAdrZone;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pAdrZone$[ebp]
  00021	89 45 f8	 mov	 DWORD PTR _pVetExtras$[ebp], eax

; 282  : 
; 283  : 	Indice=0;

  00024	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _Indice$[ebp], 0
$LN7@cbLoadMyDa:

; 284  : 
; 285  : 	while (ParseNgField(pVetExtras ,Indice, &ParseField)==true) {

  0002b	8d 45 dc	 lea	 eax, DWORD PTR _ParseField$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d d0	 mov	 ecx, DWORD PTR _Indice$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 f8	 mov	 edx, DWORD PTR _pVetExtras$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?ParseNgField@@YA_NPAGKPAUStrParseNGField@@@Z ; ParseNgField
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003f	0f b6 c0	 movzx	 eax, al
  00042	83 f8 01	 cmp	 eax, 1
  00045	0f 85 a1 00 00
	00		 jne	 $LN8@cbLoadMyDa

; 286  : 		
; 287  : 		// recover different ng token
; 288  : 		switch (ParseField.Type) {

  0004b	0f b7 45 ec	 movzx	 eax, WORD PTR _ParseField$[ebp+16]
  0004f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00055	83 bd f0 fe ff
	ff 01		 cmp	 DWORD PTR tv71[ebp], 1
  0005c	74 3e		 je	 SHORT $LN1@cbLoadMyDa
  0005e	83 bd f0 fe ff
	ff 02		 cmp	 DWORD PTR tv71[ebp], 2
  00065	74 0b		 je	 SHORT $LN3@cbLoadMyDa
  00067	83 bd f0 fe ff
	ff 03		 cmp	 DWORD PTR tv71[ebp], 3
  0006e	74 17		 je	 SHORT $LN2@cbLoadMyDa
  00070	eb 6f		 jmp	 SHORT $LN4@cbLoadMyDa
$LN3@cbLoadMyDa:

; 289  : 		case NGTAG_LOCAL_DATA:
; 290  : 			// local data
; 291  : 			memcpy(&MyData.Save.Local, ParseField.pData, sizeof(StrSavegameLocalData));

  00072	6a 01		 push	 1
  00074	8b 45 e0	 mov	 eax, DWORD PTR _ParseField$[ebp+4]
  00077	50		 push	 eax
  00078	68 01 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+1
  0007d	e8 00 00 00 00	 call	 _memcpy
  00082	83 c4 0c	 add	 esp, 12			; 0000000cH

; 292  : 			break;

  00085	eb 5a		 jmp	 SHORT $LN4@cbLoadMyDa
$LN2@cbLoadMyDa:

; 293  : 
; 294  : 		case NGTAG_GLOBAL_DATA:
; 295  : 			// global data
; 296  : 			memcpy(&MyData.Save.Global, ParseField.pData, sizeof(StrSavegameGlobalData));

  00087	6a 01		 push	 1
  00089	8b 45 e0	 mov	 eax, DWORD PTR _ParseField$[ebp+4]
  0008c	50		 push	 eax
  0008d	68 00 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A ; MyData
  00092	e8 00 00 00 00	 call	 _memcpy
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 297  : 			break;

  0009a	eb 45		 jmp	 SHORT $LN4@cbLoadMyDa
$LN1@cbLoadMyDa:

; 298  : 			
; 299  : 		case NGTAG_PROGRESSIVE_ACTIONS:
; 300  : 			// progressive actions
; 301  : 			i= ParseField.StartDataIndex;

  0009c	8b 45 e8	 mov	 eax, DWORD PTR _ParseField$[ebp+12]
  0009f	89 45 c4	 mov	 DWORD PTR _i$[ebp], eax

; 302  : 			// read tot actions value
; 303  : 			TotActions = pVetExtras[i++];

  000a2	8b 45 c4	 mov	 eax, DWORD PTR _i$[ebp]
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _pVetExtras$[ebp]
  000a8	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  000ac	66 89 55 b8	 mov	 WORD PTR _TotActions$[ebp], dx
  000b0	8b 45 c4	 mov	 eax, DWORD PTR _i$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 c4	 mov	 DWORD PTR _i$[ebp], eax

; 304  : 			// copy all tot records
; 305  : 			memcpy(&MyData.VetProgrActions[0], &pVetExtras[i], sizeof(StrProgressiveAction) * TotActions);

  000b9	0f b7 45 b8	 movzx	 eax, WORD PTR _TotActions$[ebp]
  000bd	c1 e0 05	 shl	 eax, 5
  000c0	50		 push	 eax
  000c1	8b 4d c4	 mov	 ecx, DWORD PTR _i$[ebp]
  000c4	8b 55 f8	 mov	 edx, DWORD PTR _pVetExtras$[ebp]
  000c7	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  000ca	50		 push	 eax
  000cb	68 0a 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+10
  000d0	e8 00 00 00 00	 call	 _memcpy
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 306  : 			MyData.TotProgrActions = TotActions;

  000d8	0f b7 45 b8	 movzx	 eax, WORD PTR _TotActions$[ebp]
  000dc	a3 02 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+2, eax
$LN4@cbLoadMyDa:

; 307  : 			break;
; 308  : 		}
; 309  : 		Indice= ParseField.NextIndex; 

  000e1	8b 45 dc	 mov	 eax, DWORD PTR _ParseField$[ebp]
  000e4	89 45 d0	 mov	 DWORD PTR _Indice$[ebp], eax

; 310  : 	}

  000e7	e9 3f ff ff ff	 jmp	 $LN7@cbLoadMyDa
$LN8@cbLoadMyDa:

; 311  : 
; 312  : }

  000ec	52		 push	 edx
  000ed	8b cd		 mov	 ecx, ebp
  000ef	50		 push	 eax
  000f0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@cbLoadMyDa
  000f6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fb	58		 pop	 eax
  000fc	5a		 pop	 edx
  000fd	5f		 pop	 edi
  000fe	5e		 pop	 esi
  000ff	5b		 pop	 ebx
  00100	81 c4 10 01 00
	00		 add	 esp, 272		; 00000110H
  00106	3b ec		 cmp	 ebp, esp
  00108	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
  00111	8d 49 00	 npad	 3
$LN12@cbLoadMyDa:
  00114	01 00 00 00	 DD	 1
  00118	00 00 00 00	 DD	 $LN11@cbLoadMyDa
$LN11@cbLoadMyDa:
  0011c	dc ff ff ff	 DD	 -36			; ffffffdcH
  00120	12 00 00 00	 DD	 18			; 00000012H
  00124	00 00 00 00	 DD	 $LN10@cbLoadMyDa
$LN10@cbLoadMyDa:
  00128	50		 DB	 80			; 00000050H
  00129	61		 DB	 97			; 00000061H
  0012a	72		 DB	 114			; 00000072H
  0012b	73		 DB	 115			; 00000073H
  0012c	65		 DB	 101			; 00000065H
  0012d	46		 DB	 70			; 00000046H
  0012e	69		 DB	 105			; 00000069H
  0012f	65		 DB	 101			; 00000065H
  00130	6c		 DB	 108			; 0000006cH
  00131	64		 DB	 100			; 00000064H
  00132	00		 DB	 0
?cbLoadMyData@@YAXPAEK@Z ENDP				; cbLoadMyData
_TEXT	ENDS
PUBLIC	?FreeMemoryCustomize@@YAXXZ			; FreeMemoryCustomize
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeMemoryCustomize@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?FreeMemoryCustomize@@YAXXZ PROC			; FreeMemoryCustomize, COMDAT

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 316  : 	int i;
; 317  : 
; 318  : 	for (i=0;i<MyData.BaseCustomizeMine.TotCustomize;i++) {

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@FreeMemory
$LN3@FreeMemory:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FreeMemory:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 05 8a 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3210
  00039	7d 18		 jge	 SHORT $LN2@FreeMemory

; 319  : 		FreeMemory(MyData.BaseCustomizeMine.pVetCustomize[i].pVetArg);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	8b 0d 8e 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3214
  00044	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?FreeMemory@@YAXPAX@Z	; FreeMemory
  0004e	83 c4 04	 add	 esp, 4

; 320  : 	}

  00051	eb d4		 jmp	 SHORT $LN3@FreeMemory
$LN2@FreeMemory:

; 321  : 
; 322  : 	if (MyData.BaseCustomizeMine.TotCustomize > 0) {

  00053	83 3d 8a 0c 00
	00 00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+3210, 0
  0005a	7e 18		 jle	 SHORT $LN1@FreeMemory

; 323  : 		FreeMemory(MyData.BaseCustomizeMine.pVetCustomize);

  0005c	a1 8e 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3214
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?FreeMemory@@YAXPAX@Z	; FreeMemory
  00067	83 c4 04	 add	 esp, 4

; 324  : 		MyData.BaseCustomizeMine.TotCustomize=0;

  0006a	c7 05 8a 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3210, 0
$LN1@FreeMemory:

; 325  : 	}
; 326  : 
; 327  : 
; 328  : 	MyData.BaseCustomizeMine.pVetCustomize=NULL;

  00074	c7 05 8e 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3214, 0

; 329  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?FreeMemoryCustomize@@YAXXZ ENDP			; FreeMemoryCustomize
_TEXT	ENDS
PUBLIC	?FreeMemoryParameters@@YAXXZ			; FreeMemoryParameters
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeMemoryParameters@@YAXXZ
_TEXT	SEGMENT
_i$ = -8						; size = 4
?FreeMemoryParameters@@YAXXZ PROC			; FreeMemoryParameters, COMDAT

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 334  : 	int i;
; 335  : 
; 336  : 	for (i=0;i<MyData.BaseParametersMine.TotParameters;i++) {

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@FreeMemory@2
$LN3@FreeMemory@2:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@FreeMemory@2:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00033	3b 05 92 0c 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3218
  00039	7d 18		 jge	 SHORT $LN2@FreeMemory@2

; 337  : 		FreeMemory(MyData.BaseParametersMine.pVetParameters[i].pVetArg);

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003e	8b 0d 96 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3222
  00044	8b 54 c1 04	 mov	 edx, DWORD PTR [ecx+eax*8+4]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ?FreeMemory@@YAXPAX@Z	; FreeMemory
  0004e	83 c4 04	 add	 esp, 4

; 338  : 	}

  00051	eb d4		 jmp	 SHORT $LN3@FreeMemory@2
$LN2@FreeMemory@2:

; 339  : 
; 340  : 	if (MyData.BaseParametersMine.TotParameters > 0) {

  00053	83 3d 92 0c 00
	00 00		 cmp	 DWORD PTR ?MyData@@3UStrMyData@@A+3218, 0
  0005a	7e 18		 jle	 SHORT $LN1@FreeMemory@2

; 341  : 		FreeMemory(MyData.BaseParametersMine.pVetParameters);

  0005c	a1 96 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3222
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ?FreeMemory@@YAXPAX@Z	; FreeMemory
  00067	83 c4 04	 add	 esp, 4

; 342  : 		MyData.BaseParametersMine.TotParameters=0;

  0006a	c7 05 92 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3218, 0
$LN1@FreeMemory@2:

; 343  : 	}
; 344  : 
; 345  : 	MyData.BaseParametersMine.pVetParameters=NULL;

  00074	c7 05 96 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3222, 0

; 346  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?FreeMemoryParameters@@YAXXZ ENDP			; FreeMemoryParameters
_TEXT	ENDS
PUBLIC	?FreeLevelResources@@YAXXZ			; FreeLevelResources
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?FreeLevelResources@@YAXXZ
_TEXT	SEGMENT
?FreeLevelResources@@YAXXZ PROC				; FreeLevelResources, COMDAT

; 351  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 352  : 
; 353  : 	// free memory used to store all data about your customize commands loaded in previous level
; 354  : 	FreeMemoryCustomize();

  0001e	e8 00 00 00 00	 call	 ?FreeMemoryCustomize@@YAXXZ ; FreeMemoryCustomize

; 355  : 	// free memory used to store all data about your parameters commands loaded in previous level
; 356  : 	FreeMemoryParameters();

  00023	e8 00 00 00 00	 call	 ?FreeMemoryParameters@@YAXXZ ; FreeMemoryParameters

; 357  : 	MyData.BaseAssignSlotMine.TotAssign=0;

  00028	c7 05 9a 0c 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3226, 0

; 358  : 
; 359  : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?FreeLevelResources@@YAXXZ ENDP				; FreeLevelResources
_TEXT	ENDS
PUBLIC	?cbInitLoadNewLevel@@YAXXZ			; cbInitLoadNewLevel
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbInitLoadNewLevel@@YAXXZ
_TEXT	SEGMENT
_pAction$ = -20						; size = 4
_i$ = -8						; size = 4
?cbInitLoadNewLevel@@YAXXZ PROC				; cbInitLoadNewLevel, COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 366  : 	int i;
; 367  : 
; 368  : 	StrProgressiveAction *pAction;
; 369  : 
; 370  : 	// clear all LOCAL variables
; 371  : 	ClearMemory(&MyData.Save.Local,sizeof(StrSavegameLocalData));

  0001e	6a 01		 push	 1
  00020	68 01 00 00 00	 push	 OFFSET ?MyData@@3UStrMyData@@A+1
  00025	e8 00 00 00 00	 call	 ?ClearMemory@@YAXPAXK@Z	; ClearMemory
  0002a	83 c4 08	 add	 esp, 8

; 372  : 
; 373  : 	// clear progressive actions
; 374  : 	pAction= &MyData.VetProgrActions[0];

  0002d	c7 45 ec 0a 00
	00 00		 mov	 DWORD PTR _pAction$[ebp], OFFSET ?MyData@@3UStrMyData@@A+10

; 375  : 
; 376  : 	for (i=0;i<MyData.TotProgrActions;i++) {

  00034	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003b	eb 09		 jmp	 SHORT $LN4@cbInitLoad
$LN3@cbInitLoad:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cbInitLoad:
  00046	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00049	3b 05 02 00 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  0004f	7d 14		 jge	 SHORT $LN2@cbInitLoad

; 377  : 		if (pAction->ActionType != AXN_FREE) {

  00051	8b 45 ec	 mov	 eax, DWORD PTR _pAction$[ebp]
  00054	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00057	85 c9		 test	 ecx, ecx
  00059	74 08		 je	 SHORT $LN1@cbInitLoad

; 378  : 			// here you could analise to free resoruce allocated from this specific action
; 379  : 
; 380  : 			pAction->ActionType = AXN_FREE;

  0005b	33 c0		 xor	 eax, eax
  0005d	8b 4d ec	 mov	 ecx, DWORD PTR _pAction$[ebp]
  00060	66 89 01	 mov	 WORD PTR [ecx], ax
$LN1@cbInitLoad:

; 381  : 		}
; 382  : 	}

  00063	eb d8		 jmp	 SHORT $LN3@cbInitLoad
$LN2@cbInitLoad:

; 383  : 
; 384  : 	MyData.TotProgrActions=0;

  00065	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+2, 0

; 385  : 	MyData.LastProgrActionIndex=0;

  0006f	c7 05 06 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+6, 0

; 386  : 
; 387  : 	// here you can initialise other variables of MyData different than Local and progressive actions
; 388  : 	// free resources allocate in previous level
; 389  : 	FreeLevelResources();

  00079	e8 00 00 00 00	 call	 ?FreeLevelResources@@YAXXZ ; FreeLevelResources

; 390  : 
; 391  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?cbInitLoadNewLevel@@YAXXZ ENDP				; cbInitLoadNewLevel
_TEXT	ENDS
PUBLIC	??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@ ; `string'
PUBLIC	?cbFlipEffectMine@@YAHGGGG@Z			; cbFlipEffectMine
EXTRN	?enumSCANF@@3UStrEnumSCANF@@A:BYTE		; enumSCANF
EXTRN	?SendToLog@@YA_NPADZZ:PROC			; SendToLog
EXTRN	?enumTRET@@3UStrEnumTRET@@A:BYTE		; enumTRET
;	COMDAT ??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@
CONST	SEGMENT
??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@ DB 'WARNING: Fli'
	DB	'peffect trigger number %d has not been handled in cbFlipEffec'
	DB	'tMine() function', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?cbFlipEffectMine@@YAHGGGG@Z
_TEXT	SEGMENT
tv70 = -220						; size = 4
_TimerFull$ = -20					; size = 2
_RetValue$ = -8						; size = 4
_FlipIndex$ = 8						; size = 2
_Timer$ = 12						; size = 2
_Extra$ = 16						; size = 2
_ActivationMode$ = 20					; size = 2
?cbFlipEffectMine@@YAHGGGG@Z PROC			; cbFlipEffectMine, COMDAT

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00012	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 399  : 	int RetValue;
; 400  : 	WORD TimerFull;
; 401  : 
; 402  : 	RetValue = enumTRET.PERFORM_ONCE_AND_GO;

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+4
  00023	89 45 f8	 mov	 DWORD PTR _RetValue$[ebp], eax

; 403  : 	// if the flip has no Extra paremeter you can handle a Timer value with values upto 32767
; 404  : 	// in this case you'll use the following TimerFull variable, where (with following code) we set a unique big number 
; 405  : 	// pasting togheter the timer+extra arguments:
; 406  : 	TimerFull = Timer | (Extra << 8);

  00026	0f b7 45 0c	 movzx	 eax, WORD PTR _Timer$[ebp]
  0002a	0f b7 4d 10	 movzx	 ecx, WORD PTR _Extra$[ebp]
  0002e	c1 e1 08	 shl	 ecx, 8
  00031	0b c1		 or	 eax, ecx
  00033	66 89 45 ec	 mov	 WORD PTR _TimerFull$[ebp], ax

; 407  : 
; 408  : 	switch (FlipIndex) {

  00037	0f b7 45 08	 movzx	 eax, WORD PTR _FlipIndex$[ebp]
  0003b	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  00041	83 bd 24 ff ff
	ff ff		 cmp	 DWORD PTR tv70[ebp], -1
  00048	74 02		 je	 SHORT $LN3@cbFlipEffe
  0004a	eb 02		 jmp	 SHORT $LN2@cbFlipEffe
$LN3@cbFlipEffe:

; 409  : 		// here type the "case Number:" for each flipeffect number. At end of the code you'll use the "break;" instruction to signal the code ending
; 410  : 		// Note: when you'll add your first "case Number:" then you can remove the following "case -1: and break;" instructions
; 411  : 	case -1: 
; 412  : 		break;

  0004c	eb 12		 jmp	 SHORT $LN4@cbFlipEffe
$LN2@cbFlipEffe:

; 413  : 	default:
; 414  : 		SendToLog("WARNING: Flipeffect trigger number %d has not been handled in cbFlipEffectMine() function", FlipIndex);

  0004e	0f b7 45 08	 movzx	 eax, WORD PTR _FlipIndex$[ebp]
  00052	50		 push	 eax
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@EILPCEPB@WARNING?3?5Flipeffect?5trigger?5numb@
  00058	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0005d	83 c4 08	 add	 esp, 8
$LN4@cbFlipEffe:

; 415  : 		break;
; 416  : 	}
; 417  : 
; 418  : 	// if there was the one-shot button enabled, return TRET_PERFORM_NEVER_MORE
; 419  : 	if (ActivationMode & enumSCANF.BUTTON_ONE_SHOT) RetValue= enumTRET.PERFORM_NEVER_MORE; 

  00060	0f b7 45 14	 movzx	 eax, WORD PTR _ActivationMode$[ebp]
  00064	23 05 08 00 00
	00		 and	 eax, DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+8
  0006a	74 08		 je	 SHORT $LN1@cbFlipEffe
  0006c	a1 08 00 00 00	 mov	 eax, DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+8
  00071	89 45 f8	 mov	 DWORD PTR _RetValue$[ebp], eax
$LN1@cbFlipEffe:

; 420  : 	return RetValue;

  00074	8b 45 f8	 mov	 eax, DWORD PTR _RetValue$[ebp]

; 421  : }

  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00080	3b ec		 cmp	 ebp, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
?cbFlipEffectMine@@YAHGGGG@Z ENDP			; cbFlipEffectMine
_TEXT	ENDS
PUBLIC	??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@ ; `string'
PUBLIC	?cbActionMine@@YAHGHGG@Z			; cbActionMine
;	COMDAT ??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@
CONST	SEGMENT
??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@ DB 'WARNING:'
	DB	' action trigger number %d has not been handled in cbActionMin'
	DB	'e() function', 00H				; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?cbActionMine@@YAHGHGG@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_RetValue$ = -8						; size = 4
_ActionIndex$ = 8					; size = 2
_ItemIndex$ = 12					; size = 4
_Extra$ = 16						; size = 2
_ActivationMode$ = 20					; size = 2
?cbActionMine@@YAHGHGG@Z PROC				; cbActionMine, COMDAT

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 426  : 	int RetValue;
; 427  : 	
; 428  : 	RetValue=TRET_PERFORM_ONCE_AND_GO;

  0001e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _RetValue$[ebp], 1

; 429  : 
; 430  : 	switch (ActionIndex) {

  00025	0f b7 45 08	 movzx	 eax, WORD PTR _ActionIndex$[ebp]
  00029	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0002f	83 bd 30 ff ff
	ff ff		 cmp	 DWORD PTR tv65[ebp], -1
  00036	74 02		 je	 SHORT $LN3@cbActionMi
  00038	eb 02		 jmp	 SHORT $LN2@cbActionMi
$LN3@cbActionMi:

; 431  : 		// type here the code per your action trigger.
; 432  : 		// add "case Number:" and complete the code with "break;" instruction
; 433  : 	case -1:
; 434  : 		// note: remove this "case -1:" and its "break;" it has been added only to avoid warning messages about empty switch
; 435  : 		break;

  0003a	eb 12		 jmp	 SHORT $LN4@cbActionMi
$LN2@cbActionMi:

; 436  : 	default:
; 437  : 		SendToLog("WARNING: action trigger number %d has not been handled in cbActionMine() function", ActionIndex);

  0003c	0f b7 45 08	 movzx	 eax, WORD PTR _ActionIndex$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@EJBFAEPG@WARNING?3?5action?5trigger?5number?5?$CF@
  00046	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0004b	83 c4 08	 add	 esp, 8
$LN4@cbActionMi:

; 438  : 		break;
; 439  : 	}
; 440  : 	
; 441  : 	// if there was the one-shot button enabled, return TRET_PERFORM_NEVER_MORE
; 442  : 	if (ActivationMode & enumSCANF.BUTTON_ONE_SHOT) RetValue= enumTRET.PERFORM_NEVER_MORE;

  0004e	0f b7 45 14	 movzx	 eax, WORD PTR _ActivationMode$[ebp]
  00052	23 05 08 00 00
	00		 and	 eax, DWORD PTR ?enumSCANF@@3UStrEnumSCANF@@A+8
  00058	74 08		 je	 SHORT $LN1@cbActionMi
  0005a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?enumTRET@@3UStrEnumTRET@@A+8
  0005f	89 45 f8	 mov	 DWORD PTR _RetValue$[ebp], eax
$LN1@cbActionMi:

; 443  : 	return RetValue;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _RetValue$[ebp]

; 444  : 
; 445  : 
; 446  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
?cbActionMine@@YAHGHGG@Z ENDP				; cbActionMine
_TEXT	ENDS
PUBLIC	??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@ ; `string'
PUBLIC	?cbConditionMine@@YAHGHGG@Z			; cbConditionMine
;	COMDAT ??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@
CONST	SEGMENT
??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@ DB 'WARNING: con'
	DB	'dition trigger number %d has not been handled in cbConditionM'
	DB	'ine() function', 00H			; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?cbConditionMine@@YAHGHGG@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
_RetValue$ = -8						; size = 4
_ConditionIndex$ = 8					; size = 2
_ItemIndex$ = 12					; size = 4
_Extra$ = 16						; size = 2
_ActivationMode$ = 20					; size = 2
?cbConditionMine@@YAHGHGG@Z PROC			; cbConditionMine, COMDAT

; 451  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 452  : 	int RetValue;
; 453  : 	
; 454  : 	RetValue=CTRET_ONLY_ONCE_ON_TRUE;

  0001e	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR _RetValue$[ebp], 16 ; 00000010H

; 455  : 
; 456  : 	switch (ConditionIndex){

  00025	0f b7 45 08	 movzx	 eax, WORD PTR _ConditionIndex$[ebp]
  00029	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0002f	83 bd 30 ff ff
	ff ff		 cmp	 DWORD PTR tv65[ebp], -1
  00036	74 02		 je	 SHORT $LN2@cbConditio
  00038	eb 02		 jmp	 SHORT $LN1@cbConditio
$LN2@cbConditio:

; 457  : 		// type here the code for your condition trigger, inserting the code in the section
; 458  : 		// beginning with "case NumberOfAction:" and ending with row "break;"
; 459  : 	case -1:
; 460  : 		// note: remove this "case -1:" and its "break;" it has been added only to avoid warning messages about empty switch
; 461  : 		break;

  0003a	eb 12		 jmp	 SHORT $LN3@cbConditio
$LN1@cbConditio:

; 462  : 	default:
; 463  : 		SendToLog("WARNING: condition trigger number %d has not been handled in cbConditionMine() function", ConditionIndex);

  0003c	0f b7 45 08	 movzx	 eax, WORD PTR _ConditionIndex$[ebp]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0FI@MMJMIBOA@WARNING?3?5condition?5trigger?5numbe@
  00046	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  0004b	83 c4 08	 add	 esp, 8
$LN3@cbConditio:

; 464  : 		break;
; 465  : 
; 466  : 
; 467  : 	}
; 468  : 	return RetValue;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _RetValue$[ebp]

; 469  : 	  
; 470  : }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?cbConditionMine@@YAHGHGG@Z ENDP			; cbConditionMine
_TEXT	ENDS
PUBLIC	?cbCustomizeMine@@YAXGHPAF@Z			; cbCustomizeMine
EXTRN	?ResizeMemory@@YAPAXPAXK@Z:PROC			; ResizeMemory
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbCustomizeMine@@YAXGHPAF@Z
_TEXT	SEGMENT
_TotCust$ = -32						; size = 4
_pMyCust$ = -20						; size = 4
_SizeMem$ = -8						; size = 4
_CustomizeValue$ = 8					; size = 2
_NumberOfItems$ = 12					; size = 4
_pItemArray$ = 16					; size = 4
?cbCustomizeMine@@YAXGHPAF@Z PROC			; cbCustomizeMine, COMDAT

; 479  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 480  : 	// here you can replace this default management of anonymous customize commands
; 481  : 	// with your procedure where you can recognize each different CUST_ value and 
; 482  : 	// save its arguments in meaningful names fields, or elaboriting them immediatly
; 483  : 	// when it is possible (warning: in this moment nothing of level it has been yet loaded, excepting the script section)
; 484  : 
; 485  : 	// ----- default management (optional)----
; 486  : 	// all customize values will be saved in MyData structure
; 487  : 	DWORD SizeMem;
; 488  : 	StrGenericCustomize *pMyCust;
; 489  : 	int TotCust;
; 490  : 
; 491  : 	// ask memory to have another (new) record of StrGenericCustomize structure
; 492  : 	TotCust= MyData.BaseCustomizeMine.TotCustomize;

  0001e	a1 8a 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3210
  00023	89 45 e0	 mov	 DWORD PTR _TotCust$[ebp], eax

; 493  : 	TotCust++;

  00026	8b 45 e0	 mov	 eax, DWORD PTR _TotCust$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 e0	 mov	 DWORD PTR _TotCust$[ebp], eax

; 494  : 	SizeMem = TotCust * sizeof(StrGenericCustomize);

  0002f	8b 45 e0	 mov	 eax, DWORD PTR _TotCust$[ebp]
  00032	c1 e0 03	 shl	 eax, 3
  00035	89 45 f8	 mov	 DWORD PTR _SizeMem$[ebp], eax

; 495  : 	MyData.BaseCustomizeMine.pVetCustomize = 
; 496  : 				(StrGenericCustomize *) ResizeMemory(MyData.BaseCustomizeMine.pVetCustomize, SizeMem);

  00038	8b 45 f8	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  0003b	50		 push	 eax
  0003c	8b 0d 8e 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3214
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?ResizeMemory@@YAPAXPAXK@Z ; ResizeMemory
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 8e 0c 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3214, eax

; 497  : 
; 498  : 	pMyCust = & MyData.BaseCustomizeMine.pVetCustomize[TotCust-1];

  00050	8b 45 e0	 mov	 eax, DWORD PTR _TotCust$[ebp]
  00053	8b 0d 8e 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3214
  00059	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  0005d	89 55 ec	 mov	 DWORD PTR _pMyCust$[ebp], edx

; 499  : 	
; 500  : 	// now require memory for all arguments (NumberOfItems) store in pItemArray
; 501  : 
; 502  : 	pMyCust->pVetArg = (short *) GetMemory(2 * NumberOfItems);

  00060	8b 45 0c	 mov	 eax, DWORD PTR _NumberOfItems$[ebp]
  00063	d1 e0		 shl	 eax, 1
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR _pMyCust$[ebp]
  00071	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 503  : 	// copy data
; 504  : 	pMyCust->NArguments = NumberOfItems;

  00074	8b 45 ec	 mov	 eax, DWORD PTR _pMyCust$[ebp]
  00077	66 8b 4d 0c	 mov	 cx, WORD PTR _NumberOfItems$[ebp]
  0007b	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 505  : 	memcpy(pMyCust->pVetArg, pItemArray, 2*NumberOfItems);

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _NumberOfItems$[ebp]
  00082	d1 e0		 shl	 eax, 1
  00084	50		 push	 eax
  00085	8b 4d 10	 mov	 ecx, DWORD PTR _pItemArray$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 ec	 mov	 edx, DWORD PTR _pMyCust$[ebp]
  0008c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _memcpy
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 506  : 	pMyCust->CustValue = CustomizeValue;

  00098	8b 45 ec	 mov	 eax, DWORD PTR _pMyCust$[ebp]
  0009b	66 8b 4d 08	 mov	 cx, WORD PTR _CustomizeValue$[ebp]
  0009f	66 89 08	 mov	 WORD PTR [eax], cx

; 507  : 
; 508  : 	MyData.BaseCustomizeMine.TotCustomize= TotCust;

  000a2	8b 45 e0	 mov	 eax, DWORD PTR _TotCust$[ebp]
  000a5	a3 8a 0c 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3210, eax

; 509  : 	// ---- end of default managemnt for generic customize -------------	
; 510  : }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?cbCustomizeMine@@YAXGHPAF@Z ENDP			; cbCustomizeMine
_TEXT	ENDS
PUBLIC	??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@ ; `string'
PUBLIC	?cbAssignSlotMine@@YAXGG@Z			; cbAssignSlotMine
;	COMDAT ??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@
CONST	SEGMENT
??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@ DB 'ERROR: t'
	DB	'oo many AssignSlot= commands for current plugin', 00H ; `string'
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?cbAssignSlotMine@@YAXGG@Z
_TEXT	SEGMENT
_i$ = -8						; size = 4
_Slot$ = 8						; size = 2
_ObjType$ = 12						; size = 2
?cbAssignSlotMine@@YAXGG@Z PROC				; cbAssignSlotMine, COMDAT

; 514  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 515  : 	int i;
; 516  : 
; 517  : 	i = MyData.BaseAssignSlotMine.TotAssign;

  0001e	a1 9a 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3226
  00023	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 518  : 
; 519  : 	if (i >= MAX_ASSIGN_SLOT_MINE) {

  00026	81 7d f8 c8 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 200	; 000000c8H
  0002d	7c 0f		 jl	 SHORT $LN1@cbAssignSl

; 520  : 		SendToLog("ERROR: too many AssignSlot= commands for current plugin");

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@KFLAGLEP@ERROR?3?5too?5many?5AssignSlot?$DN?5comm@
  00034	e8 00 00 00 00	 call	 ?SendToLog@@YA_NPADZZ	; SendToLog
  00039	83 c4 04	 add	 esp, 4

; 521  : 		return;

  0003c	eb 2b		 jmp	 SHORT $LN2@cbAssignSl
$LN1@cbAssignSl:

; 522  : 	}
; 523  : 
; 524  : 	MyData.BaseAssignSlotMine.VetAssignSlot[i].MioSlot = Slot;

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00041	66 8b 4d 08	 mov	 cx, WORD PTR _Slot$[ebp]
  00045	66 89 0c 85 9e
	0c 00 00	 mov	 WORD PTR ?MyData@@3UStrMyData@@A[eax*4+3230], cx

; 525  : 	MyData.BaseAssignSlotMine.VetAssignSlot[i].TipoSlot = ObjType;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00050	66 8b 4d 0c	 mov	 cx, WORD PTR _ObjType$[ebp]
  00054	66 89 0c 85 a0
	0c 00 00	 mov	 WORD PTR ?MyData@@3UStrMyData@@A[eax*4+3232], cx

; 526  : 	MyData.BaseAssignSlotMine.TotAssign++;

  0005c	a1 9a 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3226
  00061	83 c0 01	 add	 eax, 1
  00064	a3 9a 0c 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3226, eax
$LN2@cbAssignSl:

; 527  : 
; 528  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00072	3b ec		 cmp	 ebp, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
?cbAssignSlotMine@@YAXGG@Z ENDP				; cbAssignSlotMine
_TEXT	ENDS
PUBLIC	?cbParametersMine@@YAXGHPAF@Z			; cbParametersMine
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbParametersMine@@YAXGHPAF@Z
_TEXT	SEGMENT
_TotParam$ = -32					; size = 4
_pMyParam$ = -20					; size = 4
_SizeMem$ = -8						; size = 4
_ParameterValue$ = 8					; size = 2
_NumberOfItems$ = 12					; size = 4
_pItemArray$ = 16					; size = 4
?cbParametersMine@@YAXGHPAF@Z PROC			; cbParametersMine, COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 1c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-228]
  00012	b9 39 00 00 00	 mov	 ecx, 57			; 00000039H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 537  : 	// here you can replace this default management of anonymous parameters commands
; 538  : 	// with your procedure where you can recognize each different Param_ value and 
; 539  : 	// save its arguments in meaningful names fields, or elaboriting them immediatly
; 540  : 	// when it is possible (warning: in this moment nothing of level it has been yet loaded, excepting the script section)
; 541  : 
; 542  : 	// ----- default management (optional)----
; 543  : 	// all parameters values will be saved in MyData structure
; 544  : 	DWORD SizeMem;
; 545  : 	StrGenericParameters *pMyParam;
; 546  : 	int TotParam;
; 547  : 
; 548  : 	// ask memory to have another (new) record of StrGenericparameters structure
; 549  : 	TotParam= MyData.BaseParametersMine.TotParameters;

  0001e	a1 92 0c 00 00	 mov	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+3218
  00023	89 45 e0	 mov	 DWORD PTR _TotParam$[ebp], eax

; 550  : 	TotParam++;

  00026	8b 45 e0	 mov	 eax, DWORD PTR _TotParam$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 e0	 mov	 DWORD PTR _TotParam$[ebp], eax

; 551  : 	SizeMem = TotParam * sizeof(StrGenericParameters);

  0002f	8b 45 e0	 mov	 eax, DWORD PTR _TotParam$[ebp]
  00032	c1 e0 03	 shl	 eax, 3
  00035	89 45 f8	 mov	 DWORD PTR _SizeMem$[ebp], eax

; 552  : 	MyData.BaseParametersMine.pVetParameters = 
; 553  : 		(StrGenericParameters *) ResizeMemory(MyData.BaseParametersMine.pVetParameters, SizeMem);

  00038	8b 45 f8	 mov	 eax, DWORD PTR _SizeMem$[ebp]
  0003b	50		 push	 eax
  0003c	8b 0d 96 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3222
  00042	51		 push	 ecx
  00043	e8 00 00 00 00	 call	 ?ResizeMemory@@YAPAXPAXK@Z ; ResizeMemory
  00048	83 c4 08	 add	 esp, 8
  0004b	a3 96 0c 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3222, eax

; 554  : 
; 555  : 	pMyParam = & MyData.BaseParametersMine.pVetParameters[TotParam-1];

  00050	8b 45 e0	 mov	 eax, DWORD PTR _TotParam$[ebp]
  00053	8b 0d 96 0c 00
	00		 mov	 ecx, DWORD PTR ?MyData@@3UStrMyData@@A+3222
  00059	8d 54 c1 f8	 lea	 edx, DWORD PTR [ecx+eax*8-8]
  0005d	89 55 ec	 mov	 DWORD PTR _pMyParam$[ebp], edx

; 556  : 	
; 557  : 	// now require memory for all arguments (NumberOfItems) store in pItemArray
; 558  : 
; 559  : 	pMyParam->pVetArg = (short *) GetMemory(2 * NumberOfItems);

  00060	8b 45 0c	 mov	 eax, DWORD PTR _NumberOfItems$[ebp]
  00063	d1 e0		 shl	 eax, 1
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ?GetMemory@@YAPAXK@Z	; GetMemory
  0006b	83 c4 04	 add	 esp, 4
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR _pMyParam$[ebp]
  00071	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 560  : 	// copy data
; 561  : 	pMyParam->NArguments = NumberOfItems;

  00074	8b 45 ec	 mov	 eax, DWORD PTR _pMyParam$[ebp]
  00077	66 8b 4d 0c	 mov	 cx, WORD PTR _NumberOfItems$[ebp]
  0007b	66 89 48 02	 mov	 WORD PTR [eax+2], cx

; 562  : 	memcpy(pMyParam->pVetArg, pItemArray, 2*NumberOfItems);

  0007f	8b 45 0c	 mov	 eax, DWORD PTR _NumberOfItems$[ebp]
  00082	d1 e0		 shl	 eax, 1
  00084	50		 push	 eax
  00085	8b 4d 10	 mov	 ecx, DWORD PTR _pItemArray$[ebp]
  00088	51		 push	 ecx
  00089	8b 55 ec	 mov	 edx, DWORD PTR _pMyParam$[ebp]
  0008c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 _memcpy
  00095	83 c4 0c	 add	 esp, 12			; 0000000cH

; 563  : 
; 564  : 	MyData.BaseParametersMine.TotParameters= TotParam;

  00098	8b 45 e0	 mov	 eax, DWORD PTR _TotParam$[ebp]
  0009b	a3 92 0c 00 00	 mov	 DWORD PTR ?MyData@@3UStrMyData@@A+3218, eax

; 565  : 	// ---- end of default managemnt for generic parameters -------------
; 566  : 
; 567  : 
; 568  : }

  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?cbParametersMine@@YAXGHPAF@Z ENDP			; cbParametersMine
_TEXT	ENDS
PUBLIC	?GetItem@@YAXHH_N@Z				; GetItem
EXTRN	?PerformFlipeffect@@YA_NPADHHH@Z:PROC		; PerformFlipeffect
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?GetItem@@YAXHH_N@Z
_TEXT	SEGMENT
_i$45989 = -20						; size = 4
_j$45985 = -8						; size = 4
_Item$ = 8						; size = 4
_Amount$ = 12						; size = 4
_ShowPickup$ = 16					; size = 1
?GetItem@@YAXHH_N@Z PROC				; GetItem, COMDAT

; 571  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 572  : 	for (int j = 0; j < Amount; j++)

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _j$45985[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN7@GetItem
$LN6@GetItem:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _j$45985[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _j$45985[ebp], eax
$LN7@GetItem:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _j$45985[ebp]
  00033	3b 45 0c	 cmp	 eax, DWORD PTR _Amount$[ebp]
  00036	7d 4b		 jge	 SHORT $LN8@GetItem

; 573  : 	{
; 574  : 		for (int i = 0; i <= 128; i++)

  00038	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$45989[ebp], 0
  0003f	eb 09		 jmp	 SHORT $LN4@GetItem
$LN3@GetItem:
  00041	8b 45 ec	 mov	 eax, DWORD PTR _i$45989[ebp]
  00044	83 c0 01	 add	 eax, 1
  00047	89 45 ec	 mov	 DWORD PTR _i$45989[ebp], eax
$LN4@GetItem:
  0004a	81 7d ec 80 00
	00 00		 cmp	 DWORD PTR _i$45989[ebp], 128 ; 00000080H
  00051	7f 2e		 jg	 SHORT $LN2@GetItem

; 575  : 		{
; 576  : 			if (Trng.pGlobTomb4->VetInventory[i] == Item)

  00053	8b 45 ec	 mov	 eax, DWORD PTR _i$45989[ebp]
  00056	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0005c	8b 94 81 bb 03
	1a 00		 mov	 edx, DWORD PTR [ecx+eax*4+1704891]
  00063	3b 55 08	 cmp	 edx, DWORD PTR _Item$[ebp]
  00066	75 17		 jne	 SHORT $LN1@GetItem

; 577  : 			{
; 578  : 				PerformFlipeffect(NULL, 48, i, ShowPickup);

  00068	0f b6 45 10	 movzx	 eax, BYTE PTR _ShowPickup$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _i$45989[ebp]
  00070	51		 push	 ecx
  00071	6a 30		 push	 48			; 00000030H
  00073	6a 00		 push	 0
  00075	e8 00 00 00 00	 call	 ?PerformFlipeffect@@YA_NPADHHH@Z ; PerformFlipeffect
  0007a	83 c4 10	 add	 esp, 16			; 00000010H

; 579  : 				break;

  0007d	eb 02		 jmp	 SHORT $LN2@GetItem
$LN1@GetItem:

; 580  : 			}
; 581  : 		}

  0007f	eb c0		 jmp	 SHORT $LN3@GetItem
$LN2@GetItem:

; 582  : 	}

  00081	eb a4		 jmp	 SHORT $LN6@GetItem
$LN8@GetItem:

; 583  : }

  00083	5f		 pop	 edi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx
  00086	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0008c	3b ec		 cmp	 ebp, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?GetItem@@YAXHH_N@Z ENDP				; GetItem
_TEXT	ENDS
PUBLIC	?StepDownFix@@YAXXZ				; StepDownFix
EXTRN	?ForceAnimationForLara@@YAXHH@Z:PROC		; ForceAnimationForLara
EXTRN	?GET@@3UStrGetLocator@@A:BYTE			; GET
EXTRN	?Get@@YA_NHHH@Z:PROC				; Get
EXTRN	?enumGET@@3UStrEnumGET@@A:BYTE			; enumGET
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?StepDownFix@@YAXXZ
_TEXT	SEGMENT
?StepDownFix@@YAXXZ PROC				; StepDownFix, COMDAT

; 586  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 587  : 	Get(enumGET.LARA, 0, 0);

  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 588  : 	Get(enumGET.ANIMATION, GET.pLara->AnimationNow, 0);

  00030	6a 00		 push	 0
  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00037	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0003b	51		 push	 ecx
  0003c	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 589  : 
; 590  : 	if (GET.pLara->AnimationNow == 40)

  0004b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00050	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00054	83 f9 28	 cmp	 ecx, 40			; 00000028H
  00057	75 44		 jne	 SHORT $LN4@StepDownFi

; 591  : 	{
; 592  : 		if ((GET.pLara->FrameNow - GET.pAnimation->FrameStart >= 30) && (GET.pLara->FrameNow - GET.pAnimation->FrameStart <= 59))

  00059	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  0005e	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00062	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00068	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  0006c	2b c8		 sub	 ecx, eax
  0006e	83 f9 1e	 cmp	 ecx, 30			; 0000001eH
  00071	7c 23		 jl	 SHORT $LN3@StepDownFi
  00073	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00078	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  0007c	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00082	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  00086	2b c8		 sub	 ecx, eax
  00088	83 f9 3b	 cmp	 ecx, 59			; 0000003bH
  0008b	7f 09		 jg	 SHORT $LN3@StepDownFi

; 593  : 		{
; 594  : 			StepRight = true;

  0008d	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?StepRight@@3_NA, 1 ; StepRight

; 595  : 		} else {

  00094	eb 07		 jmp	 SHORT $LN4@StepDownFi
$LN3@StepDownFi:

; 596  : 			StepRight = false;

  00096	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?StepRight@@3_NA, 0 ; StepRight
$LN4@StepDownFi:

; 597  : 		}
; 598  : 	}
; 599  : 
; 600  : 	if (GET.pLara->AnimationNow == 61 && StepRight == true)

  0009d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  000a2	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  000a6	83 f9 3d	 cmp	 ecx, 61			; 0000003dH
  000a9	75 1f		 jne	 SHORT $LN5@StepDownFi
  000ab	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?StepRight@@3_NA ; StepRight
  000b2	83 f8 01	 cmp	 eax, 1
  000b5	75 13		 jne	 SHORT $LN5@StepDownFi

; 601  : 	{
; 602  : 		ForceAnimationForLara(62, 16);

  000b7	6a 10		 push	 16			; 00000010H
  000b9	6a 3e		 push	 62			; 0000003eH
  000bb	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  000c0	83 c4 08	 add	 esp, 8

; 603  : 		StepRight = false;

  000c3	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?StepRight@@3_NA, 0 ; StepRight
$LN5@StepDownFi:

; 604  : 	}
; 605  : }

  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi
  000cc	5b		 pop	 ebx
  000cd	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000d3	3b ec		 cmp	 ebp, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?StepDownFix@@YAXXZ ENDP				; StepDownFix
_TEXT	ENDS
PUBLIC	?BinocularsZoom@@YAXXZ				; BinocularsZoom
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?BinocularsZoom@@YAXXZ
_TEXT	SEGMENT
?BinocularsZoom@@YAXXZ PROC				; BinocularsZoom, COMDAT

; 608  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 609  : 	if (*Trng.pGlobTomb4->pAdr->pTestLaserSight || (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & FL2_IS_USING_LASER_SIGHT_OR_BINOCULARS))

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00029	8b 91 b4 01 00
	00		 mov	 edx, DWORD PTR [ecx+436]
  0002f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00032	85 c0		 test	 eax, eax
  00034	75 19		 jne	 SHORT $LN4@Binoculars
  00036	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0003b	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00041	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  00047	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0004a	83 e0 10	 and	 eax, 16			; 00000010H
  0004d	74 50		 je	 SHORT $LN5@Binoculars
$LN4@Binoculars:

; 610  : 	{
; 611  : 		if (*Trng.pGlobTomb4->pAdr->pZoomFactor != OldZoom)

  0004f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00054	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  0005a	8b 91 b8 01 00
	00		 mov	 edx, DWORD PTR [ecx+440]
  00060	8b 02		 mov	 eax, DWORD PTR [edx]
  00062	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?OldZoom@@3HA ; OldZoom
  00068	74 33		 je	 SHORT $LN3@Binoculars

; 612  : 		{
; 613  : 			SoundEffect(313, NULL, 0);

  0006a	8b f4		 mov	 esi, esp
  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	68 39 01 00 00	 push	 313			; 00000139H
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR ?SoundEffect@@3P6AXHPAXH@ZA ; SoundEffect
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 614  : 			OldZoom = *Trng.pGlobTomb4->pAdr->pZoomFactor;

  00085	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0008a	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00090	8b 91 b8 01 00
	00		 mov	 edx, DWORD PTR [ecx+440]
  00096	8b 02		 mov	 eax, DWORD PTR [edx]
  00098	a3 00 00 00 00	 mov	 DWORD PTR ?OldZoom@@3HA, eax ; OldZoom
$LN3@Binoculars:

; 615  : 		}
; 616  : 	}

  0009d	eb 16		 jmp	 SHORT $LN6@Binoculars
$LN5@Binoculars:

; 617  : 	else if (OldZoom != 128) // Set default value when not used

  0009f	81 3d 00 00 00
	00 80 00 00 00	 cmp	 DWORD PTR ?OldZoom@@3HA, 128 ; OldZoom, 00000080H
  000a9	74 0a		 je	 SHORT $LN6@Binoculars

; 618  : 	{
; 619  : 		OldZoom = 128;

  000ab	c7 05 00 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?OldZoom@@3HA, 128 ; OldZoom, 00000080H
$LN6@Binoculars:

; 620  : 	}
; 621  : }

  000b5	5f		 pop	 edi
  000b6	5e		 pop	 esi
  000b7	5b		 pop	 ebx
  000b8	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
?BinocularsZoom@@YAXXZ ENDP				; BinocularsZoom
_TEXT	ENDS
PUBLIC	__real@4044000000000000
PUBLIC	__real@403e000000000000
PUBLIC	?WideScreen@@YAXXZ				; WideScreen
EXTRN	?enumFL2@@3UStrEnumFL2@@A:BYTE			; enumFL2
EXTRN	?enumCMD@@3UStrEnumCMD@@A:BYTE			; enumCMD
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4044000000000000
CONST	SEGMENT
__real@4044000000000000 DQ 04044000000000000r	; 40
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
; Function compile flags: /Odtp /RTCsu /ZI
CONST	ENDS
;	COMDAT ?WideScreen@@YAXXZ
_TEXT	SEGMENT
_ratio$ = -36						; size = 8
_h$ = -20						; size = 4
_w$ = -8						; size = 4
?WideScreen@@YAXXZ PROC					; WideScreen, COMDAT

; 624  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00012	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 625  : 	int w = Trng.pGlobTomb4->ScreenSizeX;

  0001e	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00023	0f bf 88 0b 20
	1a 00		 movsx	 ecx, WORD PTR [eax+1712139]
  0002a	89 4d f8	 mov	 DWORD PTR _w$[ebp], ecx

; 626  : 	int h = Trng.pGlobTomb4->ScreenSizeY;

  0002d	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  00032	0f bf 88 0d 20
	1a 00		 movsx	 ecx, WORD PTR [eax+1712141]
  00039	89 4d ec	 mov	 DWORD PTR _h$[ebp], ecx

; 627  : 	double ratio = (double) w / (double) h;

  0003c	db 45 f8	 fild	 DWORD PTR _w$[ebp]
  0003f	da 75 ec	 fidiv	 DWORD PTR _h$[ebp]
  00042	dd 5d dc	 fstp	 QWORD PTR _ratio$[ebp]

; 628  : 	Get(enumGET.INFO_LARA, 0, 0);

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	a1 20 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+32
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH

; 629  : 
; 630  : 	//SendToLog("Flyby %d", *Trng.pGlobTomb4->pAdr->pTestFlybyInProgress);
; 631  : 	if (*Trng.pGlobTomb4->pAdr->pTestFlybyInProgress != NoFlyby)

  00057	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0005c	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00062	8b 91 14 01 00
	00		 mov	 edx, DWORD PTR [ecx+276]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?NoFlyby@@3HA ; NoFlyby
  00070	74 05		 je	 SHORT $LN5@WideScreen

; 632  : 		return;

  00072	e9 95 00 00 00	 jmp	 $LN6@WideScreen
$LN5@WideScreen:

; 633  : 
; 634  : 	if (GET.LaraInfo.HoldedItem == HOLD_CROSSBOW)

  00077	83 3d 2b 00 00
	00 06		 cmp	 DWORD PTR ?GET@@3UStrGetLocator@@A+43, 6
  0007e	75 41		 jne	 SHORT $LN2@WideScreen

; 635  : 	{
; 636  : 		Get(enumGET.LARA, 0, 0);

  00080	6a 00		 push	 0
  00082	6a 00		 push	 0
  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 637  : 		if (GET.pLara->StateIdCurrent == AS_STOP)

  00092	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00097	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  0009b	83 f9 02	 cmp	 ecx, 2
  0009e	75 21		 jne	 SHORT $LN2@WideScreen

; 638  : 		{
; 639  : 			Get(enumGET.INPUT, 0, 0);

  000a0	6a 00		 push	 0
  000a2	6a 00		 push	 0
  000a4	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+44
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  000af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 640  : 			if (GET.Input.GameCommandsRead & enumCMD.LOOK)

  000b2	a1 8e 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+142
  000b7	23 05 30 00 00
	00		 and	 eax, DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+48
  000bd	74 02		 je	 SHORT $LN2@WideScreen

; 641  : 			{
; 642  : 				return;

  000bf	eb 4b		 jmp	 SHORT $LN6@WideScreen
$LN2@WideScreen:

; 643  : 			}
; 644  : 		}
; 645  : 	}
; 646  : 	if (*Trng.pGlobTomb4->pAdr->pFlagsLara2 & enumFL2.IS_USING_LASER_SIGHT_OR_BINOCULARS)

  000c1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000c6	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000cc	8b 91 90 00 00
	00		 mov	 edx, DWORD PTR [ecx+144]
  000d2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000d5	23 05 10 00 00
	00		 and	 eax, DWORD PTR ?enumFL2@@3UStrEnumFL2@@A+16
  000db	74 02		 je	 SHORT $LN1@WideScreen

; 647  : 		return;

  000dd	eb 2d		 jmp	 SHORT $LN6@WideScreen
$LN1@WideScreen:

; 648  : 
; 649  : 	//if ((Trng.pGlobTomb4->ScreenSizeX % 16 == 0) && (Trng.pGlobTomb4->ScreenSizeY % 9 == 0))
; 650  : 		//AlterFOV(92 * ONE_DEGREE);	// 16:9
; 651  : 	
; 652  : 	// Joey's FOV formula
; 653  : 	AlterFOV((int)((ratio * 30) + 40) * ONE_DEGREE);

  000df	dd 45 dc	 fld	 QWORD PTR _ratio$[ebp]
  000e2	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@403e000000000000
  000e8	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@4044000000000000
  000ee	e8 00 00 00 00	 call	 __ftol2_sse
  000f3	69 c0 b6 00 00
	00		 imul	 eax, 182		; 000000b6H
  000f9	8b f4		 mov	 esi, esp
  000fb	50		 push	 eax
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR ?AlterFOV@@3P6AXG@ZA ; AlterFOV
  00102	83 c4 04	 add	 esp, 4
  00105	3b f4		 cmp	 esi, esp
  00107	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@WideScreen:

; 654  : }

  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
?WideScreen@@YAXXZ ENDP					; WideScreen
_TEXT	ENDS
PUBLIC	?cbCycleBegin@@YAXXZ				; cbCycleBegin
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbCycleBegin@@YAXXZ
_TEXT	SEGMENT
?cbCycleBegin@@YAXXZ PROC				; cbCycleBegin, COMDAT

; 659  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 660  : 	BinocularsZoom();

  0001e	e8 00 00 00 00	 call	 ?BinocularsZoom@@YAXXZ	; BinocularsZoom

; 661  : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?cbCycleBegin@@YAXXZ ENDP				; cbCycleBegin
_TEXT	ENDS
PUBLIC	?cbCycleEnd@@YAHXZ				; cbCycleEnd
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbCycleEnd@@YAHXZ
_TEXT	SEGMENT
?cbCycleEnd@@YAHXZ PROC					; cbCycleEnd, COMDAT

; 668  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 669  : 	StepDownFix();

  0001e	e8 00 00 00 00	 call	 ?StepDownFix@@YAXXZ	; StepDownFix

; 670  : 	WideScreen();

  00023	e8 00 00 00 00	 call	 ?WideScreen@@YAXXZ	; WideScreen

; 671  : 	return RET_CYCLE_CONTINUE;	

  00028	33 c0		 xor	 eax, eax

; 672  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?cbCycleEnd@@YAHXZ ENDP					; cbCycleEnd
_TEXT	ENDS
PUBLIC	?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z ; PerformMyProgrAction
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
_pAction$ = 8						; size = 4
?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z PROC ; PerformMyProgrAction, COMDAT

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 677  : 
; 678  : 
; 679  : 	switch (pAction->ActionType) {

  0001e	8b 45 08	 mov	 eax, DWORD PTR _pAction$[ebp]
  00021	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00024	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx

; 680  : // replace the "case -1:" with your first "case AXN_...:" progressive action to manage)		
; 681  : 	case -1:
; 682  : 		break;
; 683  : 
; 684  : 	}
; 685  : 
; 686  : }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z ENDP ; PerformMyProgrAction
_TEXT	ENDS
PUBLIC	?cbProgrActionMine@@YAXXZ			; cbProgrActionMine
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbProgrActionMine@@YAXXZ
_TEXT	SEGMENT
_pAction$ = -20						; size = 4
_i$ = -8						; size = 4
?cbProgrActionMine@@YAXXZ PROC				; cbProgrActionMine, COMDAT

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00012	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 690  : 	int i;
; 691  : 	StrProgressiveAction *pAction;
; 692  : 
; 693  : 	pAction = &MyData.VetProgrActions[0];

  0001e	c7 45 ec 0a 00
	00 00		 mov	 DWORD PTR _pAction$[ebp], OFFSET ?MyData@@3UStrMyData@@A+10

; 694  : 	for (i=0;i<MyData.TotProgrActions;i++) {

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0002c	eb 09		 jmp	 SHORT $LN4@cbProgrAct
$LN3@cbProgrAct:
  0002e	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00031	83 c0 01	 add	 eax, 1
  00034	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@cbProgrAct:
  00037	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003a	3b 05 02 00 00
	00		 cmp	 eax, DWORD PTR ?MyData@@3UStrMyData@@A+2
  00040	7d 21		 jge	 SHORT $LN5@cbProgrAct

; 695  : 		if (pAction->ActionType != AXN_FREE) {

  00042	8b 45 ec	 mov	 eax, DWORD PTR _pAction$[ebp]
  00045	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00048	85 c9		 test	 ecx, ecx
  0004a	74 0c		 je	 SHORT $LN1@cbProgrAct

; 696  : 			PerformMyProgrAction(pAction);

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _pAction$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ?PerformMyProgrAction@@YAXPAUStrProgressiveAction@@@Z ; PerformMyProgrAction
  00055	83 c4 04	 add	 esp, 4
$LN1@cbProgrAct:

; 697  : 		}
; 698  : 		pAction++;

  00058	8b 45 ec	 mov	 eax, DWORD PTR _pAction$[ebp]
  0005b	83 c0 20	 add	 eax, 32			; 00000020H
  0005e	89 45 ec	 mov	 DWORD PTR _pAction$[ebp], eax

; 699  : 	}

  00061	eb cb		 jmp	 SHORT $LN3@cbProgrAct
$LN5@cbProgrAct:

; 700  : 
; 701  : 
; 702  : }

  00063	5f		 pop	 edi
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?cbProgrActionMine@@YAXXZ ENDP				; cbProgrActionMine
_TEXT	ENDS
PUBLIC	?InitialiseSearchObject@@YAXH@Z			; InitialiseSearchObject
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?InitialiseSearchObject@@YAXH@Z
_TEXT	SEGMENT
_item$ = -8						; size = 4
_ItemIndex$ = 8						; size = 4
?InitialiseSearchObject@@YAXH@Z PROC			; InitialiseSearchObject, COMDAT

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 709  : 	StrItemTr4 *item;
; 710  : 	Get(enumGET.ITEM, ItemIndex, 0);

  0001e	6a 00		 push	 0
  00020	8b 45 08	 mov	 eax, DWORD PTR _ItemIndex$[ebp]
  00023	50		 push	 eax
  00024	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 711  : 	Get(enumGET.SLOT, GET.pItem->SlotID, 0);

  00033	6a 00		 push	 0
  00035	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  0003a	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0003e	51		 push	 ecx
  0003f	8b 15 5c 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 712  : 	item = GET.pItem;

  0004e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00053	89 45 f8	 mov	 DWORD PTR _item$[ebp], eax

; 713  : 	//item = &items[ItemIndex];
; 714  : 
; 715  : 	//item->AnimationNow = GET.pSlot->IndexFirstAnim;
; 716  : 	Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00056	6a 00		 push	 0
  00058	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  0005b	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0005f	51		 push	 ecx
  00060	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 717  : 	//item->AnimationNow = objects[item->SlotID].IndexFirstAnim;
; 718  : 	item->FrameNow = GET.pAnimation->FrameStart;

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  00072	8b 0d f2 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00078	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  0007c	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 719  : 	//item->FrameNow = anims[item->AnimationNow].FrameStart;
; 720  : 	item->StateIdCurrent = 0;

  00080	33 c0		 xor	 eax, eax
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _item$[ebp]
  00085	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 721  : 	item->StateIdNext = 0;

  00089	33 c0		 xor	 eax, eax
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _item$[ebp]
  0008e	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 722  : 	item->FlagsMain = CFITEM_COLLIDABLE;

  00092	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  00095	c7 80 ea 15 00
	00 20 00 00 00	 mov	 DWORD PTR [eax+5610], 32 ; 00000020H

; 723  : 	AddActiveItem(ItemIndex);

  0009f	8b f4		 mov	 esi, esp
  000a1	0f b7 45 08	 movzx	 eax, WORD PTR _ItemIndex$[ebp]
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR ?AddActiveItem@@3P6AXF@ZA ; AddActiveItem
  000ac	83 c4 04	 add	 esp, 4
  000af	3b f4		 cmp	 esi, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 724  : }

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000bf	3b ec		 cmp	 ebp, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c3		 ret	 0
?InitialiseSearchObject@@YAXH@Z ENDP			; InitialiseSearchObject
_TEXT	ENDS
PUBLIC	?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject
EXTRN	?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z:PROC ; CheckPositionAlignment
EXTRN	?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z:PROC ; AlignLaraAtPosition
EXTRN	?GetMaxDistance@@YAHPAK0_N@Z:PROC		; GetMaxDistance
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z
_TEXT	SEGMENT
_item$ = -8						; size = 4
_ItemIndex$ = 8						; size = 2
_lara$ = 12						; size = 4
_coll$ = 16						; size = 4
?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z PROC ; CollisionSearchObject, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 728  : 	StrItemTr4 *item;
; 729  : 
; 730  : 	Get(enumGET.ITEM, ItemIndex, 0);

  0001e	6a 00		 push	 0
  00020	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  00024	50		 push	 eax
  00025	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 731  : 	item = GET.pItem;

  00034	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00039	89 45 f8	 mov	 DWORD PTR _item$[ebp], eax

; 732  : 	//item = &items[ItemIndex];
; 733  : 
; 734  : 	if (lara->AnimationNow == SO1ANIM || lara->AnimationNow == SO2ANIM || lara->AnimationNow == SO3ANIM || lara->AnimationNow == SO4ANIM)

  0003c	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  0003f	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00043	81 f9 d0 01 00
	00		 cmp	 ecx, 464		; 000001d0H
  00049	74 2d		 je	 SHORT $LN35@CollisionS
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  0004e	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00052	81 f9 d1 01 00
	00		 cmp	 ecx, 465		; 000001d1H
  00058	74 1e		 je	 SHORT $LN35@CollisionS
  0005a	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  0005d	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00061	81 f9 d2 01 00
	00		 cmp	 ecx, 466		; 000001d2H
  00067	74 0f		 je	 SHORT $LN35@CollisionS
  00069	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  0006c	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00070	81 f9 d8 01 00
	00		 cmp	 ecx, 472		; 000001d8H
  00076	75 05		 jne	 SHORT $LN36@CollisionS
$LN35@CollisionS:

; 735  : 		return;

  00078	e9 fd 03 00 00	 jmp	 $LN37@CollisionS
$LN36@CollisionS:

; 736  : 
; 737  : 	if (GetMaxDistance(&item->CordX, &lara->CordX, false) > 1024)

  0007d	6a 00		 push	 0
  0007f	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  00082	83 c0 40	 add	 eax, 64			; 00000040H
  00085	50		 push	 eax
  00086	8b 4d f8	 mov	 ecx, DWORD PTR _item$[ebp]
  00089	83 c1 40	 add	 ecx, 64			; 00000040H
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ?GetMaxDistance@@YAHPAK0_N@Z ; GetMaxDistance
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0009a	7e 05		 jle	 SHORT $LN34@CollisionS

; 738  : 		return;

  0009c	e9 d9 03 00 00	 jmp	 $LN37@CollisionS
$LN34@CollisionS:

; 739  : 
; 740  : 	if (Trng.pGlobTomb4->TestAlignmentInProgress == true && *Trng.pGlobTomb4->pAdr->pObjectActive == ItemIndex)

  000a1	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000a6	0f b6 88 a3 5e
	21 00		 movzx	 ecx, BYTE PTR [eax+2186915]
  000ad	83 f9 01	 cmp	 ecx, 1
  000b0	0f 85 54 01 00
	00		 jne	 $LN33@CollisionS
  000b6	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  000bb	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  000c1	8b 91 94 00 00
	00		 mov	 edx, DWORD PTR [ecx+148]
  000c7	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  000cb	39 02		 cmp	 DWORD PTR [edx], eax
  000cd	0f 85 37 01 00
	00		 jne	 $LN33@CollisionS

; 741  : 	{
; 742  : 		if (item->SlotID == SEARCH_OBJECT1)

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  000d6	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  000da	81 f9 f2 01 00
	00		 cmp	 ecx, 498		; 000001f2H
  000e0	75 37		 jne	 SHORT $LN32@CollisionS

; 743  : 		{
; 744  : 			if (AlignLaraAtPosition(&SearchObject1TestPosition, ItemIndex) == false)

  000e2	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  000e6	50		 push	 eax
  000e7	68 00 00 00 00	 push	 OFFSET ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
  000ec	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  000f1	83 c4 08	 add	 esp, 8
  000f4	0f b6 c8	 movzx	 ecx, al
  000f7	85 c9		 test	 ecx, ecx
  000f9	75 05		 jne	 SHORT $LN31@CollisionS

; 745  : 				return;

  000fb	e9 7a 03 00 00	 jmp	 $LN37@CollisionS
$LN31@CollisionS:

; 746  : 			ForceAnimationForLara(SO1ANIM, -1);

  00100	6a ff		 push	 -1
  00102	68 d0 01 00 00	 push	 464			; 000001d0H
  00107	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  0010c	83 c4 08	 add	 esp, 8

; 747  : 			return;

  0010f	e9 66 03 00 00	 jmp	 $LN37@CollisionS
  00114	e9 f1 00 00 00	 jmp	 $LN33@CollisionS
$LN32@CollisionS:

; 748  : 		}
; 749  : 		else if (item->SlotID == SEARCH_OBJECT2)

  00119	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  0011c	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00120	81 f9 f3 01 00
	00		 cmp	 ecx, 499		; 000001f3H
  00126	75 37		 jne	 SHORT $LN29@CollisionS

; 750  : 		{
; 751  : 			if (AlignLaraAtPosition(&SearchObject2TestPosition, ItemIndex) == false)

  00128	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  0012c	50		 push	 eax
  0012d	68 00 00 00 00	 push	 OFFSET ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
  00132	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  00137	83 c4 08	 add	 esp, 8
  0013a	0f b6 c8	 movzx	 ecx, al
  0013d	85 c9		 test	 ecx, ecx
  0013f	75 05		 jne	 SHORT $LN28@CollisionS

; 752  : 				return;

  00141	e9 34 03 00 00	 jmp	 $LN37@CollisionS
$LN28@CollisionS:

; 753  : 			ForceAnimationForLara(SO2ANIM, -1);

  00146	6a ff		 push	 -1
  00148	68 d1 01 00 00	 push	 465			; 000001d1H
  0014d	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  00152	83 c4 08	 add	 esp, 8

; 754  : 			return;

  00155	e9 20 03 00 00	 jmp	 $LN37@CollisionS
  0015a	e9 ab 00 00 00	 jmp	 $LN33@CollisionS
$LN29@CollisionS:

; 755  : 		}
; 756  : 		else if (item->SlotID == SEARCH_OBJECT3)

  0015f	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  00162	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00166	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  0016c	75 34		 jne	 SHORT $LN26@CollisionS

; 757  : 		{
; 758  : 			if (AlignLaraAtPosition(&SearchObject3TestPosition, ItemIndex) == false)

  0016e	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  00172	50		 push	 eax
  00173	68 00 00 00 00	 push	 OFFSET ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
  00178	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  0017d	83 c4 08	 add	 esp, 8
  00180	0f b6 c8	 movzx	 ecx, al
  00183	85 c9		 test	 ecx, ecx
  00185	75 05		 jne	 SHORT $LN25@CollisionS

; 759  : 				return;

  00187	e9 ee 02 00 00	 jmp	 $LN37@CollisionS
$LN25@CollisionS:

; 760  : 			ForceAnimationForLara(SO3ANIM, -1);

  0018c	6a ff		 push	 -1
  0018e	68 d2 01 00 00	 push	 466			; 000001d2H
  00193	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  00198	83 c4 08	 add	 esp, 8

; 761  : 			return;

  0019b	e9 da 02 00 00	 jmp	 $LN37@CollisionS
  001a0	eb 68		 jmp	 SHORT $LN33@CollisionS
$LN26@CollisionS:

; 762  : 		}
; 763  : 		else if (item->SlotID == SEARCH_OBJECT4)

  001a2	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  001a5	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  001a9	81 f9 f5 01 00
	00		 cmp	 ecx, 501		; 000001f5H
  001af	75 59		 jne	 SHORT $LN33@CollisionS

; 764  : 		{
; 765  : 			if (AlignLaraAtPosition(&SearchObject4TestPosition, ItemIndex) == false)

  001b1	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  001b5	50		 push	 eax
  001b6	68 00 00 00 00	 push	 OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
  001bb	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  001c0	83 c4 08	 add	 esp, 8
  001c3	0f b6 c8	 movzx	 ecx, al
  001c6	85 c9		 test	 ecx, ecx
  001c8	75 05		 jne	 SHORT $LN22@CollisionS

; 766  : 				return;

  001ca	e9 ab 02 00 00	 jmp	 $LN37@CollisionS
$LN22@CollisionS:

; 767  : 			//ForceAnimationForLara(SO4ANIM, -1); // makes it crash
; 768  : 			lara->AnimationNow = SO4ANIM;

  001cf	b8 d8 01 00 00	 mov	 eax, 472		; 000001d8H
  001d4	8b 4d 0c	 mov	 ecx, DWORD PTR _lara$[ebp]
  001d7	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 769  : 			Get(enumGET.ANIMATION, lara->AnimationNow, 0);

  001db	6a 00		 push	 0
  001dd	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  001e0	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  001e4	51		 push	 ecx
  001e5	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  001f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 770  : 			lara->FrameNow = GET.pAnimation->FrameStart;

  001f4	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  001f7	8b 0d f2 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  001fd	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00201	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 771  : 			return;

  00205	e9 70 02 00 00	 jmp	 $LN37@CollisionS
$LN33@CollisionS:

; 772  : 		}
; 773  : 	}
; 774  : 	Get(enumGET.INPUT, 0, 0);

  0020a	6a 00		 push	 0
  0020c	6a 00		 push	 0
  0020e	a1 2c 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+44
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00219	83 c4 0c	 add	 esp, 12			; 0000000cH

; 775  : 	if (GET.Input.GameCommandsRead & enumCMD.ACTION)

  0021c	a1 8e 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+142
  00221	23 05 24 00 00
	00		 and	 eax, DWORD PTR ?enumCMD@@3UStrEnumCMD@@A+36
  00227	0f 84 e1 01 00
	00		 je	 $LN21@CollisionS

; 776  : 	{
; 777  : 		if (lara->StateIdCurrent == 2 && (lara->AnimationNow == 11 || lara->AnimationNow == 103))

  0022d	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  00230	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00234	83 f9 02	 cmp	 ecx, 2
  00237	0f 85 d1 01 00
	00		 jne	 $LN21@CollisionS
  0023d	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  00240	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00244	83 f9 0b	 cmp	 ecx, 11			; 0000000bH
  00247	74 10		 je	 SHORT $LN19@CollisionS
  00249	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  0024c	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00250	83 f9 67	 cmp	 ecx, 103		; 00000067H
  00253	0f 85 b5 01 00
	00		 jne	 $LN21@CollisionS
$LN19@CollisionS:

; 778  : 		{
; 779  : 			if (*Trng.pGlobTomb4->pAdr->pFlagsLaraHands == FLH_ALMOST_FREE_HANDS)

  00259	a1 04 00 00 00	 mov	 eax, DWORD PTR ?Trng@@3UStrTrngInfos@@A+4
  0025e	8b 88 4a 34 19
	00		 mov	 ecx, DWORD PTR [eax+1651786]
  00264	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00267	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0026a	85 c0		 test	 eax, eax
  0026c	0f 85 9c 01 00
	00		 jne	 $LN21@CollisionS

; 780  : 			{
; 781  : 				if (item->SlotID == SEARCH_OBJECT1)

  00272	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  00275	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00279	81 f9 f2 01 00
	00		 cmp	 ecx, 498		; 000001f2H
  0027f	75 51		 jne	 SHORT $LN17@CollisionS

; 782  : 				{
; 783  : 					if (CheckPositionAlignment(&SearchObject1TestPosition, ItemIndex) == true)

  00281	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  00285	50		 push	 eax
  00286	68 00 00 00 00	 push	 OFFSET ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
  0028b	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  00290	83 c4 08	 add	 esp, 8
  00293	0f b6 c8	 movzx	 ecx, al
  00296	83 f9 01	 cmp	 ecx, 1
  00299	75 32		 jne	 SHORT $LN16@CollisionS

; 784  : 					{
; 785  : 						if (AlignLaraAtPosition(&SearchObject1TestPosition, ItemIndex) == false)

  0029b	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  0029f	50		 push	 eax
  002a0	68 00 00 00 00	 push	 OFFSET ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A ; SearchObject1TestPosition
  002a5	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  002aa	83 c4 08	 add	 esp, 8
  002ad	0f b6 c8	 movzx	 ecx, al
  002b0	85 c9		 test	 ecx, ecx
  002b2	75 05		 jne	 SHORT $LN15@CollisionS

; 786  : 							return;

  002b4	e9 c1 01 00 00	 jmp	 $LN37@CollisionS
$LN15@CollisionS:

; 787  : 						ForceAnimationForLara(SO1ANIM, -1);

  002b9	6a ff		 push	 -1
  002bb	68 d0 01 00 00	 push	 464			; 000001d0H
  002c0	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  002c5	83 c4 08	 add	 esp, 8

; 788  : 						return;

  002c8	e9 ad 01 00 00	 jmp	 $LN37@CollisionS
$LN16@CollisionS:

; 789  : 					}
; 790  : 				}

  002cd	e9 3c 01 00 00	 jmp	 $LN21@CollisionS
$LN17@CollisionS:

; 791  : 				else if (item->SlotID == SEARCH_OBJECT2)

  002d2	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  002d5	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  002d9	81 f9 f3 01 00
	00		 cmp	 ecx, 499		; 000001f3H
  002df	75 51		 jne	 SHORT $LN13@CollisionS

; 792  : 				{
; 793  : 					if (CheckPositionAlignment(&SearchObject2TestPosition, ItemIndex) == true)

  002e1	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  002e5	50		 push	 eax
  002e6	68 00 00 00 00	 push	 OFFSET ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
  002eb	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  002f0	83 c4 08	 add	 esp, 8
  002f3	0f b6 c8	 movzx	 ecx, al
  002f6	83 f9 01	 cmp	 ecx, 1
  002f9	75 32		 jne	 SHORT $LN12@CollisionS

; 794  : 					{
; 795  : 						if (AlignLaraAtPosition(&SearchObject2TestPosition, ItemIndex) == false)

  002fb	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  002ff	50		 push	 eax
  00300	68 00 00 00 00	 push	 OFFSET ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A ; SearchObject2TestPosition
  00305	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  0030a	83 c4 08	 add	 esp, 8
  0030d	0f b6 c8	 movzx	 ecx, al
  00310	85 c9		 test	 ecx, ecx
  00312	75 05		 jne	 SHORT $LN11@CollisionS

; 796  : 							return;

  00314	e9 61 01 00 00	 jmp	 $LN37@CollisionS
$LN11@CollisionS:

; 797  : 						ForceAnimationForLara(SO2ANIM, -1);

  00319	6a ff		 push	 -1
  0031b	68 d1 01 00 00	 push	 465			; 000001d1H
  00320	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  00325	83 c4 08	 add	 esp, 8

; 798  : 						return;

  00328	e9 4d 01 00 00	 jmp	 $LN37@CollisionS
$LN12@CollisionS:

; 799  : 					}
; 800  : 				}

  0032d	e9 dc 00 00 00	 jmp	 $LN21@CollisionS
$LN13@CollisionS:

; 801  : 				else if (item->SlotID == SEARCH_OBJECT3)

  00332	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  00335	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00339	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  0033f	75 4e		 jne	 SHORT $LN9@CollisionS

; 802  : 				{
; 803  : 					if (CheckPositionAlignment(&SearchObject3TestPosition, ItemIndex) == true)

  00341	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  00345	50		 push	 eax
  00346	68 00 00 00 00	 push	 OFFSET ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
  0034b	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  00350	83 c4 08	 add	 esp, 8
  00353	0f b6 c8	 movzx	 ecx, al
  00356	83 f9 01	 cmp	 ecx, 1
  00359	75 32		 jne	 SHORT $LN8@CollisionS

; 804  : 					{
; 805  : 						if (AlignLaraAtPosition(&SearchObject3TestPosition, ItemIndex) == false)

  0035b	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  0035f	50		 push	 eax
  00360	68 00 00 00 00	 push	 OFFSET ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A ; SearchObject3TestPosition
  00365	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  0036a	83 c4 08	 add	 esp, 8
  0036d	0f b6 c8	 movzx	 ecx, al
  00370	85 c9		 test	 ecx, ecx
  00372	75 05		 jne	 SHORT $LN7@CollisionS

; 806  : 							return;

  00374	e9 01 01 00 00	 jmp	 $LN37@CollisionS
$LN7@CollisionS:

; 807  : 						ForceAnimationForLara(SO3ANIM, -1);

  00379	6a ff		 push	 -1
  0037b	68 d2 01 00 00	 push	 466			; 000001d2H
  00380	e8 00 00 00 00	 call	 ?ForceAnimationForLara@@YAXHH@Z ; ForceAnimationForLara
  00385	83 c4 08	 add	 esp, 8

; 808  : 						return;

  00388	e9 ed 00 00 00	 jmp	 $LN37@CollisionS
$LN8@CollisionS:

; 809  : 					}
; 810  : 				}

  0038d	eb 7f		 jmp	 SHORT $LN21@CollisionS
$LN9@CollisionS:

; 811  : 				else if (item->SlotID == SEARCH_OBJECT4)

  0038f	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  00392	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00396	81 f9 f5 01 00
	00		 cmp	 ecx, 501		; 000001f5H
  0039c	75 70		 jne	 SHORT $LN21@CollisionS

; 812  : 				{
; 813  : 					if (CheckPositionAlignment(&SearchObject4TestPosition, ItemIndex) == true)

  0039e	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  003a2	50		 push	 eax
  003a3	68 00 00 00 00	 push	 OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
  003a8	e8 00 00 00 00	 call	 ?CheckPositionAlignment@@YA_NPAUStrTestPositionCmd@@H@Z ; CheckPositionAlignment
  003ad	83 c4 08	 add	 esp, 8
  003b0	0f b6 c8	 movzx	 ecx, al
  003b3	83 f9 01	 cmp	 ecx, 1
  003b6	75 56		 jne	 SHORT $LN21@CollisionS

; 814  : 					{
; 815  : 						if (AlignLaraAtPosition(&SearchObject4TestPosition, ItemIndex) == false)

  003b8	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  003bc	50		 push	 eax
  003bd	68 00 00 00 00	 push	 OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A ; SearchObject4TestPosition
  003c2	e8 00 00 00 00	 call	 ?AlignLaraAtPosition@@YA_NPAUStrTestPositionCmd@@H@Z ; AlignLaraAtPosition
  003c7	83 c4 08	 add	 esp, 8
  003ca	0f b6 c8	 movzx	 ecx, al
  003cd	85 c9		 test	 ecx, ecx
  003cf	75 05		 jne	 SHORT $LN3@CollisionS

; 816  : 							return;

  003d1	e9 a4 00 00 00	 jmp	 $LN37@CollisionS
$LN3@CollisionS:

; 817  : 						//ForceAnimationForLara(SO4ANIM, -1);
; 818  : 						lara->AnimationNow = SO4ANIM;

  003d6	b8 d8 01 00 00	 mov	 eax, 472		; 000001d8H
  003db	8b 4d 0c	 mov	 ecx, DWORD PTR _lara$[ebp]
  003de	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 819  : 						Get(enumGET.ANIMATION, lara->AnimationNow, 0);

  003e2	6a 00		 push	 0
  003e4	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  003e7	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  003eb	51		 push	 ecx
  003ec	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  003f2	52		 push	 edx
  003f3	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  003f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 820  : 						lara->FrameNow = GET.pAnimation->FrameStart;

  003fb	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  003fe	8b 0d f2 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00404	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00408	66 89 50 16	 mov	 WORD PTR [eax+22], dx

; 821  : 						return;

  0040c	eb 6c		 jmp	 SHORT $LN37@CollisionS
$LN21@CollisionS:

; 822  : 					}
; 823  : 				}
; 824  : 			}
; 825  : 		}
; 826  : 	}
; 827  : 	if (!TestBoundCollide(item, lara, coll->LaraSizeX))

  0040e	8b f4		 mov	 esi, esp
  00410	8b 45 10	 mov	 eax, DWORD PTR _coll$[ebp]
  00413	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00416	51		 push	 ecx
  00417	8b 55 0c	 mov	 edx, DWORD PTR _lara$[ebp]
  0041a	52		 push	 edx
  0041b	8b 45 f8	 mov	 eax, DWORD PTR _item$[ebp]
  0041e	50		 push	 eax
  0041f	ff 15 00 00 00
	00		 call	 DWORD PTR ?TestBoundCollide@@3P6A_NPAUStrItemTr4@@0H@ZA ; TestBoundCollide
  00425	83 c4 0c	 add	 esp, 12			; 0000000cH
  00428	3b f4		 cmp	 esi, esp
  0042a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0042f	0f b6 c8	 movzx	 ecx, al
  00432	85 c9		 test	 ecx, ecx
  00434	75 02		 jne	 SHORT $LN2@CollisionS

; 828  : 		return;

  00436	eb 42		 jmp	 SHORT $LN37@CollisionS
$LN2@CollisionS:

; 829  : 	if (!TestCollision(item, lara))

  00438	8b f4		 mov	 esi, esp
  0043a	8b 45 0c	 mov	 eax, DWORD PTR _lara$[ebp]
  0043d	50		 push	 eax
  0043e	8b 4d f8	 mov	 ecx, DWORD PTR _item$[ebp]
  00441	51		 push	 ecx
  00442	ff 15 00 00 00
	00		 call	 DWORD PTR ?TestCollision@@3P6AKPAUStrItemTr4@@0@ZA ; TestCollision
  00448	83 c4 08	 add	 esp, 8
  0044b	3b f4		 cmp	 esi, esp
  0044d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00452	85 c0		 test	 eax, eax
  00454	75 02		 jne	 SHORT $LN1@CollisionS

; 830  : 		return;

  00456	eb 22		 jmp	 SHORT $LN37@CollisionS
$LN1@CollisionS:

; 831  : 
; 832  : 	ItemPushLara(item, lara, coll, 0, 1);

  00458	8b f4		 mov	 esi, esp
  0045a	6a 01		 push	 1
  0045c	6a 00		 push	 0
  0045e	8b 45 10	 mov	 eax, DWORD PTR _coll$[ebp]
  00461	50		 push	 eax
  00462	8b 4d 0c	 mov	 ecx, DWORD PTR _lara$[ebp]
  00465	51		 push	 ecx
  00466	8b 55 f8	 mov	 edx, DWORD PTR _item$[ebp]
  00469	52		 push	 edx
  0046a	ff 15 00 00 00
	00		 call	 DWORD PTR ?ItemPushLara@@3P6AXPAUStrItemTr4@@0PAUStrCollisionLara@@_NH@ZA ; ItemPushLara
  00470	83 c4 14	 add	 esp, 20			; 00000014H
  00473	3b f4		 cmp	 esi, esp
  00475	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN37@CollisionS:

; 833  : }

  0047a	5f		 pop	 edi
  0047b	5e		 pop	 esi
  0047c	5b		 pop	 ebx
  0047d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00483	3b ec		 cmp	 ebp, esp
  00485	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0048a	8b e5		 mov	 esp, ebp
  0048c	5d		 pop	 ebp
  0048d	c3		 ret	 0
?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ENDP ; CollisionSearchObject
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SearchObjectControl@@YAXF@Z			; SearchObjectControl
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?SearchObjectControl@@YAXF@Z
_TEXT	SEGMENT
_pos$46100 = -44					; size = 12
_lara$ = -24						; size = 4
_item$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_ItemIndex$ = 8						; size = 2
?SearchObjectControl@@YAXF@Z PROC			; SearchObjectControl, COMDAT

; 836  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-240]
  00012	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 837  : 	StrItemTr4 *item;
; 838  : 	StrItemTr4 *lara;
; 839  : 
; 840  : 	Get(enumGET.ITEM, ItemIndex, 0);

  00028	6a 00		 push	 0
  0002a	0f bf 45 08	 movsx	 eax, WORD PTR _ItemIndex$[ebp]
  0002e	50		 push	 eax
  0002f	8b 0d 04 00 00
	00		 mov	 ecx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+4
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 841  : 	item = GET.pItem;

  0003e	a1 08 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+8
  00043	89 45 f4	 mov	 DWORD PTR _item$[ebp], eax

; 842  : 	Get(enumGET.SLOT, item->SlotID, 0);

  00046	6a 00		 push	 0
  00048	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0004b	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0004f	51		 push	 ecx
  00050	8b 15 5c 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 843  : 	Get(enumGET.LARA, 0, 0);

  0005f	6a 00		 push	 0
  00061	6a 00		 push	 0
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 844  : 	lara = GET.pLara;

  00071	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A
  00076	89 45 e8	 mov	 DWORD PTR _lara$[ebp], eax

; 845  : 
; 846  : 	// no need to animate if it's not the opening animation
; 847  : 	if (item->AnimationNow == GET.pSlot->IndexFirstAnim + 1)

  00079	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0007c	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00080	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00086	0f b7 42 26	 movzx	 eax, WORD PTR [edx+38]
  0008a	83 c0 01	 add	 eax, 1
  0008d	3b c8		 cmp	 ecx, eax
  0008f	75 16		 jne	 SHORT $LN19@SearchObje

; 848  : 		AnimateItem(item);

  00091	8b f4		 mov	 esi, esp
  00093	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR ?AnimateItem@@3P6AXPAUStrItemTr4@@@ZA ; AnimateItem
  0009d	83 c4 04	 add	 esp, 4
  000a0	3b f4		 cmp	 esi, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN19@SearchObje:

; 849  : 
; 850  : 	if (lara->AnimationNow == SO1ANIM || lara->AnimationNow == SO2ANIM || lara->AnimationNow == SO3ANIM || lara->AnimationNow == SO4ANIM)

  000a7	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  000aa	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  000ae	81 f9 d0 01 00
	00		 cmp	 ecx, 464		; 000001d0H
  000b4	74 31		 je	 SHORT $LN17@SearchObje
  000b6	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  000b9	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  000bd	81 f9 d1 01 00
	00		 cmp	 ecx, 465		; 000001d1H
  000c3	74 22		 je	 SHORT $LN17@SearchObje
  000c5	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  000c8	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  000cc	81 f9 d2 01 00
	00		 cmp	 ecx, 466		; 000001d2H
  000d2	74 13		 je	 SHORT $LN17@SearchObje
  000d4	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  000d7	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  000db	81 f9 d8 01 00
	00		 cmp	 ecx, 472		; 000001d8H
  000e1	0f 85 8c 02 00
	00		 jne	 $LN18@SearchObje
$LN17@SearchObje:

; 851  : 	{
; 852  : 		if (GetMaxDistance(&item->CordX, &lara->CordX, false) < 512)

  000e7	6a 00		 push	 0
  000e9	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  000ec	83 c0 40	 add	 eax, 64			; 00000040H
  000ef	50		 push	 eax
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR _item$[ebp]
  000f3	83 c1 40	 add	 ecx, 64			; 00000040H
  000f6	51		 push	 ecx
  000f7	e8 00 00 00 00	 call	 ?GetMaxDistance@@YAHPAK0_N@Z ; GetMaxDistance
  000fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ff	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00104	7d 55		 jge	 SHORT $LN16@SearchObje

; 853  : 		{
; 854  : 			//ForceAnimationForItem(item, GetRelativeAnimation(GET.pItem) + 1, 0);
; 855  : 			if (item->AnimationNow != GET.pSlot->IndexFirstAnim + 1)

  00106	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00109	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0010d	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00113	0f b7 42 26	 movzx	 eax, WORD PTR [edx+38]
  00117	83 c0 01	 add	 eax, 1
  0011a	3b c8		 cmp	 ecx, eax
  0011c	74 3d		 je	 SHORT $LN16@SearchObje

; 856  : 			{
; 857  : 				item->AnimationNow = GET.pSlot->IndexFirstAnim + 1;

  0011e	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00123	0f b7 48 26	 movzx	 ecx, WORD PTR [eax+38]
  00127	83 c1 01	 add	 ecx, 1
  0012a	8b 55 f4	 mov	 edx, DWORD PTR _item$[ebp]
  0012d	66 89 4a 14	 mov	 WORD PTR [edx+20], cx

; 858  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00131	6a 00		 push	 0
  00133	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00136	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0013a	51		 push	 ecx
  0013b	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 859  : 				item->FrameNow = GET.pAnimation->FrameStart;

  0014a	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0014d	8b 0d f2 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00153	66 8b 51 18	 mov	 dx, WORD PTR [ecx+24]
  00157	66 89 50 16	 mov	 WORD PTR [eax+22], dx
$LN16@SearchObje:

; 860  : 			}
; 861  : 		}
; 862  : 		if (item->OcbCode != 0)

  0015b	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0015e	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  00162	85 c9		 test	 ecx, ecx
  00164	0f 84 07 02 00
	00		 je	 $LN14@SearchObje

; 863  : 		{
; 864  : 			StrMovePosition pos;
; 865  : 			pos.RelX = lara->CordX;

  0016a	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  0016d	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00170	89 4d d4	 mov	 DWORD PTR _pos$46100[ebp], ecx

; 866  : 			pos.RelY = lara->CordY;

  00173	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  00176	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00179	89 4d d8	 mov	 DWORD PTR _pos$46100[ebp+4], ecx

; 867  : 			pos.RelZ = lara->CordZ;

  0017c	8b 45 e8	 mov	 eax, DWORD PTR _lara$[ebp]
  0017f	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  00182	89 4d dc	 mov	 DWORD PTR _pos$46100[ebp+8], ecx

; 868  : 
; 869  : 			if (item->SlotID == SEARCH_OBJECT1)

  00185	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00188	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0018c	81 f9 f2 01 00
	00		 cmp	 ecx, 498		; 000001f2H
  00192	75 6f		 jne	 SHORT $LN13@SearchObje

; 870  : 			{
; 871  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00194	6a 00		 push	 0
  00196	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00199	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0019d	51		 push	 ecx
  0019e	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 872  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO1)

  001ad	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  001b0	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  001b4	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  001ba	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  001be	05 b4 00 00 00	 add	 eax, 180		; 000000b4H
  001c3	3b c8		 cmp	 ecx, eax
  001c5	75 37		 jne	 SHORT $LN12@SearchObje

; 873  : 				{
; 874  : 					GetItem(item->OcbCode, 1, 1);

  001c7	6a 01		 push	 1
  001c9	6a 01		 push	 1
  001cb	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  001ce	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  001d2	51		 push	 ecx
  001d3	e8 00 00 00 00	 call	 ?GetItem@@YAXHH_N@Z	; GetItem
  001d8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 875  : 					item->OcbCode = 0;

  001db	33 c0		 xor	 eax, eax
  001dd	8b 4d f4	 mov	 ecx, DWORD PTR _item$[ebp]
  001e0	66 89 41 2c	 mov	 WORD PTR [ecx+44], ax

; 876  : 					SoundEffect(62, &pos, 0);

  001e4	8b f4		 mov	 esi, esp
  001e6	6a 00		 push	 0
  001e8	8d 45 d4	 lea	 eax, DWORD PTR _pos$46100[ebp]
  001eb	50		 push	 eax
  001ec	6a 3e		 push	 62			; 0000003eH
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR ?SoundEffect@@3P6AXHPAXH@ZA ; SoundEffect
  001f4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001f7	3b f4		 cmp	 esi, esp
  001f9	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN12@SearchObje:

; 877  : 				}
; 878  : 			}

  001fe	e9 6e 01 00 00	 jmp	 $LN14@SearchObje
$LN13@SearchObje:

; 879  : 			else if (item->SlotID == SEARCH_OBJECT2)

  00203	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00206	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  0020a	81 f9 f3 01 00
	00		 cmp	 ecx, 499		; 000001f3H
  00210	75 6d		 jne	 SHORT $LN10@SearchObje

; 880  : 			{
; 881  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00212	6a 00		 push	 0
  00214	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00217	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0021b	51		 push	 ecx
  0021c	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00222	52		 push	 edx
  00223	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00228	83 c4 0c	 add	 esp, 12			; 0000000cH

; 882  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO2)

  0022b	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0022e	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00232	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  00238	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  0023c	83 c0 64	 add	 eax, 100		; 00000064H
  0023f	3b c8		 cmp	 ecx, eax
  00241	75 37		 jne	 SHORT $LN9@SearchObje

; 883  : 				{
; 884  : 					GetItem(item->OcbCode, 1, 1);

  00243	6a 01		 push	 1
  00245	6a 01		 push	 1
  00247	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0024a	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  0024e	51		 push	 ecx
  0024f	e8 00 00 00 00	 call	 ?GetItem@@YAXHH_N@Z	; GetItem
  00254	83 c4 0c	 add	 esp, 12			; 0000000cH

; 885  : 					item->OcbCode = 0;

  00257	33 c0		 xor	 eax, eax
  00259	8b 4d f4	 mov	 ecx, DWORD PTR _item$[ebp]
  0025c	66 89 41 2c	 mov	 WORD PTR [ecx+44], ax

; 886  : 					SoundEffect(62, &pos, 0);

  00260	8b f4		 mov	 esi, esp
  00262	6a 00		 push	 0
  00264	8d 45 d4	 lea	 eax, DWORD PTR _pos$46100[ebp]
  00267	50		 push	 eax
  00268	6a 3e		 push	 62			; 0000003eH
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR ?SoundEffect@@3P6AXHPAXH@ZA ; SoundEffect
  00270	83 c4 0c	 add	 esp, 12			; 0000000cH
  00273	3b f4		 cmp	 esi, esp
  00275	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN9@SearchObje:

; 887  : 				}
; 888  : 			}

  0027a	e9 f2 00 00 00	 jmp	 $LN14@SearchObje
$LN10@SearchObje:

; 889  : 			else if (item->SlotID == SEARCH_OBJECT3)

  0027f	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00282	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00286	81 f9 f4 01 00
	00		 cmp	 ecx, 500		; 000001f4H
  0028c	75 6c		 jne	 SHORT $LN7@SearchObje

; 890  : 			{
; 891  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  0028e	6a 00		 push	 0
  00290	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00293	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00297	51		 push	 ecx
  00298	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  0029e	52		 push	 edx
  0029f	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  002a4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 892  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO3)

  002a7	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  002aa	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  002ae	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  002b4	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  002b8	05 99 00 00 00	 add	 eax, 153		; 00000099H
  002bd	3b c8		 cmp	 ecx, eax
  002bf	75 37		 jne	 SHORT $LN6@SearchObje

; 893  : 				{
; 894  : 					GetItem(item->OcbCode, 1, 1);

  002c1	6a 01		 push	 1
  002c3	6a 01		 push	 1
  002c5	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  002c8	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  002cc	51		 push	 ecx
  002cd	e8 00 00 00 00	 call	 ?GetItem@@YAXHH_N@Z	; GetItem
  002d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 895  : 					item->OcbCode = 0;

  002d5	33 c0		 xor	 eax, eax
  002d7	8b 4d f4	 mov	 ecx, DWORD PTR _item$[ebp]
  002da	66 89 41 2c	 mov	 WORD PTR [ecx+44], ax

; 896  : 					SoundEffect(62, &pos, 0);

  002de	8b f4		 mov	 esi, esp
  002e0	6a 00		 push	 0
  002e2	8d 45 d4	 lea	 eax, DWORD PTR _pos$46100[ebp]
  002e5	50		 push	 eax
  002e6	6a 3e		 push	 62			; 0000003eH
  002e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?SoundEffect@@3P6AXHPAXH@ZA ; SoundEffect
  002ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  002f1	3b f4		 cmp	 esi, esp
  002f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@SearchObje:

; 897  : 				}
; 898  : 			}

  002f8	eb 77		 jmp	 SHORT $LN14@SearchObje
$LN7@SearchObje:

; 899  : 			else if (item->SlotID == SEARCH_OBJECT4)

  002fa	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  002fd	0f b7 48 0c	 movzx	 ecx, WORD PTR [eax+12]
  00301	81 f9 f5 01 00
	00		 cmp	 ecx, 501		; 000001f5H
  00307	75 68		 jne	 SHORT $LN14@SearchObje

; 900  : 			{
; 901  : 				Get(enumGET.ANIMATION, item->AnimationNow, 0);

  00309	6a 00		 push	 0
  0030b	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0030e	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00312	51		 push	 ecx
  00313	8b 15 64 00 00
	00		 mov	 edx, DWORD PTR ?enumGET@@3UStrEnumGET@@A+100
  00319	52		 push	 edx
  0031a	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  0031f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 902  : 				if (item->FrameNow == GET.pAnimation->FrameStart + PICKUPSO4)

  00322	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00325	0f b7 48 16	 movzx	 ecx, WORD PTR [eax+22]
  00329	8b 15 f2 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+242
  0032f	0f b7 42 18	 movzx	 eax, WORD PTR [edx+24]
  00333	83 c0 53	 add	 eax, 83			; 00000053H
  00336	3b c8		 cmp	 ecx, eax
  00338	75 37		 jne	 SHORT $LN14@SearchObje

; 903  : 				{
; 904  : 					GetItem(item->OcbCode, 1, 1);

  0033a	6a 01		 push	 1
  0033c	6a 01		 push	 1
  0033e	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00341	0f b7 48 2c	 movzx	 ecx, WORD PTR [eax+44]
  00345	51		 push	 ecx
  00346	e8 00 00 00 00	 call	 ?GetItem@@YAXHH_N@Z	; GetItem
  0034b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 905  : 					item->OcbCode = 0;

  0034e	33 c0		 xor	 eax, eax
  00350	8b 4d f4	 mov	 ecx, DWORD PTR _item$[ebp]
  00353	66 89 41 2c	 mov	 WORD PTR [ecx+44], ax

; 906  : 					SoundEffect(62, &pos, 0);

  00357	8b f4		 mov	 esi, esp
  00359	6a 00		 push	 0
  0035b	8d 45 d4	 lea	 eax, DWORD PTR _pos$46100[ebp]
  0035e	50		 push	 eax
  0035f	6a 3e		 push	 62			; 0000003eH
  00361	ff 15 00 00 00
	00		 call	 DWORD PTR ?SoundEffect@@3P6AXHPAXH@ZA ; SoundEffect
  00367	83 c4 0c	 add	 esp, 12			; 0000000cH
  0036a	3b f4		 cmp	 esi, esp
  0036c	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN14@SearchObje:

; 907  : 				}
; 908  : 			}
; 909  : 		}
; 910  : 	}

  00371	eb 26		 jmp	 SHORT $LN20@SearchObje
$LN18@SearchObje:

; 911  : 	// Prevent opening animation from looping
; 912  : 	else if (!(item->AnimationNow == GET.pSlot->IndexFirstAnim))

  00373	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  00376	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0037a	8b 15 ea 00 00
	00		 mov	 edx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00380	0f b7 42 26	 movzx	 eax, WORD PTR [edx+38]
  00384	3b c8		 cmp	 ecx, eax
  00386	74 11		 je	 SHORT $LN20@SearchObje

; 913  : 	{
; 914  : 		item->AnimationNow = GET.pSlot->IndexFirstAnim;

  00388	8b 45 f4	 mov	 eax, DWORD PTR _item$[ebp]
  0038b	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00391	66 8b 51 26	 mov	 dx, WORD PTR [ecx+38]
  00395	66 89 50 14	 mov	 WORD PTR [eax+20], dx
$LN20@SearchObje:

; 915  : 	}
; 916  : 	return;
; 917  : }

  00399	52		 push	 edx
  0039a	8b cd		 mov	 ecx, ebp
  0039c	50		 push	 eax
  0039d	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN24@SearchObje
  003a3	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003a8	58		 pop	 eax
  003a9	5a		 pop	 edx
  003aa	5f		 pop	 edi
  003ab	5e		 pop	 esi
  003ac	5b		 pop	 ebx
  003ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003b0	33 cd		 xor	 ecx, ebp
  003b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003b7	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  003bd	3b ec		 cmp	 ebp, esp
  003bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c4	8b e5		 mov	 esp, ebp
  003c6	5d		 pop	 ebp
  003c7	c3		 ret	 0
$LN24@SearchObje:
  003c8	01 00 00 00	 DD	 1
  003cc	00 00 00 00	 DD	 $LN23@SearchObje
$LN23@SearchObje:
  003d0	d4 ff ff ff	 DD	 -44			; ffffffd4H
  003d4	0c 00 00 00	 DD	 12			; 0000000cH
  003d8	00 00 00 00	 DD	 $LN22@SearchObje
$LN22@SearchObje:
  003dc	70		 DB	 112			; 00000070H
  003dd	6f		 DB	 111			; 0000006fH
  003de	73		 DB	 115			; 00000073H
  003df	00		 DB	 0
?SearchObjectControl@@YAXF@Z ENDP			; SearchObjectControl
_TEXT	ENDS
PUBLIC	?InitSearchObject1@@YAXXZ			; InitSearchObject1
EXTRN	?enumFSLOT@@3UStrEnumFSLOT@@A:BYTE		; enumFSLOT
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?InitSearchObject1@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject1@@YAXXZ PROC				; InitSearchObject1, COMDAT

; 920  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 921  : 	Get(enumGET.SLOT, SEARCH_OBJECT1, 0);

  0001e	6a 00		 push	 0
  00020	68 f2 01 00 00	 push	 498			; 000001f2H
  00025	a1 5c 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 922  : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0) {

  00033	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00038	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 0b		 je	 SHORT $LN1@InitSearch
  00040	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00047	75 02		 jne	 SHORT $LN1@InitSearch

; 923  : 		return;

  00049	eb 33		 jmp	 SHORT $LN2@InitSearch
$LN1@InitSearch:

; 924  : 	}
; 925  : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  0004b	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 926  : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  00057	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0005c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 927  : 	GET.pSlot->pProcControl = SearchObjectControl;

  00063	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00068	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 928  : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  0006f	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00074	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0007a	66 89 41 32	 mov	 WORD PTR [ecx+50], ax
$LN2@InitSearch:

; 929  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?InitSearchObject1@@YAXXZ ENDP				; InitSearchObject1
_TEXT	ENDS
PUBLIC	?InitSearchObject2@@YAXXZ			; InitSearchObject2
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?InitSearchObject2@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject2@@YAXXZ PROC				; InitSearchObject2, COMDAT

; 932  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 933  : 	Get(enumGET.SLOT, SEARCH_OBJECT2, 0);

  0001e	6a 00		 push	 0
  00020	68 f3 01 00 00	 push	 499			; 000001f3H
  00025	a1 5c 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 934  : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0) {

  00033	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00038	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 0b		 je	 SHORT $LN1@InitSearch@2
  00040	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00047	75 02		 jne	 SHORT $LN1@InitSearch@2

; 935  : 		return;

  00049	eb 33		 jmp	 SHORT $LN2@InitSearch@2
$LN1@InitSearch@2:

; 936  : 	}
; 937  : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  0004b	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 938  : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  00057	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0005c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 939  : 	GET.pSlot->pProcControl = SearchObjectControl;

  00063	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00068	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 940  : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  0006f	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00074	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0007a	66 89 41 32	 mov	 WORD PTR [ecx+50], ax
$LN2@InitSearch@2:

; 941  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?InitSearchObject2@@YAXXZ ENDP				; InitSearchObject2
_TEXT	ENDS
PUBLIC	?InitSearchObject3@@YAXXZ			; InitSearchObject3
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?InitSearchObject3@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject3@@YAXXZ PROC				; InitSearchObject3, COMDAT

; 944  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 945  : 	Get(enumGET.SLOT, SEARCH_OBJECT3, 0);

  0001e	6a 00		 push	 0
  00020	68 f4 01 00 00	 push	 500			; 000001f4H
  00025	a1 5c 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 946  : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0) {

  00033	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00038	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 0b		 je	 SHORT $LN1@InitSearch@3
  00040	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00047	75 02		 jne	 SHORT $LN1@InitSearch@3

; 947  : 		return;

  00049	eb 33		 jmp	 SHORT $LN2@InitSearch@3
$LN1@InitSearch@3:

; 948  : 	}
; 949  : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  0004b	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 950  : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  00057	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0005c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 951  : 	GET.pSlot->pProcControl = SearchObjectControl;

  00063	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00068	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 952  : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  0006f	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00074	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0007a	66 89 41 32	 mov	 WORD PTR [ecx+50], ax
$LN2@InitSearch@3:

; 953  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?InitSearchObject3@@YAXXZ ENDP				; InitSearchObject3
_TEXT	ENDS
PUBLIC	?InitSearchObject4@@YAXXZ			; InitSearchObject4
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?InitSearchObject4@@YAXXZ
_TEXT	SEGMENT
?InitSearchObject4@@YAXXZ PROC				; InitSearchObject4, COMDAT

; 956  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 957  : 	Get(enumGET.SLOT, SEARCH_OBJECT4, 0);

  0001e	6a 00		 push	 0
  00020	68 f5 01 00 00	 push	 501			; 000001f5H
  00025	a1 5c 00 00 00	 mov	 eax, DWORD PTR ?enumGET@@3UStrEnumGET@@A+92
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?Get@@YA_NHHH@Z		; Get
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 958  : 	if (GET.pSlot->Flags && enumFSLOT.PRESENT == 0)

  00033	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00038	0f b7 48 32	 movzx	 ecx, WORD PTR [eax+50]
  0003c	85 c9		 test	 ecx, ecx
  0003e	74 0b		 je	 SHORT $LN1@InitSearch@4
  00040	83 3d 04 00 00
	00 00		 cmp	 DWORD PTR ?enumFSLOT@@3UStrEnumFSLOT@@A+4, 0
  00047	75 02		 jne	 SHORT $LN1@InitSearch@4

; 959  : 		return;

  00049	eb 33		 jmp	 SHORT $LN2@InitSearch@4
$LN1@InitSearch@4:

; 960  : 
; 961  : 	GET.pSlot->pProcInitialise = InitialiseSearchObject;

  0004b	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [eax+12], OFFSET ?InitialiseSearchObject@@YAXH@Z ; InitialiseSearchObject

; 962  : 	GET.pSlot->pProcCollision = CollisionSearchObject;

  00057	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0005c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ?CollisionSearchObject@@YAXFPAUStrItemTr4@@PAUStrCollisionLara@@@Z ; CollisionSearchObject

; 963  : 	GET.pSlot->pProcControl = SearchObjectControl;

  00063	a1 ea 00 00 00	 mov	 eax, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  00068	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], OFFSET ?SearchObjectControl@@YAXF@Z ; SearchObjectControl

; 964  : 	GET.pSlot->Flags = CFSLOT_SAVE_ANIM | CFSLOT_SAVE_FLAGS;

  0006f	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00074	8b 0d ea 00 00
	00		 mov	 ecx, DWORD PTR ?GET@@3UStrGetLocator@@A+234
  0007a	66 89 41 32	 mov	 WORD PTR [ecx+50], ax
$LN2@InitSearch@4:

; 965  : }

  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00087	3b ec		 cmp	 ebp, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?InitSearchObject4@@YAXXZ ENDP				; InitSearchObject4
_TEXT	ENDS
PUBLIC	?cbInitObjects@@YAXXZ				; cbInitObjects
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?cbInitObjects@@YAXXZ
_TEXT	SEGMENT
?cbInitObjects@@YAXXZ PROC				; cbInitObjects, COMDAT

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 969  : 	InitSearchObject1();

  0001e	e8 00 00 00 00	 call	 ?InitSearchObject1@@YAXXZ ; InitSearchObject1

; 970  : 	InitSearchObject2();

  00023	e8 00 00 00 00	 call	 ?InitSearchObject2@@YAXXZ ; InitSearchObject2

; 971  : 	InitSearchObject3();

  00028	e8 00 00 00 00	 call	 ?InitSearchObject3@@YAXXZ ; InitSearchObject3

; 972  : 	InitSearchObject4();

  0002d	e8 00 00 00 00	 call	 ?InitSearchObject4@@YAXXZ ; InitSearchObject4

; 973  : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?cbInitObjects@@YAXXZ ENDP				; cbInitObjects
_TEXT	ENDS
PUBLIC	?RequireMyCallBacks@@YA_NXZ			; RequireMyCallBacks
EXTRN	?GetCallBack@@YA_NHHGPAX@Z:PROC			; GetCallBack
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?RequireMyCallBacks@@YA_NXZ
_TEXT	SEGMENT
?RequireMyCallBacks@@YA_NXZ PROC			; RequireMyCallBacks, COMDAT

; 982  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 983  : // ************  RequireMyCallBacks() function  *****************
; 984  : 	// protype of GET_CALLBACK:
; 985  : 	// GET_CALLBACK(CallBackCB, CBT_Flags, Index, MyProcToCall)
; 986  : 	// default callbacks required always 
; 987  : 	GET_CALLBACK(CB_INIT_PROGRAM, 0, 0, cbInitProgram)

  0001e	68 00 00 00 00	 push	 OFFSET ?cbInitProgram@@YAXHQAPAD@Z ; cbInitProgram
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN16@RequireMyC
  00038	32 c0		 xor	 al, al
  0003a	e9 e2 01 00 00	 jmp	 $LN17@RequireMyC
$LN16@RequireMyC:

; 988  : 	GET_CALLBACK(CB_INIT_GAME, 0, 0, cbInitGame)

  0003f	68 00 00 00 00	 push	 OFFSET ?cbInitGame@@YAXXZ ; cbInitGame
  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	6a 03		 push	 3
  0004a	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	0f b6 c0	 movzx	 eax, al
  00055	85 c0		 test	 eax, eax
  00057	75 07		 jne	 SHORT $LN15@RequireMyC
  00059	32 c0		 xor	 al, al
  0005b	e9 c1 01 00 00	 jmp	 $LN17@RequireMyC
$LN15@RequireMyC:

; 989  : 	GET_CALLBACK(CB_INIT_LEVEL, 0,0, cbInitLevel)

  00060	68 00 00 00 00	 push	 OFFSET ?cbInitLevel@@YAXHHK@Z ; cbInitLevel
  00065	6a 00		 push	 0
  00067	6a 00		 push	 0
  00069	6a 10		 push	 16			; 00000010H
  0006b	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00070	83 c4 10	 add	 esp, 16			; 00000010H
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	75 07		 jne	 SHORT $LN14@RequireMyC
  0007a	32 c0		 xor	 al, al
  0007c	e9 a0 01 00 00	 jmp	 $LN17@RequireMyC
$LN14@RequireMyC:

; 990  : 	GET_CALLBACK(CB_SAVING_GAME, 0, 0, cbSaveMyData)

  00081	68 00 00 00 00	 push	 OFFSET ?cbSaveMyData@@YAKPAPAEH@Z ; cbSaveMyData
  00086	6a 00		 push	 0
  00088	6a 00		 push	 0
  0008a	6a 01		 push	 1
  0008c	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00091	83 c4 10	 add	 esp, 16			; 00000010H
  00094	0f b6 c0	 movzx	 eax, al
  00097	85 c0		 test	 eax, eax
  00099	75 07		 jne	 SHORT $LN13@RequireMyC
  0009b	32 c0		 xor	 al, al
  0009d	e9 7f 01 00 00	 jmp	 $LN17@RequireMyC
$LN13@RequireMyC:

; 991  : 	GET_CALLBACK(CB_LOADING_GAME, 0, 0, cbLoadMyData)

  000a2	68 00 00 00 00	 push	 OFFSET ?cbLoadMyData@@YAXPAEK@Z ; cbLoadMyData
  000a7	6a 00		 push	 0
  000a9	6a 00		 push	 0
  000ab	6a 02		 push	 2
  000ad	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  000b2	83 c4 10	 add	 esp, 16			; 00000010H
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 07		 jne	 SHORT $LN12@RequireMyC
  000bc	32 c0		 xor	 al, al
  000be	e9 5e 01 00 00	 jmp	 $LN17@RequireMyC
$LN12@RequireMyC:

; 992  : 	GET_CALLBACK(CB_INIT_LOAD_NEW_LEVEL, 0,0, cbInitLoadNewLevel);

  000c3	68 00 00 00 00	 push	 OFFSET ?cbInitLoadNewLevel@@YAXXZ ; cbInitLoadNewLevel
  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	6a 04		 push	 4
  000ce	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  000d3	83 c4 10	 add	 esp, 16			; 00000010H
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	85 c0		 test	 eax, eax
  000db	75 07		 jne	 SHORT $LN11@RequireMyC
  000dd	32 c0		 xor	 al, al
  000df	e9 3d 01 00 00	 jmp	 $LN17@RequireMyC
$LN11@RequireMyC:

; 993  : 	GET_CALLBACK(CB_FLIPEFFECT_MINE, 0, 0, cbFlipEffectMine);

  000e4	68 00 00 00 00	 push	 OFFSET ?cbFlipEffectMine@@YAHGGGG@Z ; cbFlipEffectMine
  000e9	6a 00		 push	 0
  000eb	6a 00		 push	 0
  000ed	6a 05		 push	 5
  000ef	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  000f4	83 c4 10	 add	 esp, 16			; 00000010H
  000f7	0f b6 c0	 movzx	 eax, al
  000fa	85 c0		 test	 eax, eax
  000fc	75 07		 jne	 SHORT $LN10@RequireMyC
  000fe	32 c0		 xor	 al, al
  00100	e9 1c 01 00 00	 jmp	 $LN17@RequireMyC
$LN10@RequireMyC:

; 994  : 	GET_CALLBACK(CB_ACTION_MINE, 0,0, cbActionMine);

  00105	68 00 00 00 00	 push	 OFFSET ?cbActionMine@@YAHGHGG@Z ; cbActionMine
  0010a	6a 00		 push	 0
  0010c	6a 00		 push	 0
  0010e	6a 06		 push	 6
  00110	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00115	83 c4 10	 add	 esp, 16			; 00000010H
  00118	0f b6 c0	 movzx	 eax, al
  0011b	85 c0		 test	 eax, eax
  0011d	75 07		 jne	 SHORT $LN9@RequireMyC
  0011f	32 c0		 xor	 al, al
  00121	e9 fb 00 00 00	 jmp	 $LN17@RequireMyC
$LN9@RequireMyC:

; 995  : 	GET_CALLBACK(CB_CONDITION_MINE,0,0,cbConditionMine);

  00126	68 00 00 00 00	 push	 OFFSET ?cbConditionMine@@YAHGHGG@Z ; cbConditionMine
  0012b	6a 00		 push	 0
  0012d	6a 00		 push	 0
  0012f	6a 07		 push	 7
  00131	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00136	83 c4 10	 add	 esp, 16			; 00000010H
  00139	0f b6 c0	 movzx	 eax, al
  0013c	85 c0		 test	 eax, eax
  0013e	75 07		 jne	 SHORT $LN8@RequireMyC
  00140	32 c0		 xor	 al, al
  00142	e9 da 00 00 00	 jmp	 $LN17@RequireMyC
$LN8@RequireMyC:

; 996  : 	GET_CALLBACK(CB_CUSTOMIZE_MINE, 0,0, cbCustomizeMine);

  00147	68 00 00 00 00	 push	 OFFSET ?cbCustomizeMine@@YAXGHPAF@Z ; cbCustomizeMine
  0014c	6a 00		 push	 0
  0014e	6a 00		 push	 0
  00150	6a 08		 push	 8
  00152	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00157	83 c4 10	 add	 esp, 16			; 00000010H
  0015a	0f b6 c0	 movzx	 eax, al
  0015d	85 c0		 test	 eax, eax
  0015f	75 07		 jne	 SHORT $LN7@RequireMyC
  00161	32 c0		 xor	 al, al
  00163	e9 b9 00 00 00	 jmp	 $LN17@RequireMyC
$LN7@RequireMyC:

; 997  : 	GET_CALLBACK(CB_PARAMETER_MINE, 0, 0, cbParametersMine);

  00168	68 00 00 00 00	 push	 OFFSET ?cbParametersMine@@YAXGHPAF@Z ; cbParametersMine
  0016d	6a 00		 push	 0
  0016f	6a 00		 push	 0
  00171	6a 09		 push	 9
  00173	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00178	83 c4 10	 add	 esp, 16			; 00000010H
  0017b	0f b6 c0	 movzx	 eax, al
  0017e	85 c0		 test	 eax, eax
  00180	75 07		 jne	 SHORT $LN6@RequireMyC
  00182	32 c0		 xor	 al, al
  00184	e9 98 00 00 00	 jmp	 $LN17@RequireMyC
$LN6@RequireMyC:

; 998  : 	GET_CALLBACK(CB_ASSIGN_SLOT_MINE, 0,0, cbAssignSlotMine);

  00189	68 00 00 00 00	 push	 OFFSET ?cbAssignSlotMine@@YAXGG@Z ; cbAssignSlotMine
  0018e	6a 00		 push	 0
  00190	6a 00		 push	 0
  00192	6a 13		 push	 19			; 00000013H
  00194	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00199	83 c4 10	 add	 esp, 16			; 00000010H
  0019c	0f b6 c0	 movzx	 eax, al
  0019f	85 c0		 test	 eax, eax
  001a1	75 04		 jne	 SHORT $LN5@RequireMyC
  001a3	32 c0		 xor	 al, al
  001a5	eb 7a		 jmp	 SHORT $LN17@RequireMyC
$LN5@RequireMyC:

; 999  : 	GET_CALLBACK(CB_CYCLE_BEGIN, 0, 0, cbCycleBegin);

  001a7	68 00 00 00 00	 push	 OFFSET ?cbCycleBegin@@YAXXZ ; cbCycleBegin
  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	6a 0a		 push	 10			; 0000000aH
  001b2	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  001b7	83 c4 10	 add	 esp, 16			; 00000010H
  001ba	0f b6 c0	 movzx	 eax, al
  001bd	85 c0		 test	 eax, eax
  001bf	75 04		 jne	 SHORT $LN4@RequireMyC
  001c1	32 c0		 xor	 al, al
  001c3	eb 5c		 jmp	 SHORT $LN17@RequireMyC
$LN4@RequireMyC:

; 1000 : 	GET_CALLBACK(CB_PROGR_ACTION_MINE, 0, 0, cbProgrActionMine);

  001c5	68 00 00 00 00	 push	 OFFSET ?cbProgrActionMine@@YAXXZ ; cbProgrActionMine
  001ca	6a 00		 push	 0
  001cc	6a 00		 push	 0
  001ce	6a 0e		 push	 14			; 0000000eH
  001d0	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  001d5	83 c4 10	 add	 esp, 16			; 00000010H
  001d8	0f b6 c0	 movzx	 eax, al
  001db	85 c0		 test	 eax, eax
  001dd	75 04		 jne	 SHORT $LN3@RequireMyC
  001df	32 c0		 xor	 al, al
  001e1	eb 3e		 jmp	 SHORT $LN17@RequireMyC
$LN3@RequireMyC:

; 1001 : 	GET_CALLBACK(CB_INIT_OBJECTS, 0, 0, cbInitObjects);

  001e3	68 00 00 00 00	 push	 OFFSET ?cbInitObjects@@YAXXZ ; cbInitObjects
  001e8	6a 00		 push	 0
  001ea	6a 00		 push	 0
  001ec	6a 0d		 push	 13			; 0000000dH
  001ee	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  001f3	83 c4 10	 add	 esp, 16			; 00000010H
  001f6	0f b6 c0	 movzx	 eax, al
  001f9	85 c0		 test	 eax, eax
  001fb	75 04		 jne	 SHORT $LN2@RequireMyC
  001fd	32 c0		 xor	 al, al
  001ff	eb 20		 jmp	 SHORT $LN17@RequireMyC
$LN2@RequireMyC:

; 1002 : 	GET_CALLBACK(CB_CYCLE_END, 0, 0, cbCycleEnd);

  00201	68 00 00 00 00	 push	 OFFSET ?cbCycleEnd@@YAHXZ ; cbCycleEnd
  00206	6a 00		 push	 0
  00208	6a 00		 push	 0
  0020a	6a 0b		 push	 11			; 0000000bH
  0020c	e8 00 00 00 00	 call	 ?GetCallBack@@YA_NHHGPAX@Z ; GetCallBack
  00211	83 c4 10	 add	 esp, 16			; 00000010H
  00214	0f b6 c0	 movzx	 eax, al
  00217	85 c0		 test	 eax, eax
  00219	75 04		 jne	 SHORT $LN1@RequireMyC
  0021b	32 c0		 xor	 al, al
  0021d	eb 02		 jmp	 SHORT $LN17@RequireMyC
$LN1@RequireMyC:

; 1003 : 
; 1004 : 	return true;

  0021f	b0 01		 mov	 al, 1
$LN17@RequireMyC:

; 1005 : }

  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx
  00224	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0022a	3b ec		 cmp	 ebp, esp
  0022c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c3		 ret	 0
?RequireMyCallBacks@@YA_NXZ ENDP			; RequireMyCallBacks
_TEXT	ENDS
PUBLIC	?InitializeAll@@YA_NXZ				; InitializeAll
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?InitializeAll@@YA_NXZ
_TEXT	SEGMENT
_pPos$ = -8						; size = 4
?InitializeAll@@YA_NXZ PROC				; InitializeAll, COMDAT

; 1015 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1016 : 	StrTestPosition *pPos;
; 1017 : 	OldZoom = 128;

  0001e	c7 05 00 00 00
	00 80 00 00 00	 mov	 DWORD PTR ?OldZoom@@3HA, 128 ; OldZoom, 00000080H

; 1018 : // ************  InitializeAll() function  ****************
; 1019 : 	//  perform all your patches
; 1020 : 	CALL_CHECK(CreateMyCodePatches)

  00028	e8 00 00 00 00	 call	 ?CreateMyCodePatches@@YA_NXZ ; CreateMyCodePatches
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	75 07		 jne	 SHORT $LN2@Initialize
  00034	32 c0		 xor	 al, al
  00036	e9 8d 02 00 00	 jmp	 $LN3@Initialize
$LN2@Initialize:

; 1021 : 
; 1022 : 	// call the function that requires all callback you need
; 1023 : 	CALL_CHECK(RequireMyCallBacks)

  0003b	e8 00 00 00 00	 call	 ?RequireMyCallBacks@@YA_NXZ ; RequireMyCallBacks
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	75 07		 jne	 SHORT $LN1@Initialize
  00047	32 c0		 xor	 al, al
  00049	e9 7a 02 00 00	 jmp	 $LN3@Initialize
$LN1@Initialize:

; 1024 : 
; 1025 : 	// TYPE_HERE: code to allocate global resource to use in the whole game
; 1026 : 
; 1027 : 	SearchObject1TestPosition.Slot = SEARCH_OBJECT1;

  0004e	b8 f2 01 00 00	 mov	 eax, 498		; 000001f2H
  00053	66 a3 04 00 00
	00		 mov	 WORD PTR ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+4, ax

; 1028 : 	pPos = &SearchObject1TestPosition.DatiPosition;

  00059	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _pPos$[ebp], OFFSET ?SearchObject1TestPosition@@3UStrTestPositionCmd@@A+6

; 1029 : 	pPos->Distance.MinX = 0 - 256;

  00060	b8 00 ff ff ff	 mov	 eax, -256		; ffffff00H
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00068	66 89 01	 mov	 WORD PTR [ecx], ax

; 1030 : 	pPos->Distance.MaxX = 0 + 256;

  0006b	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00073	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 1031 : 	pPos->Distance.MinY = 0;

  00077	33 c0		 xor	 eax, eax
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0007c	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 1032 : 	pPos->Distance.MaxY = 0;

  00080	33 c0		 xor	 eax, eax
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00085	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 1033 : 	pPos->Distance.MinZ = 0 - 512;

  00089	b8 00 fe ff ff	 mov	 eax, -512		; fffffe00H
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00091	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 1034 : 	pPos->Distance.MaxZ = 0 + 512;

  00095	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0009d	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 1035 : 	pPos->Orienting.OrientHMin = -10 * ONE_DEGREE;

  000a1	b8 e4 f8 ff ff	 mov	 eax, -1820		; fffff8e4H
  000a6	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000a9	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 1036 : 	pPos->Orienting.OrientHMax = 10 * ONE_DEGREE;

  000ad	b8 1c 07 00 00	 mov	 eax, 1820		; 0000071cH
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000b5	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1037 : 	pPos->Orienting.OrientRMin = -30 * ONE_DEGREE;

  000b9	b8 ac ea ff ff	 mov	 eax, -5460		; ffffeaacH
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000c1	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 1038 : 	pPos->Orienting.OrientRMax = 30 * ONE_DEGREE;

  000c5	b8 54 15 00 00	 mov	 eax, 5460		; 00001554H
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000cd	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 1039 : 	pPos->Orienting.OrientVMin = -10 * ONE_DEGREE;

  000d1	b8 e4 f8 ff ff	 mov	 eax, -1820		; fffff8e4H
  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000d9	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 1040 : 	pPos->Orienting.OrientVMax = 10 * ONE_DEGREE;

  000dd	b8 1c 07 00 00	 mov	 eax, 1820		; 0000071cH
  000e2	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000e5	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 1041 : 	/*pPos->Distance.MinX = -512;
; 1042 : 	pPos->Distance.MaxX = 512;
; 1043 : 	pPos->Distance.MinY = -128;
; 1044 : 	pPos->Distance.MaxY = 128;
; 1045 : 	pPos->Distance.MinZ = -192;
; 1046 : 	pPos->Distance.MaxZ = 192;
; 1047 : 
; 1048 : 	pPos->Orienting.OrientHMin = -6000;
; 1049 : 	pPos->Orienting.OrientHMax = 6000;
; 1050 : 	pPos->Orienting.OrientVMin = -1000;
; 1051 : 	pPos->Orienting.OrientVMax = 1000;
; 1052 : 	pPos->Orienting.OrientRMin = -1000;
; 1053 : 	pPos->Orienting.OrientRMax = 1000;*/
; 1054 : 
; 1055 : 	// Search Object2
; 1056 : 	SearchObject2TestPosition.Slot = SEARCH_OBJECT2;

  000e9	b8 f3 01 00 00	 mov	 eax, 499		; 000001f3H
  000ee	66 a3 04 00 00
	00		 mov	 WORD PTR ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+4, ax

; 1057 : 	pPos = &SearchObject2TestPosition.DatiPosition;

  000f4	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _pPos$[ebp], OFFSET ?SearchObject2TestPosition@@3UStrTestPositionCmd@@A+6

; 1058 : 	pPos->Distance.MinX = -256;

  000fb	b8 00 ff ff ff	 mov	 eax, -256		; ffffff00H
  00100	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00103	66 89 01	 mov	 WORD PTR [ecx], ax

; 1059 : 	pPos->Distance.MaxX = 256;

  00106	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0010e	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 1060 : 	pPos->Distance.MinY = -128;

  00112	b8 80 ff ff ff	 mov	 eax, -128		; ffffff80H
  00117	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0011a	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 1061 : 	pPos->Distance.MaxY = 128;

  0011e	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00126	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 1062 : 	pPos->Distance.MinZ = 128-332;

  0012a	b8 34 ff ff ff	 mov	 eax, -204		; ffffff34H
  0012f	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00132	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 1063 : 	pPos->Distance.MaxZ = 160;

  00136	b8 a0 00 00 00	 mov	 eax, 160		; 000000a0H
  0013b	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0013e	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 1064 : 
; 1065 : 	pPos->Orienting.OrientHMin = -6000;

  00142	b8 90 e8 ff ff	 mov	 eax, -6000		; ffffe890H
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0014a	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 1066 : 	pPos->Orienting.OrientHMax = 6000;

  0014e	b8 70 17 00 00	 mov	 eax, 6000		; 00001770H
  00153	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00156	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1067 : 	pPos->Orienting.OrientVMin = -1000;

  0015a	b8 18 fc ff ff	 mov	 eax, -1000		; fffffc18H
  0015f	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00162	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 1068 : 	pPos->Orienting.OrientVMax = 1000;

  00166	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0016b	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0016e	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 1069 : 	pPos->Orienting.OrientRMin = -1000;

  00172	b8 18 fc ff ff	 mov	 eax, -1000		; fffffc18H
  00177	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0017a	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 1070 : 	pPos->Orienting.OrientRMax = 1000;

  0017e	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00183	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00186	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 1071 : 
; 1072 : 	// Search Object3
; 1073 : 	SearchObject3TestPosition.Slot = SEARCH_OBJECT3;

  0018a	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  0018f	66 a3 04 00 00
	00		 mov	 WORD PTR ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+4, ax

; 1074 : 	pPos = &SearchObject3TestPosition.DatiPosition;

  00195	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _pPos$[ebp], OFFSET ?SearchObject3TestPosition@@3UStrTestPositionCmd@@A+6

; 1075 : 	pPos->Distance.MinX = -512;

  0019c	b8 00 fe ff ff	 mov	 eax, -512		; fffffe00H
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001a4	66 89 01	 mov	 WORD PTR [ecx], ax

; 1076 : 	pPos->Distance.MaxX = 512;

  001a7	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  001ac	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001af	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 1077 : 	pPos->Distance.MinY = -128;

  001b3	b8 80 ff ff ff	 mov	 eax, -128		; ffffff80H
  001b8	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001bb	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 1078 : 	pPos->Distance.MaxY = 128;

  001bf	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  001c4	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001c7	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 1079 : 	pPos->Distance.MinZ = -192;

  001cb	b8 40 ff ff ff	 mov	 eax, -192		; ffffff40H
  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001d3	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 1080 : 	pPos->Distance.MaxZ = 192;

  001d7	b8 c0 00 00 00	 mov	 eax, 192		; 000000c0H
  001dc	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001df	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 1081 : 
; 1082 : 	pPos->Orienting.OrientHMin = -6000;

  001e3	b8 90 e8 ff ff	 mov	 eax, -6000		; ffffe890H
  001e8	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001eb	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 1083 : 	pPos->Orienting.OrientHMax = 6000;

  001ef	b8 70 17 00 00	 mov	 eax, 6000		; 00001770H
  001f4	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  001f7	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1084 : 	pPos->Orienting.OrientVMin = -1000;

  001fb	b8 18 fc ff ff	 mov	 eax, -1000		; fffffc18H
  00200	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00203	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 1085 : 	pPos->Orienting.OrientVMax = 1000;

  00207	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0020c	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0020f	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 1086 : 	pPos->Orienting.OrientRMin = -1000;

  00213	b8 18 fc ff ff	 mov	 eax, -1000		; fffffc18H
  00218	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0021b	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 1087 : 	pPos->Orienting.OrientRMax = 1000;

  0021f	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  00224	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00227	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 1088 : 
; 1089 : 	// Search Object 4
; 1090 : 	SearchObject4TestPosition.Slot = SEARCH_OBJECT4;

  0022b	b8 f5 01 00 00	 mov	 eax, 501		; 000001f5H
  00230	66 a3 04 00 00
	00		 mov	 WORD PTR ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+4, ax

; 1091 : 	pPos = &SearchObject4TestPosition.DatiPosition;

  00236	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR _pPos$[ebp], OFFSET ?SearchObject4TestPosition@@3UStrTestPositionCmd@@A+6

; 1092 : 	pPos->Distance.MinX = 0 - 256;

  0023d	b8 00 ff ff ff	 mov	 eax, -256		; ffffff00H
  00242	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00245	66 89 01	 mov	 WORD PTR [ecx], ax

; 1093 : 	pPos->Distance.MaxX = 0 + 256;

  00248	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0024d	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00250	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 1094 : 	pPos->Distance.MinY = 0;

  00254	33 c0		 xor	 eax, eax
  00256	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00259	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 1095 : 	pPos->Distance.MaxY = 0;

  0025d	33 c0		 xor	 eax, eax
  0025f	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00262	66 89 41 06	 mov	 WORD PTR [ecx+6], ax

; 1096 : 	pPos->Distance.MinZ = -313 - 256;

  00266	b8 c7 fd ff ff	 mov	 eax, -569		; fffffdc7H
  0026b	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0026e	66 89 41 08	 mov	 WORD PTR [ecx+8], ax

; 1097 : 	pPos->Distance.MaxZ = -313 + 256;

  00272	b8 c7 ff ff ff	 mov	 eax, -57		; ffffffc7H
  00277	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0027a	66 89 41 0a	 mov	 WORD PTR [ecx+10], ax

; 1098 : 	pPos->Orienting.OrientHMin = -10 * ONE_DEGREE;

  0027e	b8 e4 f8 ff ff	 mov	 eax, -1820		; fffff8e4H
  00283	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00286	66 89 41 10	 mov	 WORD PTR [ecx+16], ax

; 1099 : 	pPos->Orienting.OrientHMax = 10 * ONE_DEGREE;

  0028a	b8 1c 07 00 00	 mov	 eax, 1820		; 0000071cH
  0028f	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00292	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1100 : 	pPos->Orienting.OrientRMin = -30 * ONE_DEGREE;

  00296	b8 ac ea ff ff	 mov	 eax, -5460		; ffffeaacH
  0029b	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0029e	66 89 41 14	 mov	 WORD PTR [ecx+20], ax

; 1101 : 	pPos->Orienting.OrientRMax = 30 * ONE_DEGREE;

  002a2	b8 54 15 00 00	 mov	 eax, 5460		; 00001554H
  002a7	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  002aa	66 89 41 16	 mov	 WORD PTR [ecx+22], ax

; 1102 : 	pPos->Orienting.OrientVMin = -10 * ONE_DEGREE;

  002ae	b8 e4 f8 ff ff	 mov	 eax, -1820		; fffff8e4H
  002b3	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  002b6	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax

; 1103 : 	pPos->Orienting.OrientVMax = 10 * ONE_DEGREE;

  002ba	b8 1c 07 00 00	 mov	 eax, 1820		; 0000071cH
  002bf	8b 4d f8	 mov	 ecx, DWORD PTR _pPos$[ebp]
  002c2	66 89 41 0e	 mov	 WORD PTR [ecx+14], ax

; 1104 : 
; 1105 : 
; 1106 : 	return true;

  002c6	b0 01		 mov	 al, 1
$LN3@Initialize:

; 1107 : }

  002c8	5f		 pop	 edi
  002c9	5e		 pop	 esi
  002ca	5b		 pop	 ebx
  002cb	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  002d1	3b ec		 cmp	 ebp, esp
  002d3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002d8	8b e5		 mov	 esp, ebp
  002da	5d		 pop	 ebp
  002db	c3		 ret	 0
?InitializeAll@@YA_NXZ ENDP				; InitializeAll
_TEXT	ENDS
PUBLIC	?ReleaseAll@@YAXXZ				; ReleaseAll
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?ReleaseAll@@YAXXZ
_TEXT	SEGMENT
?ReleaseAll@@YAXXZ PROC					; ReleaseAll, COMDAT

; 1113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1114 : // ************  ReleaseAll() function  ******************
; 1115 : 	FreeLevelResources();

  0001e	e8 00 00 00 00	 call	 ?FreeLevelResources@@YAXXZ ; FreeLevelResources

; 1116 : }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?ReleaseAll@@YAXXZ ENDP					; ReleaseAll
_TEXT	ENDS
PUBLIC	_DllMain@12
EXTRN	?CheckControlGlobTomb4@@YA_NXZ:PROC		; CheckControlGlobTomb4
EXTRN	?GetTrngInfo@@YAXXZ:PROC			; GetTrngInfo
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT _DllMain@12
_TEXT	SEGMENT
tv64 = -196						; size = 4
_hInstanceDll$ = 8					; size = 4
_ul_reason_for_call$ = 12				; size = 4
_lpReserved$ = 16					; size = 4
_DllMain@12 PROC					; COMDAT

; 1122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 1123 : 
; 1124 :     switch (ul_reason_for_call)

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _ul_reason_for_call$[ebp]
  00021	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00027	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR tv64[ebp], 0
  0002e	74 3f		 je	 SHORT $LN1@DllMain
  00030	83 bd 3c ff ff
	ff 01		 cmp	 DWORD PTR tv64[ebp], 1
  00037	74 02		 je	 SHORT $LN4@DllMain
  00039	eb 39		 jmp	 SHORT $LN5@DllMain
$LN4@DllMain:

; 1125 : 	{
; 1126 : 		case DLL_PROCESS_ATTACH:
; 1127 : 			MyDllInstance = hInstanceDll;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _hInstanceDll$[ebp]
  0003e	a3 00 00 00 00	 mov	 DWORD PTR ?MyDllInstance@@3PAUHINSTANCE__@@A, eax ; MyDllInstance

; 1128 : 			GetTrngInfo();

  00043	e8 00 00 00 00	 call	 ?GetTrngInfo@@YAXXZ	; GetTrngInfo

; 1129 : 			// control per check control value about size and alignment with globtomb4 structure
; 1130 : 			if (CheckControlGlobTomb4() == false) return FALSE;

  00048	e8 00 00 00 00	 call	 ?CheckControlGlobTomb4@@YA_NXZ ; CheckControlGlobTomb4
  0004d	0f b6 c0	 movzx	 eax, al
  00050	85 c0		 test	 eax, eax
  00052	75 04		 jne	 SHORT $LN3@DllMain
  00054	33 c0		 xor	 eax, eax
  00056	eb 21		 jmp	 SHORT $LN7@DllMain
$LN3@DllMain:

; 1131 : 
; 1132 : 			if  (InitializeAll()==false) {

  00058	e8 00 00 00 00	 call	 ?InitializeAll@@YA_NXZ	; InitializeAll
  0005d	0f b6 c0	 movzx	 eax, al
  00060	85 c0		 test	 eax, eax
  00062	75 04		 jne	 SHORT $LN2@DllMain

; 1133 : 				return FALSE;

  00064	33 c0		 xor	 eax, eax
  00066	eb 11		 jmp	 SHORT $LN7@DllMain
$LN2@DllMain:

; 1134 : 			}
; 1135 : 			return TRUE;

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	eb 0a		 jmp	 SHORT $LN7@DllMain
$LN1@DllMain:

; 1136 : 			
; 1137 : 
; 1138 : 		case DLL_PROCESS_DETACH:
; 1139 : 			ReleaseAll();

  0006f	e8 00 00 00 00	 call	 ?ReleaseAll@@YAXXZ	; ReleaseAll
$LN5@DllMain:

; 1140 : 			break;
; 1141 :     }
; 1142 :     return TRUE;

  00074	b8 01 00 00 00	 mov	 eax, 1
$LN7@DllMain:

; 1143 : }

  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00082	3b ec		 cmp	 ebp, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
END
